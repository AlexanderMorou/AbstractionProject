 /* ----------------------------------------------------------\
 |  This code was generated by Allen Copeland's Abstraction.  |
 |  Version: 0.5.0.0                                          |
 |------------------------------------------------------------|
 |  To ensure the code works properly,                        |
 |  please do not make any changes to the file.               |
 |------------------------------------------------------------|
 |  The specific language is C♯                               |
 |  Sub-tool Name: C♯ Code Translator                         |
 |  Sub-tool Version: 1.0.0.0                                 |
 \---------------------------------------------------------- */
using AllenCopeland.Abstraction.IO;
using AllenCopeland.Abstraction.Slf.Cli.Metadata;
using AllenCopeland.Abstraction.Slf.Cli.Metadata.Tables;
using System;
using System.IO;
namespace AllenCopeland.Abstraction.Slf._Internal.Cli.Metadata.Tables
{
    /// <summary>
    /// Provides a table which defines the processor of the target machine of the assembly.
    /// </summary>
    /// <remarks>
    /// This record should not be emitted into any PE image; however if present, it should
    /// be treated as if all its fields were zero. Supported to ensure proper reading of the
    /// metadata.
    /// </remarks>
    internal class CliMetadataAssemblyProcessorTableReader :
        CliMetadataLazyTable<ICliMetadataAssemblyProcessorTableRow>, 
        ICliMetadataTable, 
        ICliMetadataAssemblyProcessorTable
    {
        private ICliMetadataRoot metadataRoot;
        private EndianAwareBinaryReader reader;
        private object syncObject;
        private FileStream fStream;
        private uint rowCount;
        /// <summary>
        /// Size constant used when the total size of the <see cref="CliMetadataAssemblyProcessorLockedTableRow"/>
        /// is 4 bytes long.
        /// </summary>
        internal const int __COR_ASSEMBLYPROCESSOR_CALC_SIZE_1__ = 4;
        /// <summary>
        /// Data member which denotes where in the original stream the <see cref="CliMetadataAssemblyProcessorTableReader"/>
        /// is.
        /// </summary>
        private long streamOffset;
        private long length;
        private bool fullyRead;
        public override CliMetadataTableKinds Kind
        {
            get
            {
                return CliMetadataTableKinds.AssemblyProcessor;
            }
        }
        public long Length
        {
            get
            {
                return this.length;
            }
        }
        /// <param name="streamOffset">
        /// The <see cref="Int64"/> value which denotes where in the stream of <see cref="reader"/>
        /// the <see cref="CliMetadataAssemblyProcessorTableReader"/> is.
        /// </param>
        internal void Initialize(long streamOffset)
        {
            this.streamOffset = streamOffset;
            this.length = CliMetadataAssemblyProcessorTableReader.__COR_ASSEMBLYPROCESSOR_CALC_SIZE_1__ * this.rowCount;
        }
        protected override ICliMetadataAssemblyProcessorTableRow ReadElementAt(uint index)
        {
            bool gotLock = false;
            System.Threading.Monitor.Enter(this.syncObject, ref gotLock);
            if (index == 0)
                return null;
            this.fStream.Seek(this.streamOffset + (index - 1) * CliMetadataAssemblyProcessorTableReader.__COR_ASSEMBLYPROCESSOR_CALC_SIZE_1__, SeekOrigin.Begin);
            uint processor = this.reader.ReadUInt32();
            if (gotLock)
                System.Threading.Monitor.Exit(this.syncObject);
            return new CliMetadataAssemblyProcessorLockedTableRow(processor);
        }
        public override void Read()
        {
            if (this.fullyRead)
                return;
            for (uint index = 1; index <= this.Count; index++)
            {
                bool gotLock = false;
                System.Threading.Monitor.Enter(this.syncObject, ref gotLock);
                if (!base.ItemLoaded(index))
                {
                    this.fStream.Seek(this.streamOffset + (index - 1) * CliMetadataAssemblyProcessorTableReader.__COR_ASSEMBLYPROCESSOR_CALC_SIZE_1__, SeekOrigin.Begin);
                    uint processor = this.reader.ReadUInt32();
                    base.InjectLoadedItem(new CliMetadataAssemblyProcessorLockedTableRow(processor), index);
                }
                if (gotLock)
                    System.Threading.Monitor.Exit(this.syncObject);
            }
            this.fullyRead = true;
        }
        public CliMetadataAssemblyProcessorTableReader(ICliMetadataRoot metadataRoot, Tuple<object, FileStream, EndianAwareBinaryReader> readerInfo, uint rowCount)
            : base(metadataRoot, rowCount)
        {
            this.metadataRoot = metadataRoot;
            this.syncObject = readerInfo.Item1;
            this.fStream = readerInfo.Item2;
            this.reader = readerInfo.Item3;
            this.rowCount = rowCount;
        }
    };
};
