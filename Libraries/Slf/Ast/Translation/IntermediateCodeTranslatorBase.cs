using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using AllenCopeland.Abstraction.Slf.Ast;
using AllenCopeland.Abstraction.Slf.Ast.Expressions;
using AllenCopeland.Abstraction.Slf.Ast.Expressions.Lambda;
using AllenCopeland.Abstraction.Slf.Ast.Expressions.Linq;
using AllenCopeland.Abstraction.Slf.Ast.Members;
using AllenCopeland.Abstraction.Slf.Ast.Statements;
using AllenCopeland.Abstraction.Slf.Abstract.Members;
using AllenCopeland.Abstraction.Slf.Abstract;
using System.CodeDom.Compiler;
using AllenCopeland.Abstraction.Utilities.Collections;
using System.Text.RegularExpressions;
/*---------------------------------------------------------------------\
| Copyright © 2008-2016 Allen C. [Alexander Morou] Copeland Jr.        |
|----------------------------------------------------------------------|
| The Abstraction Project's code is provided under a contract-release  |
| basis.  DO NOT DISTRIBUTE and do not use beyond the contract terms.  |
\-------------------------------------------------------------------- */

namespace AllenCopeland.Abstraction.Slf.Translation
{

    public abstract partial class IntermediateCodeTranslatorBase :
        IIntermediateCodeTranslator
    {
        private static Regex docCommentLookup = new Regex(@"@(?<refKind>[PpSsTt]):(?<targetName>[_A-Za-z](?:\.?[A-Z_a-z0-9]|\.?\\u[0-9A-F_a-f]{4})*(?:\{[0-9A-Z_a-z]+(?:,[ ]*[0-9_A-Za-z]+)*\})?(\.[A-Z_a-z](?:[A-Z_a-z0-9]|\\u[_0-9A-Fa-f]{4})*(?:\{[_A-Za-z](?:[A-Z_a-z0-9]|\\u[0-9A-F_a-f]{4})*(?:\{[0-9A-Z_a-z]+(?:,[ ]*[0-9_A-Za-z]+)*\})?(\.[A-Z_a-z](?:[A-Z_a-z0-9]|\\u[_0-9A-Fa-f]{4})*(?:\{[_0-9A-Za-z]+(?:,[ ]*[_0-9A-Za-z]+)*\})?)*\})?)*);", RegexOptions.Compiled);
        private static Regex docCommentTableStart = new Regex(@"@table;(?<inner>(?:(?!@\/table\;).|\n)*)@/table;", RegexOptions.Multiline | RegexOptions.Compiled);
        private static Regex docCommentCode = new Regex(@"@code(?: language=(?<language>[^;]+))?;(?<inner>(?:(?!@\/code\;).|\n)*)@/code;", RegexOptions.Multiline | RegexOptions.Compiled);
        private static Regex docCommentParagraph = new Regex(@"@para;(?<inner>(?:(?!@\/para\;).|\n)*)@/para;", RegexOptions.Multiline | RegexOptions.Compiled);
        private static Regex docCommentTableListItem = new Regex(@"\|(?<IsHeader>\:)?-(?<left>(?:(?!-\|-).)*)-\|-(?<right>(?:(?!\|).)*)-\|", RegexOptions.Multiline | RegexOptions.Compiled);
        private static Regex docCommentWrapper = new Regex(@"(?<CurrentSpace>(?:[ \t])+)");
        private const string generatedMessageBase =
            "This code was generated by {0}.\r\n" +
            "Version: {1} \r\n" +
            "-\r\n" +
            "To ensure the code works properly,\r\n" +
            "please do not make any changes to the file.\r\n" +
            "-\r\n" +
            "The specific language is {2} (Runtime Version: {5})\r\n" +
            "Sub-tool Name: {3}\r\n" +
            "Sub-tool Version: {4}";

        /// <summary>
        /// The <see cref="IndentedTextWriter"/> which is used to handle indentation.
        /// </summary>
        private IndentedTextWriter target = null;

        private IIntermediateCodeTranslatorOptions options;

        protected abstract IIntermediateCodeNameProvider InitializeNameProvider();
        protected abstract IIntermediateCodeTranslatorOptions InitializeOptions();
        private IControlledCollection<IIntermediateDeclaration> buildTrailReadOnly;
        private List<IIntermediateDeclaration> buildTrail = new List<IIntermediateDeclaration>();
        private IntermediateSpanTranslationClasses currentSpanClass = IntermediateSpanTranslationClasses.None;
        private IIntermediateCodeTranslatorFormatter formatter;
        private IIntermediateCodeNameProvider nameProvider;
        internal static readonly DeclarationTranslationOrder[] fullOrderSet = new DeclarationTranslationOrder[]
            {
                DeclarationTranslationOrder.BinaryOperatorCoercions,
                DeclarationTranslationOrder.Classes,
                DeclarationTranslationOrder.Constructors,
                DeclarationTranslationOrder.Delegates,
                DeclarationTranslationOrder.Enums,
                DeclarationTranslationOrder.Events,
                DeclarationTranslationOrder.Fields,
                DeclarationTranslationOrder.Indexers,
                DeclarationTranslationOrder.Interfaces,
                DeclarationTranslationOrder.Methods,
                DeclarationTranslationOrder.Properties,
                DeclarationTranslationOrder.Structs,
                DeclarationTranslationOrder.TypeCoercions,
                DeclarationTranslationOrder.UnaryOperatorCoercions,
                DeclarationTranslationOrder.Remaining,
            };

        private string toolVersion;

        #region IIntermediateCodeTranslator Members
        public IControlledCollection<IIntermediateDeclaration> BuildTrail
        {
            get
            {
                CheckBuildTrail();
                return this.buildTrailReadOnly;
            }
        }

        private void CheckBuildTrail()
        {
            if (buildTrailReadOnly == null)
                buildTrailReadOnly = this.InitializeReadOnlyBuildTrail();
        }

        private IControlledCollection<IIntermediateDeclaration> InitializeReadOnlyBuildTrail()
        {
            return new ControlledCollection<IIntermediateDeclaration>(buildTrail);
        }

        protected void BuildTrailPush(IIntermediateDeclaration declaration)
        {
            CheckBuildTrail();
            this.buildTrail.Add(declaration);
        }

        protected void BuildTrailPop()
        {
            CheckBuildTrail();
            this.buildTrail.RemoveAt(buildTrail.Count - 1);
        }

        protected void BuildTrailPop(IIntermediateDeclaration declaration)
        {
            CheckBuildTrail();
            if (this.buildTrail.Contains(declaration))
            {
                for (int i = buildTrail.Count - 1; i >= 0; i--)
                    if (buildTrail[i] == declaration)
                    {
                        buildTrail.RemoveAt(i);
                        break;
                    }
            }
        }

        public IIntermediateCodeTranslatorOptions Options
        {
            get
            {
                if (this.options == null)
                    this.options = this.InitializeOptions();
                return this.options;
            }
        }
        #endregion


        /// <summary>
        /// Increases the <see cref="Target"/> indent level.
        /// </summary>
        protected void IncreaseIndent()
        {
            if (this.Formatter.HandlesWrite)
                this.Formatter.Indent();
            else
                this.Target.Indent++;
        }

        /// <summary>
        /// Decreases the <see cref="Target"/> indent level.
        /// </summary>
        protected void DecreaseIndent()
        {
            if (this.Formatter.HandlesWrite)
                this.Formatter.Dedent();
            else
                this.Target.Indent--;
        }

        public IndentedTextWriter Target
        {
            get
            {
                return this.target;
            }
            set
            {
                this.target = value;
            }
        }

        protected void TranslateFieldParent<TField, TIntermediateField, TFieldParent, TIntermediateFieldParent>(TIntermediateFieldParent parent)
            where TField :
                IFieldMember<TField, TFieldParent>
            where TIntermediateField :
                TField,
                IIntermediateFieldMember<TField, TIntermediateField, TFieldParent, TIntermediateFieldParent>
            where TFieldParent :
                IFieldParent<TField, TFieldParent>
            where TIntermediateFieldParent :
                TFieldParent,
                IIntermediateFieldParent<TField, TIntermediateField, TFieldParent, TIntermediateFieldParent>
        {
            foreach (var item in parent.Fields.Values)
                item.Accept(this);
        }

        protected void TranslateMethodSignatures<TSignatureParameter, TIntermediateSignatureParameter, TSignature, TIntermediateSignature, TParent, TIntermediateParent>(IIntermediateMethodSignatureMemberDictionary<TSignatureParameter, TIntermediateSignatureParameter, TSignature, TIntermediateSignature, TParent, TIntermediateParent> signatures)
            where TSignatureParameter :
                IMethodSignatureParameterMember<TSignatureParameter, TSignature, TParent>
            where TIntermediateSignatureParameter :
                IIntermediateMethodSignatureParameterMember<TSignatureParameter, TIntermediateSignatureParameter, TSignature, TIntermediateSignature, TParent, TIntermediateParent>,
                TSignatureParameter
            where TSignature :
                IMethodSignatureMember<TSignatureParameter, TSignature, TParent>
            where TIntermediateSignature :
                IIntermediateMethodSignatureMember<TSignatureParameter, TIntermediateSignatureParameter, TSignature, TIntermediateSignature, TParent, TIntermediateParent>,
                TSignature
            where TParent :
                ISignatureParent<IGeneralGenericSignatureMemberUniqueIdentifier, TSignature, TSignatureParameter, TParent>
            where TIntermediateParent :
                IIntermediateSignatureParent<IGeneralGenericSignatureMemberUniqueIdentifier, TSignature, TIntermediateSignature, TSignatureParameter, TIntermediateSignatureParameter, TParent, TIntermediateParent>,
                TParent
        {
            foreach (var method in signatures.Values)
                method.Accept(this);
        }

        protected void TranslateTypes<TTypeIdentifier, TType, TIntermediateType>(IIntermediateTypeDictionary<TTypeIdentifier, TType, TIntermediateType> target)
            where TTypeIdentifier :
                ITypeUniqueIdentifier
            where TType :
                IType<TTypeIdentifier, TType>
            where TIntermediateType :
                IIntermediateType,
                TType
        {
            foreach (var type in target.Values)
                type.Accept(this);
        }

        protected void TranslateTypeParent(IIntermediateTypeParent parent)
        {
            this.TranslateTypes(parent.Classes);
            this.TranslateTypes(parent.Delegates);
            this.TranslateTypes(parent.Enums);
            this.TranslateTypes(parent.Interfaces);
            this.TranslateTypes(parent.Structs);
        }

        protected void TranslateNamespaceParent(IIntermediateNamespaceParent parent)
        {
            this.TranslateFieldParent<ITopLevelFieldMember, IIntermediateTopLevelFieldMember, INamespaceParent, IIntermediateNamespaceParent>(parent);
            this.TranslateMethodSignatures(parent.Methods);
            this.TranslateTypeParent(parent);
        }

        protected void WriteKeyword(string keyword)
        {
            this.Write(IntermediateSpanTranslationClasses.Keyword, keyword);
        }

        protected void WriteOperator(string op)
        {
            this.Write(IntermediateSpanTranslationClasses.Operator, op);
        }

        public virtual void Write(IntermediateSpanTranslationClasses spanClass, string text)
        {
            WriteSpanCheck(spanClass);
            this.Write(text);
        }

        internal void WriteSpanCheck(IntermediateSpanTranslationClasses spanClass)
        {
            if (this.CurrentSpanClass != spanClass)
                ChangeSpanClasses(spanClass);
        }

        private void ChangeSpanClasses(IntermediateSpanTranslationClasses spanClass)
        {
            if (this.Formatter != null)
            {
                if (CurrentSpanClass != IntermediateSpanTranslationClasses.None)
                    this.Formatter.EndSpan();
                this.Formatter.BeginSpan(spanClass);
            }
            else
                this.CurrentSpanClass = spanClass;
        }

        #region IIntermediateCodeTranslator Members

        public void Write(string text)
        {
            if (this.Formatter.HandlesWrite)
                this.Formatter.HandleWrite(text);
            else
                this.target.Write(text);
        }

        public void WriteLine()
        {
            if (this.Formatter.HandlesWrite)
                this.Formatter.HandleWriteLine();
            else
                this.target.WriteLine();
        }


        public IIntermediateCodeTranslatorFormatter Formatter
        {
            get
            {
                if (this.formatter == null)
                    this.formatter = this.Options.FormatProvider.GetFormatterFor(this);
                return this.formatter;
            }
        }

        #endregion

        public abstract void Translate<T>(IExpressionCollection<T> malleableExpressionCollection)
            where T :
                IExpression;

        public abstract void Translate(IControlledTypeCollection controlledTypeCollection);

        internal static string GetCSharpCommentText(string commentBase, bool docComment, bool inline = false)
        {
            string result = "";
            if (docComment)
            {
                if (commentBase.Contains("\r\n"))
                {
                    StringBuilder sb = new StringBuilder();
                    string[] commentLines = commentBase.Split(new string[] { "\r\n" }, StringSplitOptions.None);
                    bool firstItem = true;
                    for (int i = 0; i < commentLines.Length; i++)
                    {
                        string s = commentLines[i];
                        if (firstItem)
                            firstItem = false;
                        else
                            sb.AppendLine();
                        sb.Append("/// ");
                        sb.Append(s);
                    }
                    result = sb.ToString();
                }
                else
                {
                    result = string.Format("/// {0}", commentBase);
                }
            }
            else if (commentBase.Contains("\r\n"))
                result = GetBoxedCommentText(commentBase);
            else if (!inline)
                result = string.Format("// {0}", commentBase);
            else
                result = string.Format("/* {0} */", commentBase);

            return result;
        }

        internal static string GetBoxedCommentText(string commentBase)
        {
            string[] commentLines = (from line in commentBase.Split(new string[] { "\r\n" }, StringSplitOptions.None)
                                     select string.Format(" |  {0}", line)).ToArray();

            int maximumLength = commentLines.Max(p => p.Length);
            StringBuilder sb = new StringBuilder();
            maximumLength += 4;
            sb.Append(" /* ");
            sb.Append('-', maximumLength - 6);
            sb.AppendLine("\\");
            foreach (string s in commentLines)
            {
                if (s == " |  -")
                {
                    sb.Append(" |");
                    sb.Append('-', maximumLength - 4);
                }
                else
                {
                    sb.Append(s);
                    sb.Append(' ', maximumLength - (s.Length + 2));
                }
                sb.AppendLine("|");
            }
            sb.Append(" \\");
            sb.Append('-', maximumLength - 6);
            sb.Append(" */");
            return sb.ToString();
        }

        protected void DenoteNewLine()
        {
            if (this.Formatter != null)
                this.Formatter.DenoteNewLine();
            else
                this.WriteLine();
        }

        protected abstract void Translate<TParent, TIntermediateParent, TParameter, TIntermediateParameter>(IIntermediateParameterMemberDictionary<TParent, TIntermediateParent, TParameter, TIntermediateParameter> parameters)
            where TParent :
                IParameterParent<TParent, TParameter>
            where TIntermediateParent :
                TParent,
                IIntermediateParameterParent<TParent, TIntermediateParent, TParameter, TIntermediateParameter>
            where TParameter :
                IParameterMember<TParent>
            where TIntermediateParameter :
                TParameter,
                IIntermediateParameterMember<TParent, TIntermediateParent>;

        protected virtual void Translate(IControlledCollection<IStatement> statementCollection)
        {
            foreach (var statement in statementCollection)
                statement.Accept(this);
        }

        #region IIntermediateCodeTranslator Members

        public void DefineDeclaration(IIntermediateClassType declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateConstructorMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateConstructorSignatureMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateDelegateType declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateEnumType declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateEventMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateEventSignatureMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateFieldMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateIndexerMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateIndexerSignatureMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateInterfaceType declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(ILambdaTypeInferredExpressionParameterMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(ILinqRangeVariable declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(ILocalMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateMethodMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateMethodSignatureMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateParameterMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediatePropertyMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediatePropertySignatureMember declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void DefineDeclaration(IIntermediateStructType declaration)
        {
            this.Formatter.DefineDeclaration(declaration);
        }

        public void EndDeclarationDefinition()
        {
            this.Formatter.EndDeclarationDefinition();
        }

        public void ReferenceDeclaration(IIntermediateClassType declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateConstructorMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateConstructorSignatureMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateDelegateType declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateEnumType declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateEventMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateEventSignatureMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateFieldMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateIndexerMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateIndexerSignatureMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateInterfaceType declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(ILambdaTypeInferredExpressionParameterMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(ILinqRangeVariable declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(ILocalMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateMethodMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateMethodSignatureMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateParameterMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediatePropertyMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediatePropertySignatureMember declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIntermediateStructType declaration)
        {
            this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IClassType declaration)
        {
            if (declaration is IIntermediateClassType)
                this.ReferenceDeclaration((IIntermediateClassType)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IConstructorMember declaration)
        {
            if (declaration is IIntermediateConstructorMember)
                this.ReferenceDeclaration((IIntermediateConstructorMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IDelegateType declaration)
        {
            if (declaration is IIntermediateDelegateType)
                this.ReferenceDeclaration((IIntermediateDelegateType)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IEnumType declaration)
        {
            if (declaration is IIntermediateEnumType)
                this.ReferenceDeclaration((IIntermediateEnumType)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IEventMember declaration)
        {
            if (declaration is IIntermediateEventMember)
                this.ReferenceDeclaration((IIntermediateEventMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IEventSignatureMember declaration)
        {
            if (declaration is IIntermediateEventSignatureMember)
                this.ReferenceDeclaration((IIntermediateEventSignatureMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IFieldMember declaration)
        {
            if (declaration is IIntermediateFieldMember)
                this.ReferenceDeclaration((IIntermediateFieldMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIndexerMember declaration)
        {
            if (declaration is IIntermediateIndexerMember)
                this.ReferenceDeclaration((IIntermediateIndexerMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IIndexerSignatureMember declaration)
        {
            if (declaration is IIntermediateIndexerSignatureMember)
                this.ReferenceDeclaration((IIntermediateIndexerSignatureMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IInterfaceType declaration)
        {
            if (declaration is IIntermediateInterfaceType)
                this.ReferenceDeclaration((IIntermediateInterfaceType)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IMethodMember declaration)
        {
            if (declaration is IIntermediateMethodMember)
                this.ReferenceDeclaration((IIntermediateMethodMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IMethodSignatureMember declaration)
        {
            if (declaration is IIntermediateMethodMember)
                this.ReferenceDeclaration((IIntermediateMethodMember)declaration);
            else if (declaration is IIntermediateMethodSignatureMember)
                this.ReferenceDeclaration((IIntermediateMethodSignatureMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IParameterMember declaration)
        {
            if (declaration is IIntermediateParameterMember)
                this.ReferenceDeclaration((IIntermediateParameterMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IPropertyMember declaration)
        {
            if (declaration is IIntermediatePropertyMember)
                this.ReferenceDeclaration((IIntermediatePropertyMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IPropertySignatureMember declaration)
        {
            if (declaration is IIntermediatePropertySignatureMember)
                this.ReferenceDeclaration((IIntermediatePropertySignatureMember)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void ReferenceDeclaration(IStructType declaration)
        {
            if (declaration is IIntermediateStructType)
                this.ReferenceDeclaration((IIntermediateStructType)declaration);
            else
                this.Formatter.ReferenceDeclaration(declaration);
        }

        public void EndReferenceDeclaration()
        {
            this.Formatter.EndReferenceDeclaration();
        }

        #endregion

        public void BeginDocument(IIntermediateAssembly target)
        {
            this.Formatter.BeginDocument(target);
        }

        public void EndDocument()
        {
            this.Formatter.EndDocument();
        }

        public IIntermediateCodeNameProvider NameProvider
        {
            get { return this.nameProvider ?? (this.nameProvider = this.InitializeNameProvider()); }
        }

        //void IExpressionVisitor.Visit<TSignatureParameter, TSignature, TParent>(IMethodReferenceStub<TSignatureParameter, TSignature, TParent> expression)
        //{
        //    this.Translate(expression);
        //}

        void IPrimitiveVisitor.VisitNull()
        {
            this.TranslateNull();
        }

        /// <summary>
        /// Returns the string which denotes the sub-tool version.  
        /// Relates specifically to the individual language implementation.
        /// </summary>
        public abstract string SubToolVersion { get; }

        /// <summary>
        /// Returns the string which denotes the sub-tool's name.
        /// Relates specifically to the individual language implementation.
        /// </summary>
        public abstract string SubToolName { get; }

        /// <summary>
        /// Returns the name of the language implemented by the sub-tool.
        /// </summary>
        public abstract string Language { get; }

        /// <summary>
        /// Returns the version of the tool.
        /// </summary>
        public string ToolVersion
        {
            get
            {
                if (toolVersion == null)
                    toolVersion = typeof(IntermediateCodeTranslatorBase).Assembly.GetName().Version.ToString();
                return this.toolVersion;
            }
        }

        /// <summary>
        /// Returns the name of the intermediate foundation.
        /// </summary>
        public virtual string ToolName
        {
            get
            {
                return "Allen Copeland's Abstraction";
            }
        }

        /// <summary>
        /// Returns the 'generated by a tool' text for comments.
        /// </summary>
        public string GeneratedMessageText
        {
            get
            {
                return string.Format(generatedMessageBase, ToolName, ToolVersion, Language, SubToolName, SubToolVersion, RuntimeVersion);
            }
        }

        //void IExpressionVisitor.Visit(IBoundLocalReferenceExpression expression)
        //{
        //    this.Translate(expression);
        //}



        protected static string GetSelfTerminableDocumentComment(string tag, string attributeName, string attributeValue)
        {
            return string.Format("<{0}\xA0{1}=\"{2}\"/>", tag, attributeName, attributeValue);
        }

        protected static string BreakdownTables(string target)
        {
            StringBuilder result = new StringBuilder();

            int lastStartIndex = 0;
            foreach (var match in docCommentTableStart.MatchSet(target))
            {
                result.Append(target.Substring(lastStartIndex, match.Index - lastStartIndex));
                var inner = match.Groups["inner"].Value;
                result.Append("<list type=\"table\">");
                result.Append(BreakdownTableItems(inner));
                result.Append("</list>");
                lastStartIndex = match.Index + match.Length;
            }
            result.Append(target.Substring(lastStartIndex));
            return result.ToString();
        }

        private static string BreakdownCodeSections(string target)
        {
            StringBuilder result = new StringBuilder();
            int lastStartIndex = 0;
            bool first = true;
            foreach (var match in docCommentCode.MatchSet(target))
            {
                if (first)
                    first = false;
                else
                    result.AppendLine();
                result.Append(target.Substring(lastStartIndex, match.Index - lastStartIndex));
                bool language = match.Groups["language"].Success;
                if (language)
                {
                    result.AppendFormat("<code language=\"{0}\">", match.Groups["language"].Value);
                    result.AppendLine();
                }
                else
                    result.AppendLine("<code>");
                result.AppendLine(match.Groups["inner"].Value);
                result.Append("</code>");
                lastStartIndex = match.Index + match.Length;
            }
            result.Append(target.Substring(lastStartIndex));
            return result.ToString();
        }

        private static string BreakdownParagraphSections(string target)
        {
            bool first = true;
            StringBuilder result = new StringBuilder();
            int lastStartIndex = 0;
            foreach (var match in docCommentParagraph.MatchSet(target))
            {
                if (first)
                    first = false;
                else
                    result.AppendLine();
                result.Append(target.Substring(lastStartIndex, match.Index - lastStartIndex));
                result.AppendLine("<para>");
                result.AppendLine(match.Groups["inner"].Value);
                result.Append("</para>");
                lastStartIndex = match.Index + match.Length;
            }
            result.Append(target.Substring(lastStartIndex));
            return result.ToString();
        }

        private static string BreakdownTableItems(string target)
        {
            StringBuilder result = new StringBuilder();

            int lastStartIndex = 0;
            foreach (var match in docCommentTableListItem.MatchSet(target))
            {
                result.Append(target.Substring(lastStartIndex, match.Index - lastStartIndex));
                var left = match.Groups["left"].Value;
                var right = match.Groups["right"].Value;
                bool header = match.Groups["IsHeader"].Success;
                if (header)
                    result.Append("<listheader>");
                else
                    result.Append("<item>");
                result.Append("<term>");
                result.Append(left);
                result.Append("</term>");
                result.Append("<description>");
                result.Append(right);
                result.Append("</description>");
                if (header)
                    result.Append("</listheader>");
                else
                    result.Append("</item>");
                lastStartIndex = match.Index + match.Length;
            }
            result.Append(target.Substring(lastStartIndex));
            return result.ToString();
        }
        /// <summary>
        /// <list type=""
        /// </summary>
        /// <param name="target"></param>
        /// <returns></returns>
        protected static string ResolveDocumentationCommentLookups(string target)
        {
            /* *
             * A necessary evil.  Because documentation comments are derived
             * from HTML, it's necessary to encode the actual text from the
             * comments and strip any un-necessary characters, replacing them
             * with their unicode or html encoded variants.  Because of this,
             * type-parameter, parameter, and type/member references, must be
             * encoded in a different manner; else, users of the system be
             * required to encode all targets on their own, as well as remember
             * that characters like '<' and '>' are not valid.
             * */
            StringBuilder result = new StringBuilder();
            int lastStartIndex = 0;
            var sectionedAreas = BreakdownParagraphSections(BreakdownCodeSections(BreakdownTables(target)));

            foreach (var match in docCommentLookup.MatchSet(sectionedAreas))
            {
                result.Append(sectionedAreas.Substring(lastStartIndex, match.Index - lastStartIndex));
                switch (match.Groups["refKind"].Value[0])
                {
                    case 'S':
                    case 's':
                        result.Append(GetSelfTerminableDocumentComment("see", "cref", match.Groups["targetName"].Value));
                        break;
                    case 'T':
                    case 't':
                        result.Append(GetSelfTerminableDocumentComment("typeparamref", "name", match.Groups["targetName"].Value));
                        break;
                    case 'P':
                    case 'p':
                        result.Append(GetSelfTerminableDocumentComment("paramref", "name", match.Groups["targetName"].Value));
                        break;
                    default:
                        break;
                }
                lastStartIndex = match.Index + match.Length;
            }
            result.Append(sectionedAreas.Substring(lastStartIndex));
            return BreakdownWrap(result.ToString());
        }


        internal static string BreakdownWrap(string target, int maxWidth = 80)
        {
            const string tabSpace = "\xA0\xA0\xA0\xA0";
            StringBuilder result = new StringBuilder();
            bool first = true;
            foreach (var line in target.Split(new string[] { Environment.NewLine }, StringSplitOptions.None))
            {
                if (first)
                    first = false;
                else
                    result.AppendLine();
                int lastStartIndex = 0;
                int lastWrapIndex = 0;
                foreach (var match in docCommentWrapper.MatchSet(line))
                {
                    result.Append(line.Substring(lastStartIndex, match.Index - lastStartIndex));
                    var diff = match.Index - lastWrapIndex;
                    if (diff > maxWidth)
                    {
                        result.AppendLine();
                        lastWrapIndex = match.Index + match.Length;
                    }
                    else
                        result.Append(match.Groups["CurrentSpace"].Value);
                    lastStartIndex = match.Index + match.Length;
                }
                result.Append(line.Substring(lastStartIndex));
            }
            return result.ToString().Replace("\xA0", "\x20").Replace("\t", tabSpace);
        }

        protected static string GetTerminableDocumentComment(string comment, string tag, string attributeName = null, string attributeValue = null)
        {
            if (attributeName == null)
                return string.Format("<{0}>\r\n{1}\r\n</{0}>", tag, comment);
            else if (attributeValue == null)
                return string.Format("<{0} {1}>\r\n{2}\r\n</{0}", tag, attributeName, comment);
            else
                return string.Format("<{0} {1}=\"{2}\">{3}</{0}>", tag, attributeName, attributeValue, comment);
        }

        protected static string GetSummaryDocumentComment(string summary)
        {
            return GetTerminableDocumentComment(summary, "summary");
        }
        protected static string GetRemarksDocumentComment(string remarks)
        {
            return GetTerminableDocumentComment(remarks, "remarks");
        }
        protected static string GetReturnsDocumentComment(string returns)
        {
            return GetTerminableDocumentComment(returns, "returns");
        }

        public IntermediateSpanTranslationClasses CurrentSpanClass
        {
            get
            {
                if (this.Formatter == null)
                    return this.currentSpanClass;
                else
                    return this.Formatter.CurrentSpanClass;
            }
            set
            {
                this.currentSpanClass = value;
            }
        }

        public string RuntimeVersion
        {
            get
            {
                return Environment.Version.ToString();
            }
        }

        public abstract void TranslateNull();

        public virtual void Translate<TLeft, TRight>(IBinaryOperationExpression<TLeft, TRight> expression)
            where TLeft :
                INaryOperandExpression
            where TRight :
                INaryOperandExpression
        {
            switch (expression.Associativity)
            {
                case BinaryOperationAssociativity.Left:
                    if (expression.LeftSide != null)
                    {
                        expression.LeftSide.Accept(this);
                        Translate(expression.OperationKind);
                    }
                    expression.RightSide.Accept(this);
                    break;
                case BinaryOperationAssociativity.Right:
                    expression.LeftSide.Accept(this);
                    if (expression.RightSide != null)
                    {
                        Translate(expression.OperationKind);
                        expression.RightSide.Accept(this);
                    }
                    break;
                default:
                    break;
            }
        }

        public abstract void Translate(IType type);

        public abstract void Translate(BinaryOperationKind kind);

    }
}
