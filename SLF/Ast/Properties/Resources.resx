<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CSharpErrors_CS0001" xml:space="preserve">
    <value>Internal compiler error</value>
  </data>
  <data name="CSharpErrors_CS0003" xml:space="preserve">
    <value>Out of memory</value>
  </data>
  <data name="CSharpErrors_CS0004" xml:space="preserve">
    <value>Warning treated as error</value>
  </data>
  <data name="CSharpErrors_CS0005" xml:space="preserve">
    <value>Compiler option {0} must be followed by an argument</value>
  </data>
  <data name="CSharpErrors_CS0006" xml:space="preserve">
    <value>Metadata file {0} could not be found</value>
  </data>
  <data name="CSharpErrors_CS0007" xml:space="preserve">
    <value>Unexpected common language runtime initialization error — {0}</value>
  </data>
  <data name="CSharpErrors_CS0008" xml:space="preserve">
    <value>Unexpected error reading metadata from file 'file' — {0}</value>
  </data>
  <data name="CSharpErrors_CS0009" xml:space="preserve">
    <value>Metadata file {0} could not be opened — {1}</value>
  </data>
  <data name="CSharpErrors_CS0010" xml:space="preserve">
    <value>Unexpected fatal error -- {0}.</value>
  </data>
  <data name="CSharpErrors_CS0011" xml:space="preserve">
    <value>The base class or interface {0} in assembly {1} referenced by type {2} could not be resolved</value>
  </data>
  <data name="CSharpErrors_CS0012" xml:space="preserve">
    <value>The type {0} is defined in an assembly that is not referenced. You must add a reference to assembly {1}.</value>
  </data>
  <data name="CSharpErrors_CS0013" xml:space="preserve">
    <value>Unexpected error writing metadata to file {0} -- {1}</value>
  </data>
  <data name="CSharpErrors_CS0014" xml:space="preserve">
    <value>Required file {0} could not be found</value>
  </data>
  <data name="CSharpErrors_CS0015" xml:space="preserve">
    <value>The name of type {0} is too long</value>
  </data>
  <data name="CSharpErrors_CS0016" xml:space="preserve">
    <value>Could not write to output file {0} — {1}</value>
  </data>
  <data name="CSharpErrors_CS0017" xml:space="preserve">
    <value>Program {0} has more than one entry point defined. Compile with /main to specify the type that contains the entry point.</value>
  </data>
  <data name="CSharpErrors_CS0019" xml:space="preserve">
    <value>Operator {0} cannot be applied to operands of type {1} and {2}</value>
  </data>
  <data name="CSharpErrors_CS0020" xml:space="preserve">
    <value>Division by constant zero</value>
  </data>
  <data name="CSharpErrors_CS0021" xml:space="preserve">
    <value>Cannot apply indexing with [] to an expression of type {0}</value>
  </data>
  <data name="CSharpErrors_CS0022" xml:space="preserve">
    <value>Wrong number of indices inside [], expected {0}</value>
  </data>
  <data name="CSharpErrors_CS0023" xml:space="preserve">
    <value>Operator {0} cannot be applied to operand of type {1}</value>
  </data>
  <data name="CSharpErrors_CS0025" xml:space="preserve">
    <value>Standard library file {0} could not be found</value>
  </data>
  <data name="CSharpErrors_CS0026" xml:space="preserve">
    <value>Keyword 'this' is not valid in a static property, static method, or static field initializer</value>
  </data>
  <data name="CSharpErrors_CS0027" xml:space="preserve">
    <value>Keyword 'this' is not available in the current context</value>
  </data>
  <data name="CSharpErrors_CS0029" xml:space="preserve">
    <value>Cannot implicitly convert type {0} to {1}</value>
  </data>
  <data name="CSharpErrors_CS0030" xml:space="preserve">
    <value>Cannot convert type {0} to {1}</value>
  </data>
  <data name="CSharpErrors_CS0031" xml:space="preserve">
    <value>Constant value {0} cannot be converted to a {1}. (use 'unchecked' syntax to override)</value>
  </data>
  <data name="CSharpErrors_CS0034" xml:space="preserve">
    <value>Operator {0} is ambiguous on operands of type {1} and {2}</value>
  </data>
  <data name="CSharpErrors_CS0035" xml:space="preserve">
    <value>Operator {0} is ambiguous on an operand of type {1}</value>
  </data>
  <data name="CSharpErrors_CS0036" xml:space="preserve">
    <value>An out parameter cannot have the '[In]' attribute</value>
  </data>
  <data name="CSharpErrors_CS0037" xml:space="preserve">
    <value>Cannot convert null to {0} because it is a non-nullable value type</value>
  </data>
  <data name="CSharpErrors_CS0038" xml:space="preserve">
    <value>Cannot access a nonstatic member of outer type {0} via nested type {1}</value>
  </data>
  <data name="CSharpErrors_CS0039" xml:space="preserve">
    <value>Cannot convert type {0} to {1} via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion</value>
  </data>
  <data name="CSharpErrors_CS0040" xml:space="preserve">
    <value>Unexpected error creating debug information file — {0}</value>
  </data>
  <data name="CSharpErrors_CS0041" xml:space="preserve">
    <value>The fully qualified name for {0} is too long for debug information. Compile without '/debug' option.</value>
  </data>
  <data name="CSharpErrors_CS0042" xml:space="preserve">
    <value>Unexpected error creating debug information file {0} — {1}</value>
  </data>
  <data name="CSharpErrors_CS0043" xml:space="preserve">
    <value>PDB file {0} has an incorrect or out-of-date format. Delete it and rebuild.</value>
  </data>
  <data name="CSharpErrors_CS0050" xml:space="preserve">
    <value>Inconsistent accessibility: return type {0} is less accessible than method {1}</value>
  </data>
  <data name="CSharpErrors_CS0051" xml:space="preserve">
    <value>Inconsistent accessibility: parameter type {0} is less accessible than method {1}</value>
  </data>
  <data name="CSharpErrors_CS0052" xml:space="preserve">
    <value>Inconsistent accessibility: field type {0} is less accessible than field {1}</value>
  </data>
  <data name="CSharpErrors_CS0053" xml:space="preserve">
    <value>Inconsistent accessibility: property type {0} is less accessible than property {1}</value>
  </data>
  <data name="CSharpErrors_CS0054" xml:space="preserve">
    <value>Inconsistent accessibility: indexer return type {0} is less accessible than indexer {1}</value>
  </data>
  <data name="CSharpErrors_CS0055" xml:space="preserve">
    <value>Inconsistent accessibility: parameter type {0} is less accessible than indexer {1}</value>
  </data>
  <data name="CSharpErrors_CS0056" xml:space="preserve">
    <value>Inconsistent accessibility: return type {0} is less accessible than operator {1}</value>
  </data>
  <data name="CSharpErrors_CS0057" xml:space="preserve">
    <value>Inconsistent accessibility: parameter type {0} is less accessible than operator {1}</value>
  </data>
  <data name="CSharpErrors_CS0058" xml:space="preserve">
    <value>Inconsistent accessibility: return type {0} is less accessible than delegate {1}</value>
  </data>
  <data name="CSharpErrors_CS0059" xml:space="preserve">
    <value>Inconsistent accessibility: parameter type {0} is less accessible than delegate {1}</value>
  </data>
  <data name="CSharpErrors_CS0060" xml:space="preserve">
    <value>Inconsistent accessibility: base class {0} is less accessible than class {1}</value>
  </data>
  <data name="CSharpErrors_CS0061" xml:space="preserve">
    <value>Inconsistent accessibility: base interface {0} is less accessible than interface {1}</value>
  </data>
  <data name="CSharpErrors_CS0065" xml:space="preserve">
    <value>{0}: event property must have both add and remove accessors</value>
  </data>
  <data name="CSharpErrors_CS0066" xml:space="preserve">
    <value>{0}: event must be of a delegate type</value>
  </data>
  <data name="CSharpErrors_CS0068" xml:space="preserve">
    <value>{0}: event in interface cannot have initializer</value>
  </data>
  <data name="CSharpErrors_CS0069" xml:space="preserve">
    <value>An event in an interface cannot have add or remove accessors</value>
  </data>
  <data name="CSharpErrors_CS0070" xml:space="preserve">
    <value>The event {0} can only appear on the left hand side of += or -= (except when used from within the type {1})</value>
  </data>
  <data name="CSharpErrors_CS0071" xml:space="preserve">
    <value>An explicit interface implementation of an event must use event accessor syntax</value>
  </data>
  <data name="CSharpErrors_CS0072" xml:space="preserve">
    <value>{0} : cannot override; {1} is not an event</value>
  </data>
  <data name="CSharpErrors_CS0073" xml:space="preserve">
    <value>An add or remove accessor must have a body</value>
  </data>
  <data name="CSharpErrors_CS0074" xml:space="preserve">
    <value>{0}: abstract event cannot have initializer</value>
  </data>
  <data name="CSharpErrors_CS0075" xml:space="preserve">
    <value>To cast a negative value, you must enclose the value in parentheses</value>
  </data>
  <data name="CSharpErrors_CS0076" xml:space="preserve">
    <value>The enumerator name 'value__' is reserved and cannot be used</value>
  </data>
  <data name="CSharpErrors_CS0077" xml:space="preserve">
    <value>The as operator must be used with a reference type or nullable type ({0} is a non-nullable value type).</value>
  </data>
  <data name="CSharpErrors_CS0079" xml:space="preserve">
    <value>The event {0} can only appear on the left hand side of += or -=</value>
  </data>
  <data name="CSharpErrors_CS0080" xml:space="preserve">
    <value>Constraints are not allowed on non-generic declarations</value>
  </data>
  <data name="CSharpErrors_CS0081" xml:space="preserve">
    <value>Type parameter declaration must be an identifier not a type</value>
  </data>
  <data name="CSharpErrors_CS0082" xml:space="preserve">
    <value>Type {0} already reserves a member called {1} with the same parameter types</value>
  </data>
  <data name="CSharpErrors_CS0100" xml:space="preserve">
    <value>The parameter name {0} is a duplicate</value>
  </data>
  <data name="CSharpErrors_CS0101" xml:space="preserve">
    <value>The namespace {0} already contains a definition for {1}</value>
  </data>
  <data name="CSharpErrors_CS0102" xml:space="preserve">
    <value>The type {0} already contains a definition for {1}</value>
  </data>
  <data name="CSharpErrors_CS0103" xml:space="preserve">
    <value>The name {0} does not exist in the current context</value>
  </data>
  <data name="CSharpErrors_CS0104" xml:space="preserve">
    <value>{0} is an ambiguous reference between {1} and {2}</value>
  </data>
  <data name="CSharpErrors_CS0106" xml:space="preserve">
    <value>The modifier {0} is not valid for this item</value>
  </data>
  <data name="CSharpErrors_CS0107" xml:space="preserve">
    <value>More than one protection modifier</value>
  </data>
  <data name="CSharpErrors_CS0110" xml:space="preserve">
    <value>The evaluation of the constant value for {0} involves a circular definition</value>
  </data>
  <data name="CSharpErrors_CS0111" xml:space="preserve">
    <value>Type {0} already defines a member called {1} with the same parameter types</value>
  </data>
  <data name="CSharpErrors_CS0112" xml:space="preserve">
    <value>A static member {0} cannot be marked as override, virtual or abstract</value>
  </data>
  <data name="CSharpErrors_CS0113" xml:space="preserve">
    <value>A member {0} marked as override cannot be marked as new or virtual</value>
  </data>
  <data name="CSharpErrors_CS0115" xml:space="preserve">
    <value>{0} : no suitable method found to override</value>
  </data>
  <data name="CSharpErrors_CS0116" xml:space="preserve">
    <value>A namespace does not directly contain members such as fields or methods</value>
  </data>
  <data name="CSharpErrors_CS0117" xml:space="preserve">
    <value>{0} does not contain a definition for 'identifier'</value>
  </data>
  <data name="CSharpErrors_CS0118" xml:space="preserve">
    <value>{0} is a {1} but is used like a {2}</value>
  </data>
  <data name="CSharpErrors_CS0119" xml:space="preserve">
    <value>{0} is a {1}, which is not valid in the given context.</value>
  </data>
  <data name="CSharpErrors_CS0120" xml:space="preserve">
    <value>An object reference is required for the nonstatic field, method, or property {0}</value>
  </data>
  <data name="CSharpErrors_CS0121" xml:space="preserve">
    <value>The call is ambiguous between the following methods or properties: {0} and {1}</value>
  </data>
  <data name="CSharpErrors_CS0122" xml:space="preserve">
    <value>{0} is inaccessible due to its protection level</value>
  </data>
  <data name="CSharpErrors_CS0123" xml:space="preserve">
    <value>No overload for {0} matches delegate {1}</value>
  </data>
  <data name="CSharpErrors_CS0126" xml:space="preserve">
    <value>An object of a type convertible to {0} is required</value>
  </data>
  <data name="CSharpErrors_CS0127" xml:space="preserve">
    <value>Since {0} returns void, a return keyword must not be followed by an object expression</value>
  </data>
  <data name="CSharpErrors_CS0128" xml:space="preserve">
    <value>A local variable named {0} is already defined in this scope</value>
  </data>
  <data name="CSharpErrors_CS0131" xml:space="preserve">
    <value>The left-hand side of an assignment must be a variable, property or indexer</value>
  </data>
  <data name="CSharpErrors_CS0132" xml:space="preserve">
    <value>{0} : a static constructor must be parameterless</value>
  </data>
  <data name="CSharpErrors_CS0133" xml:space="preserve">
    <value>The expression being assigned to {0} must be constant</value>
  </data>
  <data name="CSharpErrors_CS0134" xml:space="preserve">
    <value>{0} is of type {1}. A const field of a reference type other than string can only be initialized with null.</value>
  </data>
  <data name="CSharpErrors_CS0135" xml:space="preserve">
    <value>{0} conflicts with the declaration {1}</value>
  </data>
  <data name="CSharpErrors_CS0136" xml:space="preserve">
    <value>A local variable named {0} cannot be declared in this scope because it would give a different meaning to {0}, which is already used in a 'parent or current/child' scope to denote something else</value>
  </data>
  <data name="CSharpErrors_CS0138" xml:space="preserve">
    <value>A using namespace directive can only be applied to namespaces; {0} is a type not a namespace</value>
  </data>
  <data name="CSharpErrors_CS0139" xml:space="preserve">
    <value>No enclosing loop out of which to break or continue</value>
  </data>
  <data name="CSharpErrors_CS0140" xml:space="preserve">
    <value>The label {0} is a duplicate</value>
  </data>
  <data name="CSharpErrors_CS0143" xml:space="preserve">
    <value>The type {0} has no constructors defined</value>
  </data>
  <data name="CSharpErrors_CS0144" xml:space="preserve">
    <value>Cannot create an instance of the abstract class or interface {0}</value>
  </data>
  <data name="CSharpErrors_CS0145" xml:space="preserve">
    <value>A const field requires a value to be provided</value>
  </data>
  <data name="CSharpErrors_CS0146" xml:space="preserve">
    <value>Circular base class dependency involving {0} and {1}</value>
  </data>
  <data name="CSharpErrors_CS0148" xml:space="preserve">
    <value>The delegate {0} does not have a valid constructor</value>
  </data>
  <data name="CSharpErrors_CS0149" xml:space="preserve">
    <value>Method name expected</value>
  </data>
  <data name="CSharpErrors_CS0150" xml:space="preserve">
    <value>A constant value is expected</value>
  </data>
  <data name="CSharpErrors_CS0151" xml:space="preserve">
    <value>A value of an integral type expected</value>
  </data>
  <data name="CSharpErrors_CS0152" xml:space="preserve">
    <value>The label {0} already occurs in this switch statement</value>
  </data>
  <data name="CSharpErrors_CS0153" xml:space="preserve">
    <value>A goto case is only valid inside a switch statement</value>
  </data>
  <data name="CSharpErrors_CS0154" xml:space="preserve">
    <value>The property or indexer 'property' cannot be used in this context because it lacks the get accessor</value>
  </data>
  <data name="CSharpErrors_CS0155" xml:space="preserve">
    <value>The type caught or thrown must be derived from System.Exception</value>
  </data>
  <data name="CSharpErrors_CS0156" xml:space="preserve">
    <value>A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause</value>
  </data>
  <data name="CSharpErrors_CS0157" xml:space="preserve">
    <value>Control cannot leave the body of a finally clause</value>
  </data>
  <data name="CSharpErrors_CS0158" xml:space="preserve">
    <value>The label {0} shadows another label by the same name in a contained scope</value>
  </data>
  <data name="CSharpErrors_CS0159" xml:space="preserve">
    <value>No such label {0} within the scope of the goto statement</value>
  </data>
  <data name="CSharpErrors_CS0160" xml:space="preserve">
    <value>A previous catch clause already catches all exceptions of this or of a super type ({0})</value>
  </data>
  <data name="CSharpErrors_CS0161" xml:space="preserve">
    <value>{0}: not all code paths return a value</value>
  </data>
  <data name="CSharpErrors_CS0163" xml:space="preserve">
    <value>Control cannot fall through from one case label ({0}) to another</value>
  </data>
  <data name="CSharpErrors_CS0165" xml:space="preserve">
    <value>Use of unassigned local variable {0}</value>
  </data>
  <data name="CSharpErrors_CS0167" xml:space="preserve">
    <value>The delegate {0} is missing the Invoke method</value>
  </data>
  <data name="CSharpErrors_CS0170" xml:space="preserve">
    <value>Use of possibly unassigned field {0}</value>
  </data>
  <data name="CSharpErrors_CS0171" xml:space="preserve">
    <value>Backing field for automatically implemented property {0} must be fully assigned before control is returned to the caller. Consider calling the default constructor from a constructor initializer.</value>
  </data>
  <data name="CSharpErrors_CS0172" xml:space="preserve">
    <value>Type of conditional expression cannot be determined because {0} and {1} implicitly convert to one another</value>
  </data>
  <data name="CSharpErrors_CS0173" xml:space="preserve">
    <value>Type of conditional expression cannot be determined because there is no implicit conversion between {0} and {1}</value>
  </data>
  <data name="CSharpErrors_CS0174" xml:space="preserve">
    <value>A base class is required for a 'base' reference</value>
  </data>
  <data name="CSharpErrors_CS0175" xml:space="preserve">
    <value>Use of keyword 'base' is not valid in this context</value>
  </data>
  <data name="CSharpErrors_CS0176" xml:space="preserve">
    <value>Static member {0} cannot be accessed with an instance reference; qualify it with a type name instead</value>
  </data>
  <data name="CSharpErrors_CS0177" xml:space="preserve">
    <value>The out parameter {0} must be assigned to before control leaves the current method</value>
  </data>
  <data name="CSharpErrors_CS0178" xml:space="preserve">
    <value>Invalid rank specifier: expected ',' or ']'</value>
  </data>
  <data name="CSharpErrors_CS0179" xml:space="preserve">
    <value>{0} cannot be extern and declare a body</value>
  </data>
  <data name="CSharpErrors_CS0180" xml:space="preserve">
    <value>{0} cannot be both extern and abstract</value>
  </data>
  <data name="CSharpErrors_CS0182" xml:space="preserve">
    <value>An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type</value>
  </data>
  <data name="CSharpErrors_CS0185" xml:space="preserve">
    <value>{0} is not a reference type as required by the lock statement</value>
  </data>
  <data name="CSharpErrors_CS0186" xml:space="preserve">
    <value>Use of null is not valid in this context </value>
  </data>
  <data name="CSharpErrors_CS0188" xml:space="preserve">
    <value>The 'this' object cannot be used before all of its fields are assigned to</value>
  </data>
  <data name="CSharpErrors_CS0191" xml:space="preserve">
    <value>Property or indexer {0} cannot be assigned to -- it is read only</value>
  </data>
  <data name="CSharpErrors_CS0192" xml:space="preserve">
    <value>Fields of static readonly field {0} cannot be passed ref or out (except in a static constructor)</value>
  </data>
  <data name="CSharpErrors_CS0193" xml:space="preserve">
    <value>The * or -&gt; operator must be applied to a pointer</value>
  </data>
  <data name="CSharpErrors_CS0196" xml:space="preserve">
    <value>A pointer must be indexed by only one value</value>
  </data>
  <data name="CSharpErrors_CS0198" xml:space="preserve">
    <value>Fields of static readonly field {0} cannot be assigned to (except in a static constructor or a variable initializer)</value>
  </data>
  <data name="CSharpErrors_CS0199" xml:space="preserve">
    <value>Fields of static readonly field {0} cannot be passed ref or out (except in a static constructor)</value>
  </data>
  <data name="CSharpErrors_CS0200" xml:space="preserve">
    <value>Property or indexer {0} cannot be assigned to — it is read only</value>
  </data>
  <data name="CSharpErrors_CS0201" xml:space="preserve">
    <value>Only assignment, call, increment, decrement, and new object expressions can be used as a statement</value>
  </data>
  <data name="CSharpErrors_CS0202" xml:space="preserve">
    <value>foreach requires that the return type {0} of '{1}.GetEnumerator()' must have a suitable public MoveNext method and public Current property</value>
  </data>
  <data name="CSharpErrors_CS0204" xml:space="preserve">
    <value>Only 65534 locals are allowed</value>
  </data>
  <data name="CSharpErrors_CS0205" xml:space="preserve">
    <value>Cannot call an abstract base member: {0}</value>
  </data>
  <data name="CSharpErrors_CS0206" xml:space="preserve">
    <value>A property or indexer may not be passed as an out or ref parameter</value>
  </data>
  <data name="CSharpErrors_CS0208" xml:space="preserve">
    <value>Cannot take the address of, get the size of, or declare a pointer to a managed type ({0})</value>
  </data>
  <data name="CSharpErrors_CS0209" xml:space="preserve">
    <value>The type of local declared in a fixed statement must be a pointer type</value>
  </data>
  <data name="CSharpErrors_CS0210" xml:space="preserve">
    <value>You must provide an initializer in a fixed or using statement declaration</value>
  </data>
  <data name="CSharpErrors_CS0211" xml:space="preserve">
    <value>Cannot take the address of the given expression</value>
  </data>
  <data name="CSharpErrors_CS0212" xml:space="preserve">
    <value>You can only take the address of an unfixed expression inside of a fixed statement initializer</value>
  </data>
  <data name="CSharpErrors_CS0213" xml:space="preserve">
    <value>You cannot use the fixed statement to take the address of an already fixed expression</value>
  </data>
  <data name="CSharpErrors_CS0214" xml:space="preserve">
    <value>Pointers and fixed size buffers may only be used in an unsafe context</value>
  </data>
  <data name="CSharpErrors_CS0215" xml:space="preserve">
    <value>The return type of operator True or False must be bool</value>
  </data>
  <data name="CSharpErrors_CS0216" xml:space="preserve">
    <value>The operator {0} requires a matching operator {1} to also be defined</value>
  </data>
  <data name="CSharpErrors_CS0217" xml:space="preserve">
    <value>In order to be applicable as a short circuit operator a user-defined logical operator ({0}) must have the same return type as the type of its 2 parameters.</value>
  </data>
  <data name="CSharpErrors_CS0218" xml:space="preserve">
    <value>The type ({0}) must contain declarations of operator true and operator false</value>
  </data>
  <data name="CSharpErrors_CS0220" xml:space="preserve">
    <value>The operation overflows at compile time in checked mode</value>
  </data>
  <data name="CSharpErrors_CS0221" xml:space="preserve">
    <value>Constant value {0} cannot be converted to a {1} (use 'unchecked' syntax to override)</value>
  </data>
  <data name="CSharpErrors_CS0225" xml:space="preserve">
    <value>The params parameter must be a single dimensional array</value>
  </data>
  <data name="CSharpErrors_CS0226" xml:space="preserve">
    <value>An __arglist expression may only appear inside of a call or new expression.</value>
  </data>
  <data name="CSharpErrors_CS0227" xml:space="preserve">
    <value>Unsafe code may only appear if compiling with /unsafe</value>
  </data>
  <data name="CSharpErrors_CS0228" xml:space="preserve">
    <value>{0} does not contain a definition for {1}, or it is not accessible</value>
  </data>
  <data name="CSharpErrors_CS0229" xml:space="preserve">
    <value>Ambiguity between {0} and {1}</value>
  </data>
  <data name="CSharpErrors_CS0230" xml:space="preserve">
    <value>Type and identifier are both required in a foreach statement</value>
  </data>
  <data name="CSharpErrors_CS0231" xml:space="preserve">
    <value>A params parameter must be the last parameter in a formal parameter list.</value>
  </data>
  <data name="CSharpErrors_CS0233" xml:space="preserve">
    <value>{0} does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)</value>
  </data>
  <data name="CSharpErrors_CS0234" xml:space="preserve">
    <value>The type or namespace name {0} does not exist in the namespace {1} (are you missing an assembly reference?)</value>
  </data>
  <data name="CSharpErrors_CS0236" xml:space="preserve">
    <value>A field initializer cannot reference the nonstatic field, method, or property {0}</value>
  </data>
  <data name="CSharpErrors_CS0238" xml:space="preserve">
    <value>{0} cannot be sealed because it is not an override</value>
  </data>
  <data name="CSharpErrors_CS0239" xml:space="preserve">
    <value>{0} : cannot override inherited member {1} because it is sealed</value>
  </data>
  <data name="CSharpErrors_CS0241" xml:space="preserve">
    <value>Default parameter specifiers are not permitted</value>
  </data>
  <data name="CSharpErrors_CS0242" xml:space="preserve">
    <value>The operation in question is undefined on void pointers</value>
  </data>
  <data name="CSharpErrors_CS0243" xml:space="preserve">
    <value>The Conditional attribute is not valid on 'method' because it is an override method</value>
  </data>
  <data name="CSharpErrors_CS0244" xml:space="preserve">
    <value>Neither 'is' nor 'as' is valid on pointer types</value>
  </data>
  <data name="CSharpErrors_CS0245" xml:space="preserve">
    <value>Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.</value>
  </data>
  <data name="CSharpErrors_CS0246" xml:space="preserve">
    <value>The type or namespace name {0} could not be found (are you missing a using directive or an assembly reference?)</value>
  </data>
  <data name="CSharpErrors_CS0247" xml:space="preserve">
    <value>Cannot use a negative size with stackalloc</value>
  </data>
  <data name="CSharpErrors_CS0248" xml:space="preserve">
    <value>Cannot create an array with a negative size</value>
  </data>
  <data name="CSharpErrors_CS0249" xml:space="preserve">
    <value>Do not override object.Finalize. Instead, provide a destructor.</value>
  </data>
  <data name="CSharpErrors_CS0250" xml:space="preserve">
    <value>Do not directly call your base class Finalize method. It is called automatically from your destructor.</value>
  </data>
  <data name="CSharpErrors_CS0254" xml:space="preserve">
    <value>The right hand side of a fixed statement assignment may not be a cast expression</value>
  </data>
  <data name="CSharpErrors_CS0255" xml:space="preserve">
    <value>stackalloc may not be used in a catch or finally block</value>
  </data>
  <data name="CSharpErrors_CS0260" xml:space="preserve">
    <value>Missing partial modifier on declaration of type {0}; another partial declaration of this type exists</value>
  </data>
  <data name="CSharpErrors_CS0261" xml:space="preserve">
    <value>Partial declarations of {0} must be all classes, all structs, or all interfaces</value>
  </data>
  <data name="CSharpErrors_CS0262" xml:space="preserve">
    <value>Partial declarations of {0} have conflicting accessibility modifiers</value>
  </data>
  <data name="CSharpErrors_CS0263" xml:space="preserve">
    <value>Partial declarations of {0} must not specify different base classes</value>
  </data>
  <data name="CSharpErrors_CS0264" xml:space="preserve">
    <value>Partial declarations of {0} must have the same type parameter names in the same order</value>
  </data>
  <data name="CSharpErrors_CS0265" xml:space="preserve">
    <value>Partial declarations of {0} have inconsistent constraints for type parameter {1}</value>
  </data>
  <data name="CSharpErrors_CS0266" xml:space="preserve">
    <value>Cannot implicitly convert type {0} to {1}. An explicit conversion exists (are you missing a cast?)</value>
  </data>
  <data name="CSharpErrors_CS0267" xml:space="preserve">
    <value>The partial modifier can only appear immediately before 'class', 'struct', or 'interface'</value>
  </data>
  <data name="CSharpErrors_CS0268" xml:space="preserve">
    <value>Imported type {0} is invalid. It contains a circular base class dependency.</value>
  </data>
  <data name="CSharpErrors_CS0269" xml:space="preserve">
    <value>Use of unassigned out parameter {0}</value>
  </data>
  <data name="CSharpErrors_CS0270" xml:space="preserve">
    <value>Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)</value>
  </data>
  <data name="CSharpErrors_CS0271" xml:space="preserve">
    <value>The property or indexer {0} cannot be used in this context because the get accessor is inaccessible</value>
  </data>
  <data name="CSharpErrors_CS0272" xml:space="preserve">
    <value>The property or indexer {0} cannot be used in this context because the set accessor is inaccessible</value>
  </data>
  <data name="CSharpErrors_CS0273" xml:space="preserve">
    <value>The accessibility modifier of the {0} accessor must be more restrictive than the property or indexer {1}</value>
  </data>
  <data name="CSharpErrors_CS0274" xml:space="preserve">
    <value>Cannot specify accessibility modifiers for both accessors of the property or indexer {0}</value>
  </data>
  <data name="CSharpErrors_CS0275" xml:space="preserve">
    <value>{0}: accessibility modifiers may not be used on accessors in an interface</value>
  </data>
  <data name="CSharpErrors_CS0276" xml:space="preserve">
    <value>{0}: accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor</value>
  </data>
  <data name="CSharpErrors_CS0277" xml:space="preserve">
    <value>{0} does not implement interface member {1}. {2} is not public</value>
  </data>
  <data name="CSharpErrors_CS0281" xml:space="preserve">
    <value>Friend access was granted to {0}, but the output assembly is named {1}. Try adding a reference to {0} or changing the output assembly name to match.</value>
  </data>
  <data name="CSharpErrors_CS0283" xml:space="preserve">
    <value>The type {0} cannot be declared const</value>
  </data>
  <data name="CSharpErrors_CS0304" xml:space="preserve">
    <value>Cannot create an instance of the variable type {0} because it does not have the new() constraint</value>
  </data>
  <data name="CSharpErrors_CS0305" xml:space="preserve">
    <value>Using the generic type {0} requires {1} type arguments</value>
  </data>
  <data name="CSharpErrors_CS0306" xml:space="preserve">
    <value>The type {0} may not be used as a type argument</value>
  </data>
  <data name="CSharpErrors_CS0307" xml:space="preserve">
    <value>The {0} {1} is not a generic method. If you intended an expression list, use parentheses around the &lt; expression.</value>
  </data>
  <data name="CSharpErrors_CS0308" xml:space="preserve">
    <value>The non-generic type-or-method {0} cannot be used with type arguments.</value>
  </data>
  <data name="CSharpErrors_CS0310" xml:space="preserve">
    <value>The type {0} must be a non-abstract type with a public parameterless constructor in order to use it as parameter {1} in the generic type or method {2}</value>
  </data>
  <data name="CSharpErrors_CS0311" xml:space="preserve">
    <value>The type {0} cannot be used as type parameter {2} in the generic type or method {3}. There is no implicit reference conversion from {0} to {1}.</value>
  </data>
  <data name="CSharpErrors_CS0312" xml:space="preserve">
    <value>The type {0} cannot be used as type parameter {1} in the generic type or method {2}. The nullable type {0} does not satisfy the constraint of {3}.</value>
  </data>
  <data name="CSharpErrors_CS0313" xml:space="preserve">
    <value>The type {0} cannot be used as type parameter {1} in the generic type or method {2}. The nullable type {0} does not satisfy the constraint of {2}. Nullable types cannot satisfy any interface constraints.</value>
  </data>
  <data name="CSharpErrors_CS0314" xml:space="preserve">
    <value>The type {0} cannot be used as type parameter {1} in the generic type or method {2}. There is no boxing conversion or type parameter conversion from {3} to {4}.</value>
  </data>
  <data name="CSharpErrors_CS0315" xml:space="preserve">
    <value>The type {0} cannot be used as type parameter '{1}' in the generic type or method '{2}'. There is no boxing conversion from '{3}' to '{4}'.</value>
  </data>
  <data name="CSharpErrors_CS0316" xml:space="preserve">
    <value>The parameter name {0} conflicts with an automatically-generated parameter name.</value>
  </data>
  <data name="CSharpErrors_CS0400" xml:space="preserve">
    <value>The type or namespace name {0} could not be found in the global namespace (are you missing an assembly reference?)</value>
  </data>
  <data name="CSharpErrors_CS0401" xml:space="preserve">
    <value>The new() constraint must be the last constraint specified</value>
  </data>
  <data name="CSharpErrors_CS0403" xml:space="preserve">
    <value>Cannot convert null to type parameter {0} because it could be a non-nullable value type. Consider using default({0}) instead.</value>
  </data>
  <data name="CSharpErrors_CS0404" xml:space="preserve">
    <value>'&lt;' unexpected : attributes cannot be generic</value>
  </data>
  <data name="CSharpErrors_CS0405" xml:space="preserve">
    <value>Duplicate constraint {0} for type parameter {1}</value>
  </data>
  <data name="CSharpErrors_CS0406" xml:space="preserve">
    <value>The class type constraint {0} must come before any other constraints</value>
  </data>
  <data name="CSharpErrors_CS0407" xml:space="preserve">
    <value>{0} has the wrong return type</value>
  </data>
  <data name="CSharpErrors_CS0409" xml:space="preserve">
    <value>A constraint clause has already been specified for type parameter {0}. All of the constraints for a type parameter must be specified in a single where clause.</value>
  </data>
  <data name="CSharpErrors_CS0410" xml:space="preserve">
    <value>No overload for {0} has the correct parameter and return types</value>
  </data>
  <data name="CSharpErrors_CS0411" xml:space="preserve">
    <value>The type arguments for method {0} cannot be inferred from the usage. Try specifying the type arguments explicitly.</value>
  </data>
  <data name="CSharpErrors_CS0412" xml:space="preserve">
    <value>{0}: a parameter or local variable cannot have the same name as a method type parameter</value>
  </data>
  <data name="CSharpErrors_CS0413" xml:space="preserve">
    <value>The type parameter {0} cannot be used with the 'as' operator because it does not have a class type constraint nor a constraint that is a class</value>
  </data>
  <data name="CSharpErrors_CS0415" xml:space="preserve">
    <value>The {0} attribute is valid only on an indexer that is not an explicit interface member declaration</value>
  </data>
  <data name="CSharpErrors_CS0416" xml:space="preserve">
    <value>{0}: an attribute argument cannot use type parameters</value>
  </data>
  <data name="CSharpErrors_CS0417" xml:space="preserve">
    <value>{0}: cannot provide arguments when creating an instance of a variable type</value>
  </data>
  <data name="CSharpErrors_CS0418" xml:space="preserve">
    <value>{0}: an abstract class cannot be sealed or static</value>
  </data>
  <data name="CSharpErrors_CS0423" xml:space="preserve">
    <value>Since {0} has the ComImport attribute, {1} must be extern or abstract</value>
  </data>
  <data name="CSharpErrors_CS0424" xml:space="preserve">
    <value>{0}: a class with the ComImport attribute cannot specify a base class</value>
  </data>
  <data name="CSharpErrors_CS0425" xml:space="preserve">
    <value>The constraints for type parameter {0} of method {1} must match the constraints for type parameter {2} of interface method {3}. Consider using an explicit interface implementation instead.</value>
  </data>
  <data name="CSharpErrors_CS0426" xml:space="preserve">
    <value>The type name {0} does not exist in the type {1}</value>
  </data>
  <data name="CSharpErrors_CS0428" xml:space="preserve">
    <value>Cannot convert method group {0} to non-delegate type {1}. Did you intend to invoke the method?</value>
  </data>
  <data name="CSharpErrors_CS0430" xml:space="preserve">
    <value>The extern alias {0} was not specified in a /reference option</value>
  </data>
  <data name="CSharpErrors_CS0431" xml:space="preserve">
    <value>Cannot use alias {0} with '::' since the alias references a type. Use '.' instead.</value>
  </data>
  <data name="CSharpErrors_CS0432" xml:space="preserve">
    <value>Alias {0} not found</value>
  </data>
  <data name="CSharpErrors_CS0433" xml:space="preserve">
    <value>The type {0} exists in both {1} and {2}</value>
  </data>
  <data name="CSharpErrors_CS0434" xml:space="preserve">
    <value>The namespace {0} in {1} conflicts with the type {2} in {3}</value>
  </data>
  <data name="CSharpErrors_CS0438" xml:space="preserve">
    <value>The type {0} in {1} conflicts with the namespace {2} in {3}.</value>
  </data>
  <data name="CSharpErrors_CS0439" xml:space="preserve">
    <value>An extern alias declaration must precede all other elements defined in the namespace</value>
  </data>
  <data name="CSharpErrors_CS0441" xml:space="preserve">
    <value>{0}: a class cannot be both static and sealed</value>
  </data>
  <data name="CSharpErrors_CS0442" xml:space="preserve">
    <value>{0}: abstract properties cannot have private accessors</value>
  </data>
  <data name="CSharpErrors_CS0443" xml:space="preserve">
    <value>Syntax error, value expected</value>
  </data>
  <data name="CSharpErrors_CS0445" xml:space="preserve">
    <value>Cannot modify the result of an unboxing conversion</value>
  </data>
  <data name="CSharpErrors_CS0446" xml:space="preserve">
    <value>Foreach cannot operate on a {0}. Did you intend to invoke the {0}?</value>
  </data>
  <data name="CSharpErrors_CS0447" xml:space="preserve">
    <value>Attributes cannot be used on type arguments, only on type parameters</value>
  </data>
  <data name="CSharpErrors_CS0448" xml:space="preserve">
    <value>The return type for ++ or -- operator must be the containing type or derived from the containing type</value>
  </data>
  <data name="CSharpErrors_CS0449" xml:space="preserve">
    <value>The 'class' or 'struct' constraint must come before any other constraints</value>
  </data>
  <data name="CSharpErrors_CS0450" xml:space="preserve">
    <value>{0}: cannot specify both a constraint class and the 'class' or 'struct' constraint</value>
  </data>
  <data name="CSharpErrors_CS0451" xml:space="preserve">
    <value>The 'new()' constraint cannot be used with the 'struct' constraint</value>
  </data>
  <data name="CSharpErrors_CS0452" xml:space="preserve">
    <value>The type {0} must be a reference type in order to use it as parameter {1} in the generic type or method {2}.</value>
  </data>
  <data name="CSharpErrors_CS0453" xml:space="preserve">
    <value>The type {0} must be a non-nullable value type in order to use it as parameter {1} in the generic type or method {2}</value>
  </data>
  <data name="CSharpErrors_CS0454" xml:space="preserve">
    <value>Circular constraint dependency involving {0} and {1}</value>
  </data>
  <data name="CSharpErrors_CS0455" xml:space="preserve">
    <value>Type parameter {0} inherits conflicting constraints {1} and {2}</value>
  </data>
  <data name="CSharpErrors_CS0456" xml:space="preserve">
    <value>Type parameter {0} has the 'struct' constraint so {0} cannot be used as a constraint for {1}</value>
  </data>
  <data name="CSharpErrors_CS0457" xml:space="preserve">
    <value>Ambiguous user defined conversions {0} and {1} when converting from {2} to {3}</value>
  </data>
  <data name="CSharpErrors_CS0459" xml:space="preserve">
    <value>Cannot take the address of a read-only local variable</value>
  </data>
  <data name="CSharpErrors_CS0460" xml:space="preserve">
    <value>Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly</value>
  </data>
  <data name="CSharpErrors_CS0462" xml:space="preserve">
    <value>The inherited members {0} and {1} have the same signature in type {1}, so they cannot be overridden</value>
  </data>
  <data name="CSharpErrors_CS0463" xml:space="preserve">
    <value>Evaluation of the decimal constant expression failed with error: {0}</value>
  </data>
  <data name="CSharpErrors_CS0466" xml:space="preserve">
    <value>{0} should not have a params parameter since {1} does not</value>
  </data>
  <data name="CSharpErrors_CS0468" xml:space="preserve">
    <value>Ambiguity between type {0} and type {1}</value>
  </data>
  <data name="CSharpErrors_CS0470" xml:space="preserve">
    <value>Method {0} cannot implement interface accessor {1} for type {2}. Use an explicit interface implementation.</value>
  </data>
  <data name="CSharpErrors_CS0471" xml:space="preserve">
    <value>The method [0} is not a generic method. If you intended an expression list, use parentheses around the &amp;lt; expression.</value>
  </data>
  <data name="CSharpErrors_CS0473" xml:space="preserve">
    <value>Explicit interface implementation {0} matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.</value>
  </data>
  <data name="CSharpErrors_CS0500" xml:space="preserve">
    <value>{0} cannot declare a body because it is marked abstract</value>
  </data>
  <data name="CSharpErrors_CS0501" xml:space="preserve">
    <value>{0} must declare a body because it is not marked abstract, extern, or partial</value>
  </data>
  <data name="CSharpErrors_CS0502" xml:space="preserve">
    <value>{0} cannot be both abstract and sealed</value>
  </data>
  <data name="CSharpErrors_CS0503" xml:space="preserve">
    <value>The abstract method {0} cannot be marked virtual</value>
  </data>
  <data name="CSharpErrors_CS0504" xml:space="preserve">
    <value>The constant {0} cannot be marked static</value>
  </data>
  <data name="CSharpErrors_CS0505" xml:space="preserve">
    <value>{0}: cannot override because {1} is not a function</value>
  </data>
  <data name="CSharpErrors_CS0506" xml:space="preserve">
    <value>{0} : cannot override inherited member {1} because it is not marked 'virtual', 'abstract', or 'override'</value>
  </data>
  <data name="CSharpErrors_CS0507" xml:space="preserve">
    <value>{0} : cannot change access modifiers when overriding {1} inherited member {2}</value>
  </data>
  <data name="CSharpErrors_CS0508" xml:space="preserve">
    <value>{0}: return type must be {1} to match overridden member {2}</value>
  </data>
  <data name="CSharpErrors_CS0509" xml:space="preserve">
    <value>{0} : cannot derive from sealed type {1}</value>
  </data>
  <data name="CSharpErrors_CS0513" xml:space="preserve">
    <value>{0} is abstract but it is contained in nonabstract class {1}</value>
  </data>
  <data name="CSharpErrors_CS0514" xml:space="preserve">
    <value>{0} : static constructor cannot have an explicit 'this' or 'base' constructor call</value>
  </data>
  <data name="CSharpErrors_CS0515" xml:space="preserve">
    <value>{0} : access modifiers are not allowed on static constructors</value>
  </data>
  <data name="CSharpErrors_CS0516" xml:space="preserve">
    <value>Constructor {0} can not call itself</value>
  </data>
  <data name="CSharpErrors_CS0517" xml:space="preserve">
    <value>{0} has no base class and cannot call a base constructor</value>
  </data>
  <data name="CSharpErrors_CS0518" xml:space="preserve">
    <value>Predefined type {0} is not defined or imported</value>
  </data>
  <data name="CSharpErrors_CS0520" xml:space="preserve">
    <value>Predefined type {0} is declared incorrectly</value>
  </data>
  <data name="CSharpErrors_CS0522" xml:space="preserve">
    <value>{0} : structs cannot call base class constructors</value>
  </data>
  <data name="CSharpErrors_CS0523" xml:space="preserve">
    <value>Struct member {0} of type {1} causes a cycle in the struct layout</value>
  </data>
  <data name="CSharpErrors_CS0524" xml:space="preserve">
    <value>{0} : interfaces cannot declare types</value>
  </data>
  <data name="CSharpErrors_CS0525" xml:space="preserve">
    <value>Interfaces cannot contain fields</value>
  </data>
  <data name="CSharpErrors_CS0526" xml:space="preserve">
    <value>Interfaces cannot contain constructors</value>
  </data>
  <data name="CSharpErrors_CS0527" xml:space="preserve">
    <value>Type {0} in interface list is not an interface</value>
  </data>
  <data name="CSharpErrors_CS0528" xml:space="preserve">
    <value>{0} is already listed in interface list</value>
  </data>
  <data name="CSharpErrors_CS0529" xml:space="preserve">
    <value>Inherited interface {0} causes a cycle in the interface hierarchy of {1}</value>
  </data>
  <data name="CSharpErrors_CS0531" xml:space="preserve">
    <value>{0} : interface members cannot have a definition</value>
  </data>
  <data name="CSharpErrors_CS0533" xml:space="preserve">
    <value>{0} hides inherited abstract member {1}</value>
  </data>
  <data name="CSharpErrors_CS0534" xml:space="preserve">
    <value>{0} does not implement inherited abstract member {1}</value>
  </data>
  <data name="CSharpErrors_CS0535" xml:space="preserve">
    <value>{0} does not implement interface member {1}</value>
  </data>
  <data name="CSharpErrors_CS0537" xml:space="preserve">
    <value>The class System.Object cannot have a base class or implement an interface</value>
  </data>
  <data name="CSharpErrors_CS0538" xml:space="preserve">
    <value>{0} in explicit interface declaration is not an interface</value>
  </data>
  <data name="CSharpErrors_CS0539" xml:space="preserve">
    <value>{0} in explicit interface declaration is not a member of interface</value>
  </data>
  <data name="CSharpErrors_CS0540" xml:space="preserve">
    <value>{0} : containing type does not implement interface {1}</value>
  </data>
  <data name="CSharpErrors_CS0541" xml:space="preserve">
    <value>{0} : explicit interface declaration can only be declared in a class or struct</value>
  </data>
  <data name="CSharpErrors_CS0542" xml:space="preserve">
    <value>{0} : member names cannot be the same as their enclosing type</value>
  </data>
  <data name="CSharpErrors_CS0543" xml:space="preserve">
    <value>{0} : the enumerator value is too large to fit in its type</value>
  </data>
  <data name="CSharpErrors_CS0544" xml:space="preserve">
    <value>{0}: cannot override because {1} is not a property</value>
  </data>
  <data name="CSharpErrors_CS0545" xml:space="preserve">
    <value>{0} : cannot override because {1} does not have an overridable get accessor</value>
  </data>
  <data name="CSharpErrors_CS0546" xml:space="preserve">
    <value>{0} : cannot override because {1} does not have an overridable set accessor</value>
  </data>
  <data name="CSharpErrors_CS0547" xml:space="preserve">
    <value>{0} : property or indexer cannot have void type</value>
  </data>
  <data name="CSharpErrors_CS0548" xml:space="preserve">
    <value>{0} : property or indexer must have at least one accessor</value>
  </data>
  <data name="CSharpErrors_CS0549" xml:space="preserve">
    <value>{0} is a new virtual member in sealed class {1}</value>
  </data>
  <data name="CSharpErrors_CS0550" xml:space="preserve">
    <value>{0} adds an accessor not found in interface member {1}</value>
  </data>
  <data name="CSharpErrors_CS0551" xml:space="preserve">
    <value>Explicit interface implementation {0} is missing accessor {1}</value>
  </data>
  <data name="CSharpErrors_CS0552" xml:space="preserve">
    <value>{0} : user defined conversion to/from interface</value>
  </data>
  <data name="CSharpErrors_CS0553" xml:space="preserve">
    <value>{0} : user defined conversion to/from base class</value>
  </data>
  <data name="CSharpErrors_CS0554" xml:space="preserve">
    <value>{0} : user defined conversion to/from derived class</value>
  </data>
  <data name="CSharpErrors_CS0555" xml:space="preserve">
    <value>User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type</value>
  </data>
  <data name="CSharpErrors_CS0556" xml:space="preserve">
    <value>User-defined conversion must convert to or from the enclosing type</value>
  </data>
  <data name="CSharpErrors_CS0557" xml:space="preserve">
    <value>Duplicate user-defined conversion in type {0}</value>
  </data>
  <data name="CSharpErrors_CS0558" xml:space="preserve">
    <value>User-defined operator {0} must be declared static and public</value>
  </data>
  <data name="CSharpErrors_CS0559" xml:space="preserve">
    <value>The parameter type for ++ or -- operator must be the containing type</value>
  </data>
  <data name="CSharpErrors_CS0562" xml:space="preserve">
    <value>The parameter of a unary operator must be the containing type</value>
  </data>
  <data name="CSharpErrors_CS0563" xml:space="preserve">
    <value>One of the parameters of a binary operator must be the containing type</value>
  </data>
  <data name="CSharpErrors_CS0564" xml:space="preserve">
    <value>The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int</value>
  </data>
  <data name="CSharpErrors_CS0567" xml:space="preserve">
    <value>Interfaces cannot contain operators</value>
  </data>
  <data name="CSharpErrors_CS0568" xml:space="preserve">
    <value>Structs cannot contain explicit parameterless constructors</value>
  </data>
  <data name="CSharpErrors_CS0569" xml:space="preserve">
    <value>{1} : cannot override {0} because it is not supported by the language</value>
  </data>
  <data name="CSharpErrors_CS0570" xml:space="preserve">
    <value>Property, indexer, or event {0} is not supported by the language; try directly calling accessor method {1}!</value>
  </data>
  <data name="CSharpErrors_CS0571" xml:space="preserve">
    <value>{0} : cannot explicitly call operator or accessor</value>
  </data>
  <data name="CSharpErrors_CS0572" xml:space="preserve">
    <value>{0} : cannot reference a type through an expression; try {1} instead</value>
  </data>
  <data name="CSharpErrors_CS0573" xml:space="preserve">
    <value>{0} : cannot have instance field initializers in structs</value>
  </data>
  <data name="CSharpErrors_CS0574" xml:space="preserve">
    <value>Name of destructor must match name of class</value>
  </data>
  <data name="CSharpErrors_CS0575" xml:space="preserve">
    <value>Only class types can contain destructors</value>
  </data>
  <data name="CSharpErrors_CS0576" xml:space="preserve">
    <value>Namespace {0} contains a definition conflicting with alias {1}</value>
  </data>
  <data name="CSharpErrors_CS0577" xml:space="preserve">
    <value>The Conditional attribute is not valid on {0} because it is a constructor, destructor, operator, or explicit interface implementation</value>
  </data>
  <data name="CSharpErrors_CS0578" xml:space="preserve">
    <value>The Conditional attribute is not valid on {0} because its return type is not void</value>
  </data>
  <data name="CSharpErrors_CS0579" xml:space="preserve">
    <value>Duplicate {0} attribute</value>
  </data>
  <data name="CSharpErrors_CS0582" xml:space="preserve">
    <value>The Conditional not valid on interface members</value>
  </data>
  <data name="CSharpErrors_CS0583" xml:space="preserve">
    <value>Internal Compiler Error. An internal error has occurred in the compiler. To work around this problem, try simplifying or changing the program near the locations listed below. Locations at the top of the list are closer to the point at which the internal error occurred. Errors such as this can be reported to Microsoft by using the /errorreport option.</value>
  </data>
  <data name="CSharpErrors_CS0584" xml:space="preserve">
    <value>Internal Compiler Error: stage {0} symbol {1}</value>
  </data>
  <data name="CSharpErrors_CS0585" xml:space="preserve">
    <value>Internal Compiler Error: stage {0}</value>
  </data>
  <data name="CSharpErrors_CS0586" xml:space="preserve">
    <value>Internal Compiler Error: stage {0}</value>
  </data>
  <data name="CSharpErrors_CS0587" xml:space="preserve">
    <value>Internal Compiler Error: stage {0}</value>
  </data>
  <data name="CSharpErrors_CS0588" xml:space="preserve">
    <value>Internal Compiler Error: stage 'LEX'</value>
  </data>
  <data name="CSharpErrors_CS0589" xml:space="preserve">
    <value>Internal Compiler Error: stage 'PARSE'</value>
  </data>
  <data name="CSharpErrors_CS0590" xml:space="preserve">
    <value>User-defined operators cannot return void</value>
  </data>
  <data name="CSharpErrors_CS0591" xml:space="preserve">
    <value>Invalid value for argument to {0} attribute</value>
  </data>
  <data name="CSharpErrors_CS0592" xml:space="preserve">
    <value>Attribute {0} is not valid on this declaration type. It is valid on {1} declarations only.</value>
  </data>
  <data name="CSharpErrors_CS0594" xml:space="preserve">
    <value>Floating-point constant is outside the range of type {0}</value>
  </data>
  <data name="CSharpErrors_CS0596" xml:space="preserve">
    <value>The Guid attribute must be specified with the ComImport attribute</value>
  </data>
  <data name="CSharpErrors_CS0599" xml:space="preserve">
    <value>Invalid value for named attribute argument {0}</value>
  </data>
  <data name="CSharpErrors_CS0601" xml:space="preserve">
    <value>The DllImport attribute must be specified on a method marked 'static' and 'extern'</value>
  </data>
  <data name="CSharpErrors_CS0609" xml:space="preserve">
    <value>Cannot set the IndexerName attribute on an indexer marked override</value>
  </data>
  <data name="CSharpErrors_CS0610" xml:space="preserve">
    <value>Field or property cannot be of type {0}</value>
  </data>
  <data name="CSharpErrors_CS0611" xml:space="preserve">
    <value>Array elements cannot be of type {0}</value>
  </data>
  <data name="CSharpErrors_CS0616" xml:space="preserve">
    <value>{0} is not an attribute class</value>
  </data>
  <data name="CSharpErrors_CS0617" xml:space="preserve">
    <value>{0} is not a valid named attribute argument because it is not a valid attribute parameter type</value>
  </data>
  <data name="CSharpErrors_CS0619" xml:space="preserve">
    <value>{0} is obsolete: {1}</value>
  </data>
  <data name="CSharpErrors_CS0620" xml:space="preserve">
    <value>Indexers cannot have void type</value>
  </data>
  <data name="CSharpErrors_CS0621" xml:space="preserve">
    <value>{0} : virtual or abstract members cannot be private</value>
  </data>
  <data name="CSharpErrors_CS0622" xml:space="preserve">
    <value>Can only use array initializer expressions to assign to array types. Try using a new expression instead.</value>
  </data>
  <data name="CSharpErrors_CS0623" xml:space="preserve">
    <value>Array initializers can only be used in a variable or field initializer. Try using a new expression instead.</value>
  </data>
  <data name="CSharpErrors_CS0625" xml:space="preserve">
    <value>{0}: instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute</value>
  </data>
  <data name="CSharpErrors_CS0629" xml:space="preserve">
    <value>Conditional member {0} cannot implement interface member {1} in type {2}</value>
  </data>
  <data name="CSharpErrors_CS0631" xml:space="preserve">
    <value>ref and out are not valid in this context</value>
  </data>
  <data name="CSharpErrors_CS0633" xml:space="preserve">
    <value>The argument to the {0} attribute must be a valid identifier</value>
  </data>
  <data name="CSharpErrors_CS0635" xml:space="preserve">
    <value>{0} : System.Interop.UnmanagedType.CustomMarshaller requires named arguments ComType and Marshal</value>
  </data>
  <data name="CSharpErrors_CS0636" xml:space="preserve">
    <value>The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)</value>
  </data>
  <data name="CSharpErrors_CS0637" xml:space="preserve">
    <value>The FieldOffset attribute is not allowed on static or const fields</value>
  </data>
  <data name="CSharpErrors_CS0641" xml:space="preserve">
    <value>{0} : attribute is only valid on classes derived from System.Attribute</value>
  </data>
  <data name="CSharpErrors_CS0643" xml:space="preserve">
    <value>{0} duplicate named attribute argument</value>
  </data>
  <data name="CSharpErrors_CS0644" xml:space="preserve">
    <value>{0} cannot derive from special class {1}</value>
  </data>
  <data name="CSharpErrors_CS0645" xml:space="preserve">
    <value>Identifier too long</value>
  </data>
  <data name="CSharpErrors_CS0646" xml:space="preserve">
    <value>Cannot specify the DefaultMember attribute on a type containing an indexer</value>
  </data>
  <data name="CSharpErrors_CS0647" xml:space="preserve">
    <value>Error emitting {0} attribute -- {1}</value>
  </data>
  <data name="CSharpErrors_CS0648" xml:space="preserve">
    <value>{0} is a type not supported by the language</value>
  </data>
  <data name="CSharpErrors_CS0650" xml:space="preserve">
    <value>Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.</value>
  </data>
  <data name="CSharpErrors_CS0653" xml:space="preserve">
    <value>Cannot apply attribute class {0} because it is abstract</value>
  </data>
  <data name="CSharpErrors_CS0655" xml:space="preserve">
    <value>{0} is not a valid named attribute argument because it is not a valid attribute parameter type</value>
  </data>
  <data name="CSharpErrors_CS0656" xml:space="preserve">
    <value>Missing compiler required member {0}</value>
  </data>
  <data name="CSharpErrors_CS0662" xml:space="preserve">
    <value>{0} cannot specify only Out attribute on a ref parameter. Use both In and Out attributes, or neither.</value>
  </data>
  <data name="CSharpErrors_CS0663" xml:space="preserve">
    <value>Cannot define overloaded methods that differ only on ref and out.</value>
  </data>
  <data name="CSharpErrors_CS0664" xml:space="preserve">
    <value>Literal of type double cannot be implicitly converted to type {0}; use an {1} suffix to create a literal of this type</value>
  </data>
  <data name="CSharpErrors_CS0666" xml:space="preserve">
    <value>{0} : new protected member declared in struct</value>
  </data>
  <data name="CSharpErrors_CS0667" xml:space="preserve">
    <value>The feature {0} is deprecated. Please use {1} instead.</value>
  </data>
  <data name="CSharpErrors_CS0668" xml:space="preserve">
    <value>Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type</value>
  </data>
  <data name="CSharpErrors_CS0669" xml:space="preserve">
    <value>A class with the ComImport attribute cannot have a user-defined constructor</value>
  </data>
  <data name="CSharpErrors_CS0670" xml:space="preserve">
    <value>Field cannot have void type</value>
  </data>
  <data name="CSharpErrors_CS0673" xml:space="preserve">
    <value>System.Void cannot be used from C# -- use typeof(void) to get the void type object.</value>
  </data>
  <data name="CSharpErrors_CS0674" xml:space="preserve">
    <value>Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.</value>
  </data>
  <data name="CSharpErrors_CS0677" xml:space="preserve">
    <value>{0}: a volatile field cannot be of the type {1}</value>
  </data>
  <data name="CSharpErrors_CS0678" xml:space="preserve">
    <value>{0}: a field can not be both volatile and readonly</value>
  </data>
  <data name="CSharpErrors_CS0681" xml:space="preserve">
    <value>The modifier 'abstract' is not valid on fields. Try using a property instead</value>
  </data>
  <data name="CSharpErrors_CS0682" xml:space="preserve">
    <value>{0} cannot implement {1} because it is not supported by the language</value>
  </data>
  <data name="CSharpErrors_CS0683" xml:space="preserve">
    <value>{0} explicit method implementation cannot implement {1} because it is an accessor</value>
  </data>
  <data name="CSharpErrors_CS0685" xml:space="preserve">
    <value>Conditional member {0} cannot have an out parameter</value>
  </data>
  <data name="CSharpErrors_CS0686" xml:space="preserve">
    <value>Accessor {0} cannot implement interface member {1} for type {2}. Use an explicit interface implementation.</value>
  </data>
  <data name="CSharpErrors_CS0687" xml:space="preserve">
    <value>The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.</value>
  </data>
  <data name="CSharpErrors_CS0689" xml:space="preserve">
    <value>Cannot derive from {0} because it is a type parameter</value>
  </data>
  <data name="CSharpErrors_CS0690" xml:space="preserve">
    <value>Input file {0} contains invalid metadata.</value>
  </data>
  <data name="CSharpErrors_CS0692" xml:space="preserve">
    <value>Duplicate type parameter {0}</value>
  </data>
  <data name="CSharpErrors_CS0694" xml:space="preserve">
    <value>Type parameter {0} has the same name as the containing type, or method</value>
  </data>
  <data name="CSharpErrors_CS0695" xml:space="preserve">
    <value>{0} cannot implement both {1} and {1} because they may unify for some type parameter substitutions</value>
  </data>
  <data name="CSharpErrors_CS0698" xml:space="preserve">
    <value>A generic type cannot derive from {0} because it is an attribute class</value>
  </data>
  <data name="CSharpErrors_CS0699" xml:space="preserve">
    <value>{0} does not define type parameter {1}</value>
  </data>
  <data name="CSharpErrors_CS0701" xml:space="preserve">
    <value>{0} is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</value>
  </data>
  <data name="CSharpErrors_CS0702" xml:space="preserve">
    <value>Constraint cannot be special class {0}</value>
  </data>
  <data name="CSharpErrors_CS0703" xml:space="preserve">
    <value>Inconsistent accessibility: constraint type {0} is less accessible than {1}</value>
  </data>
  <data name="CSharpErrors_CS0704" xml:space="preserve">
    <value>Cannot do member lookup in {0} because it is a type parameter</value>
  </data>
  <data name="CSharpErrors_CS0706" xml:space="preserve">
    <value>Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.</value>
  </data>
  <data name="CSharpErrors_CS0708" xml:space="preserve">
    <value>{0}: cannot declare instance members in a static class</value>
  </data>
  <data name="CSharpErrors_CS0709" xml:space="preserve">
    <value>{0}: cannot derive from static class {1}</value>
  </data>
  <data name="CSharpErrors_CS0710" xml:space="preserve">
    <value>Static classes cannot have instance constructors</value>
  </data>
  <data name="CSharpErrors_CS0711" xml:space="preserve">
    <value>Static classes cannot contain destructors</value>
  </data>
  <data name="CSharpErrors_CS0712" xml:space="preserve">
    <value>Cannot create an instance of the static class {0}</value>
  </data>
  <data name="CSharpErrors_CS0713" xml:space="preserve">
    <value>Static class {0} cannot derive from type {1}. Static classes must derive from object.</value>
  </data>
  <data name="CSharpErrors_CS0714" xml:space="preserve">
    <value>{0} : static classes cannot implement interfaces</value>
  </data>
  <data name="CSharpErrors_CS0715" xml:space="preserve">
    <value>{0} : static classes cannot contain user defined operators</value>
  </data>
  <data name="CSharpErrors_CS0716" xml:space="preserve">
    <value>Cannot convert to static type {0}</value>
  </data>
  <data name="CSharpErrors_CS0717" xml:space="preserve">
    <value>{0}: static classes cannot be used as constraints</value>
  </data>
  <data name="CSharpErrors_CS0718" xml:space="preserve">
    <value>{0}: static types cannot be used as type arguments</value>
  </data>
  <data name="CSharpErrors_CS0719" xml:space="preserve">
    <value>{0}: array elements cannot be of static type</value>
  </data>
  <data name="CSharpErrors_CS0720" xml:space="preserve">
    <value>{0}: cannot declare indexers in a static class</value>
  </data>
  <data name="CSharpErrors_CS0721" xml:space="preserve">
    <value>{0}: static types cannot be used as parameters</value>
  </data>
  <data name="CSharpErrors_CS0722" xml:space="preserve">
    <value>{0}: static types cannot be used as return types</value>
  </data>
  <data name="CSharpErrors_CS0723" xml:space="preserve">
    <value>Cannot declare variable of static type {0}</value>
  </data>
  <data name="CSharpErrors_CS0724" xml:space="preserve">
    <value>does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</value>
  </data>
  <data name="CSharpErrors_CS0729" xml:space="preserve">
    <value>Type {0} is defined in this assembly, but a type forwarder is specified for it</value>
  </data>
  <data name="CSharpErrors_CS0730" xml:space="preserve">
    <value>Cannot forward type {0} because it is a nested type of {1}</value>
  </data>
  <data name="CSharpErrors_CS0731" xml:space="preserve">
    <value>The type forwarder for type {0} in assembly {1} causes a cycle</value>
  </data>
  <data name="CSharpErrors_CS0733" xml:space="preserve">
    <value>Cannot forward generic type, {0}</value>
  </data>
  <data name="CSharpErrors_CS0734" xml:space="preserve">
    <value>The /moduleassemblyname option may only be specified when building a target type of 'module'</value>
  </data>
  <data name="CSharpErrors_CS0735" xml:space="preserve">
    <value>Invalid type specified as an argument for TypeForwardedTo attribute</value>
  </data>
  <data name="CSharpErrors_CS0736" xml:space="preserve">
    <value>{0} does not implement interface member {1}. {2} cannot implement an interface member because it is static.</value>
  </data>
  <data name="CSharpErrors_CS0737" xml:space="preserve">
    <value>{0} does not implement interface member {1}. {2} cannot implement an interface member because it is not public.</value>
  </data>
  <data name="CSharpErrors_CS0738" xml:space="preserve">
    <value>{0} does not implement interface member {1}. {2} cannot implement {1} because it does not have the matching return type of {3}.</value>
  </data>
  <data name="CSharpErrors_CS0739" xml:space="preserve">
    <value>{0} duplicate TypeForwardedToAttribute.</value>
  </data>
  <data name="CSharpErrors_CS0742" xml:space="preserve">
    <value>A query body must end with a select clause or a group clause</value>
  </data>
  <data name="CSharpErrors_CS0743" xml:space="preserve">
    <value>Expected contextual keyword 'on'</value>
  </data>
  <data name="CSharpErrors_CS0744" xml:space="preserve">
    <value>Expected contextual keyword 'equals'</value>
  </data>
  <data name="CSharpErrors_CS0745" xml:space="preserve">
    <value>Expected contextual keyword 'by'</value>
  </data>
  <data name="CSharpErrors_CS0746" xml:space="preserve">
    <value>Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.</value>
  </data>
  <data name="CSharpErrors_CS0747" xml:space="preserve">
    <value>Invalid initializer member declarator.</value>
  </data>
  <data name="CSharpErrors_CS0748" xml:space="preserve">
    <value>Inconsistent lambda parameter usage; all parameter types must either be explicit or implicit.</value>
  </data>
  <data name="CSharpErrors_CS0750" xml:space="preserve">
    <value>A partial method cannot have access modifiers or the virtual, abstract, override, new, sealed, or extern modifiers.</value>
  </data>
  <data name="CSharpErrors_CS0751" xml:space="preserve">
    <value>A partial method must be declared in a partial class or partial struct</value>
  </data>
  <data name="CSharpErrors_CS0752" xml:space="preserve">
    <value>A partial method cannot have out parameters</value>
  </data>
  <data name="CSharpErrors_CS0753" xml:space="preserve">
    <value>Only methods, classes, structs, or interfaces may be partial.</value>
  </data>
  <data name="CSharpErrors_CS0754" xml:space="preserve">
    <value>A partial method may not explicitly implement an interface method.</value>
  </data>
  <data name="CSharpErrors_CS0755" xml:space="preserve">
    <value>Both partial method declarations must be extension methods or neither may be an extension method.</value>
  </data>
  <data name="CSharpErrors_CS0756" xml:space="preserve">
    <value>A partial method may not have multiple defining declarations.</value>
  </data>
  <data name="CSharpErrors_CS0757" xml:space="preserve">
    <value>A partial method may not have multiple implementing declarations.</value>
  </data>
  <data name="CSharpErrors_CS0758" xml:space="preserve">
    <value>Both partial method declarations must use a params parameter or neither may use a params parameter</value>
  </data>
  <data name="CSharpErrors_CS0759" xml:space="preserve">
    <value>No defining declaration found for implementing declaration of partial method {0}.</value>
  </data>
  <data name="CSharpErrors_CS0761" xml:space="preserve">
    <value>Partial method declarations of {0} have inconsistent type parameter constraints.</value>
  </data>
  <data name="CSharpErrors_CS0762" xml:space="preserve">
    <value>Cannot create delegate from method {0} because it is a partial method without an implementing declaration</value>
  </data>
  <data name="CSharpErrors_CS0763" xml:space="preserve">
    <value>Both partial method declarations must be static or neither may be static.</value>
  </data>
  <data name="CSharpErrors_CS0764" xml:space="preserve">
    <value>Both partial method declarations must be unsafe or neither may be unsafe</value>
  </data>
  <data name="CSharpErrors_CS0765" xml:space="preserve">
    <value>Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees</value>
  </data>
  <data name="CSharpErrors_CS0766" xml:space="preserve">
    <value>Partial methods must have a void return type.</value>
  </data>
  <data name="CSharpErrors_CS0811" xml:space="preserve">
    <value>The fully qualified name for {0} is too long for debug information. Compile without '/debug' option.</value>
  </data>
  <data name="CSharpErrors_CS0815" xml:space="preserve">
    <value>Cannot assign {0} to an implicitly typed local</value>
  </data>
  <data name="CSharpErrors_CS0818" xml:space="preserve">
    <value>Implicitly typed locals must be initialized</value>
  </data>
  <data name="CSharpErrors_CS0819" xml:space="preserve">
    <value>Implicitly typed locals cannot have multiple declarators.</value>
  </data>
  <data name="CSharpErrors_CS0820" xml:space="preserve">
    <value>Cannot assign array initializer to an implicitly typed local</value>
  </data>
  <data name="CSharpErrors_CS0821" xml:space="preserve">
    <value>Implicitly typed locals cannot be fixed</value>
  </data>
  <data name="CSharpErrors_CS0822" xml:space="preserve">
    <value>Implicitly typed locals cannot be const</value>
  </data>
  <data name="CSharpErrors_CS0825" xml:space="preserve">
    <value>The contextual keyword 'var' may only appear within a local variable declaration.</value>
  </data>
  <data name="CSharpErrors_CS0826" xml:space="preserve">
    <value>No best type found for implicitly typed array.</value>
  </data>
  <data name="CSharpErrors_CS0828" xml:space="preserve">
    <value>Cannot assign {0} to anonymous type property.</value>
  </data>
  <data name="CSharpErrors_CS0831" xml:space="preserve">
    <value>An expression tree may not contain a base access.</value>
  </data>
  <data name="CSharpErrors_CS0832" xml:space="preserve">
    <value>An expression tree may not contain an assignment operator.</value>
  </data>
  <data name="CSharpErrors_CS0833" xml:space="preserve">
    <value>An anonymous type cannot have multiple properties with the same name.</value>
  </data>
  <data name="CSharpErrors_CS0834" xml:space="preserve">
    <value>A lambda expression must have an expression body to be converted to an expression tree.</value>
  </data>
  <data name="CSharpErrors_CS0835" xml:space="preserve">
    <value>Cannot convert lambda to an expression tree whose type argument {0} is not a delegate type.</value>
  </data>
  <data name="CSharpErrors_CS0836" xml:space="preserve">
    <value>Cannot use anonymous type in a constant expression.</value>
  </data>
  <data name="CSharpErrors_CS0837" xml:space="preserve">
    <value>The first operand of an 'is' or 'as' operator may not be a lambda expression or anonymous method.</value>
  </data>
  <data name="CSharpErrors_CS0838" xml:space="preserve">
    <value>An expression tree may not contain a multidimensional array initializer.</value>
  </data>
  <data name="CSharpErrors_CS0839" xml:space="preserve">
    <value>Argument missing.</value>
  </data>
  <data name="CSharpErrors_CS0840" xml:space="preserve">
    <value>{0} must declare a body because it is not marked abstract or extern. Automatically implemented properties must define both get and set accessors.</value>
  </data>
  <data name="CSharpErrors_CS0841" xml:space="preserve">
    <value>Cannot use variable {0} before it is declared.</value>
  </data>
  <data name="CSharpErrors_CS0842" xml:space="preserve">
    <value>Automatically implemented properties cannot be used inside a type marked with StructLayout(LayoutKind.Explicit).</value>
  </data>
  <data name="CSharpErrors_CS0843" xml:space="preserve">
    <value>Backing field for automatically implemented property {0} must be fully assigned before control is returned to the caller. Consider calling the default constructor from a constructor initializer.</value>
  </data>
  <data name="CSharpErrors_CS0844" xml:space="preserve">
    <value>Cannot use local variable {0} before it is declared. The declaration of the local variable hides the field {0}.</value>
  </data>
  <data name="CSharpErrors_CS0845" xml:space="preserve">
    <value>An expression tree lambda may not contain a coalescing operator with a null literal left-hand side.</value>
  </data>
  <data name="CSharpErrors_CS1001" xml:space="preserve">
    <value>Identifier expected</value>
  </data>
  <data name="CSharpErrors_CS1002" xml:space="preserve">
    <value>; expected</value>
  </data>
  <data name="CSharpErrors_CS1003" xml:space="preserve">
    <value>Syntax error, 'char' expected</value>
  </data>
  <data name="CSharpErrors_CS1004" xml:space="preserve">
    <value>Duplicate {0} modifier</value>
  </data>
  <data name="CSharpErrors_CS1007" xml:space="preserve">
    <value>Property accessor already defined</value>
  </data>
  <data name="CSharpErrors_CS1008" xml:space="preserve">
    <value>Type byte, sbyte, short, ushort, int, uint, long, or ulong expected</value>
  </data>
  <data name="CSharpErrors_CS1009" xml:space="preserve">
    <value>Unrecognized escape sequence</value>
  </data>
  <data name="CSharpErrors_CS1010" xml:space="preserve">
    <value>Newline in constant</value>
  </data>
  <data name="CSharpErrors_CS1011" xml:space="preserve">
    <value>Empty character literal</value>
  </data>
  <data name="CSharpErrors_CS1012" xml:space="preserve">
    <value>Too many characters in character literal</value>
  </data>
  <data name="CSharpErrors_CS1013" xml:space="preserve">
    <value>Invalid number</value>
  </data>
  <data name="CSharpErrors_CS1014" xml:space="preserve">
    <value>A get or set accessor expected</value>
  </data>
  <data name="CSharpErrors_CS1015" xml:space="preserve">
    <value>An object, string, or class type expected</value>
  </data>
  <data name="CSharpErrors_CS1016" xml:space="preserve">
    <value>Named attribute argument expected</value>
  </data>
  <data name="CSharpErrors_CS1017" xml:space="preserve">
    <value>Catch clauses cannot follow the general catch clause of a try statement</value>
  </data>
  <data name="CSharpErrors_CS1018" xml:space="preserve">
    <value>Keyword 'this' or 'base' expected</value>
  </data>
  <data name="CSharpErrors_CS1019" xml:space="preserve">
    <value>Overloadable unary operator expected</value>
  </data>
  <data name="CSharpErrors_CS1020" xml:space="preserve">
    <value>Overloadable binary operator expected</value>
  </data>
  <data name="CSharpErrors_CS1021" xml:space="preserve">
    <value>Integral constant is too large</value>
  </data>
  <data name="CSharpErrors_CS1022" xml:space="preserve">
    <value>Type or namespace definition, or end-of-file expected</value>
  </data>
  <data name="CSharpErrors_CS1023" xml:space="preserve">
    <value>Embedded statement cannot be a declaration or labeled statement</value>
  </data>
  <data name="CSharpErrors_CS1024" xml:space="preserve">
    <value>Preprocessor directive expected</value>
  </data>
  <data name="CSharpErrors_CS1025" xml:space="preserve">
    <value>Single-line comment or end-of-line expected</value>
  </data>
  <data name="CSharpErrors_CS1026" xml:space="preserve">
    <value>) expected</value>
  </data>
  <data name="CSharpErrors_CS1027" xml:space="preserve">
    <value>#endif directive expected</value>
  </data>
  <data name="CSharpErrors_CS1028" xml:space="preserve">
    <value>Unexpected preprocessor directive</value>
  </data>
  <data name="CSharpErrors_CS1029" xml:space="preserve">
    <value>#error: {0}</value>
  </data>
  <data name="CSharpErrors_CS1031" xml:space="preserve">
    <value>Type expected</value>
  </data>
  <data name="CSharpErrors_CS1032" xml:space="preserve">
    <value>Cannot define/undefine preprocessor symbols after first token in file</value>
  </data>
  <data name="CSharpErrors_CS1033" xml:space="preserve">
    <value>Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect</value>
  </data>
  <data name="CSharpErrors_CS1034" xml:space="preserve">
    <value>Compiler limit exceeded: Line cannot exceed 'number' characters</value>
  </data>
  <data name="CSharpErrors_CS1035" xml:space="preserve">
    <value>End-of-file found, '*/' expected</value>
  </data>
  <data name="CSharpErrors_CS1036" xml:space="preserve">
    <value>( or . expected</value>
  </data>
  <data name="CSharpErrors_CS1037" xml:space="preserve">
    <value>Overloadable operator expected</value>
  </data>
  <data name="CSharpErrors_CS1038" xml:space="preserve">
    <value>#endregion directive expected</value>
  </data>
  <data name="CSharpErrors_CS1039" xml:space="preserve">
    <value>Unterminated string literal</value>
  </data>
  <data name="CSharpErrors_CS1040" xml:space="preserve">
    <value>Preprocessor directives must appear as the first non-whitespace character on a line</value>
  </data>
  <data name="CSharpErrors_CS1041" xml:space="preserve">
    <value>Identifier expected, 'keyword' is a keyword</value>
  </data>
  <data name="CSharpErrors_CS1043" xml:space="preserve">
    <value>{ or ; expected</value>
  </data>
  <data name="CSharpErrors_CS1044" xml:space="preserve">
    <value>Cannot use more than one type in a for, using, fixed, or declaration statement</value>
  </data>
  <data name="CSharpErrors_CS1055" xml:space="preserve">
    <value>An add or remove accessor expected</value>
  </data>
  <data name="CSharpErrors_CS1056" xml:space="preserve">
    <value>Unexpected character 'character'</value>
  </data>
  <data name="CSharpErrors_CS1057" xml:space="preserve">
    <value>{0}: static classes cannot contain protected members</value>
  </data>
  <data name="CSharpErrors_CS1059" xml:space="preserve">
    <value>The operand of an increment or decrement operator must be a variable, property or indexer.</value>
  </data>
  <data name="CSharpErrors_CS1061" xml:space="preserve">
    <value>{0} does not contain a definition for {1} and no extension method {2} accepting a first argument of type {0} could be found (are you missing a using directive or an assembly reference?).</value>
  </data>
  <data name="CSharpErrors_CS1100" xml:space="preserve">
    <value>Method {0} has a parameter modifier 'this' which is not on the first parameter.</value>
  </data>
  <data name="CSharpErrors_CS1101" xml:space="preserve">
    <value>The parameter modifier 'ref' cannot be used with 'this'.</value>
  </data>
  <data name="CSharpErrors_CS1102" xml:space="preserve">
    <value>The parameter modifier 'out' cannot be used with 'this'.</value>
  </data>
  <data name="CSharpErrors_CS1103" xml:space="preserve">
    <value>The first parameter of an extension method cannot be of type {0}.</value>
  </data>
  <data name="CSharpErrors_CS1104" xml:space="preserve">
    <value>A parameter array cannot be used with 'this' modifier on an extension method.</value>
  </data>
  <data name="CSharpErrors_CS1105" xml:space="preserve">
    <value>Extension methods must be static.</value>
  </data>
  <data name="CSharpErrors_CS1106" xml:space="preserve">
    <value>Extension methods must be defined in a non generic static class.</value>
  </data>
  <data name="CSharpErrors_CS1107" xml:space="preserve">
    <value>A parameter can only have one {0} modifier.</value>
  </data>
  <data name="CSharpErrors_CS1108" xml:space="preserve">
    <value>A parameter cannot have all the specified modifiers; there are too many modifiers on the parameter.</value>
  </data>
  <data name="CSharpErrors_CS1109" xml:space="preserve">
    <value>Extension Methods must be defined on top level static classes, {0} is a nested class.</value>
  </data>
  <data name="CSharpErrors_CS1110" xml:space="preserve">
    <value>Cannot use 'this' modifier on first parameter of method declaration without a reference to System.Core.dll. Add a reference to System.Core.dll or remove 'this' modifier from the method declaration.</value>
  </data>
  <data name="CSharpErrors_CS1112" xml:space="preserve">
    <value>Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.</value>
  </data>
  <data name="CSharpErrors_CS1113" xml:space="preserve">
    <value>Extension methods {0} defined on value type {1} cannot be used to create delegates.</value>
  </data>
  <data name="CSharpErrors_CS1501" xml:space="preserve">
    <value>No overload for method {0} takes {1} arguments</value>
  </data>
  <data name="CSharpErrors_CS1502" xml:space="preserve">
    <value>The best overloaded Add method {0} for the collection initializer has some invalid arguments</value>
  </data>
  <data name="CSharpErrors_CS1503" xml:space="preserve">
    <value>The best overloaded Add method {0} for the collection initializer has some invalid arguments</value>
  </data>
  <data name="CSharpErrors_CS1504" xml:space="preserve">
    <value>Source file {0} could not be opened ({1})</value>
  </data>
  <data name="CSharpErrors_CS1507" xml:space="preserve">
    <value>Cannot link resource file {0} when building a module</value>
  </data>
  <data name="CSharpErrors_CS1508" xml:space="preserve">
    <value>Resource identifier {0} has already been used in this assembly</value>
  </data>
  <data name="CSharpErrors_CS1509" xml:space="preserve">
    <value>Referenced file {0} is not an assembly; use '/addmodule' option instead</value>
  </data>
  <data name="CSharpErrors_CS1510" xml:space="preserve">
    <value>A ref or out argument must be an assignable variable</value>
  </data>
  <data name="CSharpErrors_CS1511" xml:space="preserve">
    <value>Keyword 'base' is not available in a static method</value>
  </data>
  <data name="CSharpErrors_CS1512" xml:space="preserve">
    <value>Keyword 'base' is not available in the current context</value>
  </data>
  <data name="CSharpErrors_CS1513" xml:space="preserve">
    <value>} expected</value>
  </data>
  <data name="CSharpErrors_CS1514" xml:space="preserve">
    <value>{ expected</value>
  </data>
  <data name="CSharpErrors_CS1515" xml:space="preserve">
    <value>'in' expected</value>
  </data>
  <data name="CSharpErrors_CS1517" xml:space="preserve">
    <value>Invalid preprocessor expression</value>
  </data>
  <data name="CSharpErrors_CS1518" xml:space="preserve">
    <value>Expected class, delegate, enum, interface, or struct</value>
  </data>
  <data name="CSharpErrors_CS1519" xml:space="preserve">
    <value>Invalid token {0} in class, struct, or interface member declaration</value>
  </data>
  <data name="CSharpErrors_CS1520" xml:space="preserve">
    <value>Method must have a return type</value>
  </data>
  <data name="CSharpErrors_CS1521" xml:space="preserve">
    <value>Invalid base type</value>
  </data>
  <data name="CSharpErrors_CS1524" xml:space="preserve">
    <value>Expected catch or finally</value>
  </data>
  <data name="CSharpErrors_CS1525" xml:space="preserve">
    <value>Invalid expression term {0}</value>
  </data>
  <data name="CSharpErrors_CS1526" xml:space="preserve">
    <value>A new expression requires (), [], or {} after type</value>
  </data>
  <data name="CSharpErrors_CS1527" xml:space="preserve">
    <value>Elements defined in a namespace cannot be explicitly declared as private, protected, or protected internal</value>
  </data>
  <data name="CSharpErrors_CS1528" xml:space="preserve">
    <value>Expected ; or = (cannot specify constructor arguments in declaration)</value>
  </data>
  <data name="CSharpErrors_CS1529" xml:space="preserve">
    <value>A using clause must precede all other elements defined in the namespace except extern alias declarations</value>
  </data>
  <data name="CSharpErrors_CS1530" xml:space="preserve">
    <value>Keyword 'new' is not allowed on elements defined in a namespace</value>
  </data>
  <data name="CSharpErrors_CS1534" xml:space="preserve">
    <value>Overloaded binary operator {0} takes two parameters</value>
  </data>
  <data name="CSharpErrors_CS1535" xml:space="preserve">
    <value>Overloaded unary operator {0} takes one parameter</value>
  </data>
  <data name="CSharpErrors_CS1536" xml:space="preserve">
    <value>Invalid parameter type void</value>
  </data>
  <data name="CSharpErrors_CS1537" xml:space="preserve">
    <value>The using alias {0} appeared previously in this namespace</value>
  </data>
  <data name="CSharpErrors_CS1540" xml:space="preserve">
    <value>Cannot access protected member {0} via a qualifier of type {1}; the qualifier must be of type {2} (or derived from it)</value>
  </data>
  <data name="CSharpErrors_CS1541" xml:space="preserve">
    <value>Invalid reference option: {0} — cannot reference directories</value>
  </data>
  <data name="CSharpErrors_CS1542" xml:space="preserve">
    <value>{0} cannot be added to this assembly because it already is an assembly; use '/R' option instead</value>
  </data>
  <data name="CSharpErrors_CS1545" xml:space="preserve">
    <value>Property, indexer, or event {0} is not supported by the language; try directly calling accessor methods {1} or {2}</value>
  </data>
  <data name="CSharpErrors_CS1546" xml:space="preserve">
    <value>Property, indexer, or event {0} is not supported by the language; try directly calling accessor method {1}</value>
  </data>
  <data name="CSharpErrors_CS1547" xml:space="preserve">
    <value>Keyword 'void' cannot be used in this context</value>
  </data>
  <data name="CSharpErrors_CS1548" xml:space="preserve">
    <value>Cryptographic failure while signing assembly {0} — {1}</value>
  </data>
  <data name="CSharpErrors_CS1549" xml:space="preserve">
    <value>Appropriate cryptographic service not found</value>
  </data>
  <data name="CSharpErrors_CS1551" xml:space="preserve">
    <value>Indexers must have at least one parameter</value>
  </data>
  <data name="CSharpErrors_CS1552" xml:space="preserve">
    <value>Array type specifier, [], must appear before parameter name</value>
  </data>
  <data name="CSharpErrors_CS1553" xml:space="preserve">
    <value>Declaration is not valid; use '{0} operator {1} (...' instead</value>
  </data>
  <data name="CSharpErrors_CS1554" xml:space="preserve">
    <value>Declaration is not valid; use '{0} operator {1} (...' instead</value>
  </data>
  <data name="CSharpErrors_CS1555" xml:space="preserve">
    <value>Could not find {0} specified for Main method</value>
  </data>
  <data name="CSharpErrors_CS1556" xml:space="preserve">
    <value>{0} specified for Main method must be a valid class or struct</value>
  </data>
  <data name="CSharpErrors_CS1557" xml:space="preserve">
    <value>Cannot use {0} for Main method because it is in a different output file</value>
  </data>
  <data name="CSharpErrors_CS1558" xml:space="preserve">
    <value>{0} does not have a suitable static Main method</value>
  </data>
  <data name="CSharpErrors_CS1559" xml:space="preserve">
    <value>Cannot use {0} for Main method because it is imported</value>
  </data>
  <data name="CSharpErrors_CS1560" xml:space="preserve">
    <value>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename</value>
  </data>
  <data name="CSharpErrors_CS1561" xml:space="preserve">
    <value>Output filename is too long or invalid</value>
  </data>
  <data name="CSharpErrors_CS1562" xml:space="preserve">
    <value>Outputs without source must have the /out option specified</value>
  </data>
  <data name="CSharpErrors_CS1563" xml:space="preserve">
    <value>Output {0} does not have any source files</value>
  </data>
  <data name="CSharpErrors_CS1564" xml:space="preserve">
    <value>Conflicting options specified: Win32 resource file; Win32 manifest.</value>
  </data>
  <data name="CSharpErrors_CS1565" xml:space="preserve">
    <value>Conflicting options specified: Win32 resource file; Win32 icon</value>
  </data>
  <data name="CSharpErrors_CS1566" xml:space="preserve">
    <value>Error reading resource file {0} — {1}</value>
  </data>
  <data name="CSharpErrors_CS1567" xml:space="preserve">
    <value>Error generating Win32 resource: {0}</value>
  </data>
  <data name="CSharpErrors_CS1569" xml:space="preserve">
    <value>Error generating XML documentation file {0} ({1})</value>
  </data>
  <data name="CSharpErrors_CS1575" xml:space="preserve">
    <value>A stackalloc expression requires [] after type</value>
  </data>
  <data name="CSharpErrors_CS1576" xml:space="preserve">
    <value>The line number specified for #line directive is missing or invalid</value>
  </data>
  <data name="CSharpErrors_CS1577" xml:space="preserve">
    <value>Assembly generation failed — reason</value>
  </data>
  <data name="CSharpErrors_CS1578" xml:space="preserve">
    <value>Filename, single-line comment or end-of-line expected</value>
  </data>
  <data name="CSharpErrors_CS1579" xml:space="preserve">
    <value>foreach statement cannot operate on variables of type {0} because {1} does not contain a public definition for {2}</value>
  </data>
  <data name="CSharpErrors_CS1583" xml:space="preserve">
    <value>{0} is not a valid Win32 resource file</value>
  </data>
  <data name="CSharpErrors_CS1585" xml:space="preserve">
    <value>Member modifier {0} must precede the member type and name</value>
  </data>
  <data name="CSharpErrors_CS1586" xml:space="preserve">
    <value>Array creation must have array size or array initializer</value>
  </data>
  <data name="CSharpErrors_CS1588" xml:space="preserve">
    <value>Cannot determine common language runtime directory -- {0}</value>
  </data>
  <data name="CSharpErrors_CS1593" xml:space="preserve">
    <value>Delegate {0} does not take {1} arguments</value>
  </data>
  <data name="CSharpErrors_CS1594" xml:space="preserve">
    <value>Delegate {0} has some invalid arguments</value>
  </data>
  <data name="CSharpErrors_CS1597" xml:space="preserve">
    <value>Semicolon after method or accessor block is not valid</value>
  </data>
  <data name="CSharpErrors_CS1599" xml:space="preserve">
    <value>Method or delegate cannot return type {0}</value>
  </data>
  <data name="CSharpErrors_CS1600" xml:space="preserve">
    <value>Compilation cancelled by user</value>
  </data>
  <data name="CSharpErrors_CS1601" xml:space="preserve">
    <value>Method or delegate parameter cannot be of type {0}</value>
  </data>
  <data name="CSharpErrors_CS1604" xml:space="preserve">
    <value>Cannot assign to {0} because it is read-only</value>
  </data>
  <data name="CSharpErrors_CS1605" xml:space="preserve">
    <value>Cannot pass {0} as a ref or out argument because it is read-only</value>
  </data>
  <data name="CSharpErrors_CS1606" xml:space="preserve">
    <value>Assembly signing failed; output may not be signed -- {0}</value>
  </data>
  <data name="CSharpErrors_CS1608" xml:space="preserve">
    <value>The Required attribute is not permitted on C# types</value>
  </data>
  <data name="CSharpErrors_CS1609" xml:space="preserve">
    <value>Modifiers cannot be placed on event accessor declarations</value>
  </data>
  <data name="CSharpErrors_CS1611" xml:space="preserve">
    <value>The params parameter cannot be declared as ref or out</value>
  </data>
  <data name="CSharpErrors_CS1612" xml:space="preserve">
    <value>Cannot modify the return value of {0} because it is not a variable</value>
  </data>
  <data name="CSharpErrors_CS1613" xml:space="preserve">
    <value>The managed coclass wrapper class {0} for interface {1} cannot be found (are you missing an assembly reference?)</value>
  </data>
  <data name="CSharpErrors_CS1614" xml:space="preserve">
    <value>{0} is ambiguous; between {1} and {2}. use either '@{0}' or '{0}Attribute'</value>
  </data>
  <data name="CSharpErrors_CS1615" xml:space="preserve">
    <value>Argument {0} should not be passed with the {1} keyword</value>
  </data>
  <data name="CSharpErrors_CS1617" xml:space="preserve">
    <value>Invalid option {0} for /langversion; must be ISO-1, ISO-2 or Default</value>
  </data>
  <data name="CSharpErrors_CS1618" xml:space="preserve">
    <value>Cannot create delegate with {0} because it has a Conditional attribute</value>
  </data>
  <data name="CSharpErrors_CS1619" xml:space="preserve">
    <value>Cannot create temporary file {0} -- {1}</value>
  </data>
  <data name="CSharpErrors_CS1620" xml:space="preserve">
    <value>Argument {0} must be passed with the {1} keyword</value>
  </data>
  <data name="CSharpErrors_CS1621" xml:space="preserve">
    <value>The yield statement cannot be used inside an anonymous method or lambda expression</value>
  </data>
  <data name="CSharpErrors_CS1622" xml:space="preserve">
    <value>Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.</value>
  </data>
  <data name="CSharpErrors_CS1623" xml:space="preserve">
    <value>Iterators cannot have ref or out parameters</value>
  </data>
  <data name="CSharpErrors_CS1624" xml:space="preserve">
    <value>The body of {0} cannot be an iterator block because {1} is not an iterator interface type</value>
  </data>
  <data name="CSharpErrors_CS1625" xml:space="preserve">
    <value>Cannot yield in the body of a finally clause</value>
  </data>
  <data name="CSharpErrors_CS1626" xml:space="preserve">
    <value>Cannot yield a value in the body of a try block with a catch clause</value>
  </data>
  <data name="CSharpErrors_CS1627" xml:space="preserve">
    <value>Expression expected after yield return</value>
  </data>
  <data name="CSharpErrors_CS1628" xml:space="preserve">
    <value>Cannot use ref or out parameter {0} inside an anonymous method, lambda expression, or query expression</value>
  </data>
  <data name="CSharpErrors_CS1629" xml:space="preserve">
    <value>Unsafe code may not appear in iterators</value>
  </data>
  <data name="CSharpErrors_CS1630" xml:space="preserve">
    <value>Invalid option {0} for /errorreport; must be prompt, send, queue, or none</value>
  </data>
  <data name="CSharpErrors_CS1631" xml:space="preserve">
    <value>Cannot yield a value in the body of a catch clause</value>
  </data>
  <data name="CSharpErrors_CS1632" xml:space="preserve">
    <value>Control cannot leave the body of an anonymous method or lambda expression</value>
  </data>
  <data name="CSharpErrors_CS1637" xml:space="preserve">
    <value>Iterators cannot have unsafe parameters or yield types</value>
  </data>
  <data name="CSharpErrors_CS1638" xml:space="preserve">
    <value>{0} is a reserved identifier and cannot be used when ISO language version mode is used</value>
  </data>
  <data name="CSharpErrors_CS1639" xml:space="preserve">
    <value>The managed coclass wrapper class signature {0} for interface {1} is not a valid class name signature</value>
  </data>
  <data name="CSharpErrors_CS1640" xml:space="preserve">
    <value>foreach statement cannot operate on variables of type {0} because it implements multiple instantiations of {1}, try casting to a specific interface instantiation</value>
  </data>
  <data name="CSharpErrors_CS1641" xml:space="preserve">
    <value>A fixed size buffer field must have the array size specifier after the field name</value>
  </data>
  <data name="CSharpErrors_CS1642" xml:space="preserve">
    <value>Fixed size buffer fields may only be members of structs.</value>
  </data>
  <data name="CSharpErrors_CS1643" xml:space="preserve">
    <value>Not all code paths return a value in method of type {0}</value>
  </data>
  <data name="CSharpErrors_CS1644" xml:space="preserve">
    <value>Feature {0} is not part of the standardized ISO C# language specification, and may not be accepted by other compilers</value>
  </data>
  <data name="CSharpErrors_CS1646" xml:space="preserve">
    <value>Keyword, identifier, or string expected after verbatim specifier: </value>
  </data>
  <data name="CSharpErrors_CS1647" xml:space="preserve">
    <value>An expression is too long or complex to compile near {0}</value>
  </data>
  <data name="CSharpErrors_CS1648" xml:space="preserve">
    <value>Members of readonly field {0} cannot be modified (except in a constructor or a variable initializer)</value>
  </data>
  <data name="CSharpErrors_CS1649" xml:space="preserve">
    <value>Members of readonly field {0} cannot be passed ref or out (except in a constructor)</value>
  </data>
  <data name="CSharpErrors_CS1650" xml:space="preserve">
    <value>Fields of static readonly field {0} cannot be assigned to (except in a static constructor or a variable initializer)</value>
  </data>
  <data name="CSharpErrors_CS1651" xml:space="preserve">
    <value>Fields of static readonly field {0} cannot be passed ref or out (except in a static constructor)</value>
  </data>
  <data name="CSharpErrors_CS1654" xml:space="preserve">
    <value>Cannot modify members of {0} because it is a {1}</value>
  </data>
  <data name="CSharpErrors_CS1655" xml:space="preserve">
    <value>Cannot pass fields of {0} as a ref or out argument because it is a {1}</value>
  </data>
  <data name="CSharpErrors_CS1656" xml:space="preserve">
    <value>Cannot assign to {0} because it is a {1}</value>
  </data>
  <data name="CSharpErrors_CS1657" xml:space="preserve">
    <value>Cannot pass {0} as a ref or out argument because {1}</value>
  </data>
  <data name="CSharpErrors_CS1660" xml:space="preserve">
    <value>Cannot convert anonymous method block to type {0} because it is not a delegate type</value>
  </data>
  <data name="CSharpErrors_CS1661" xml:space="preserve">
    <value>Cannot convert anonymous method block to delegate type {0} because the specified block's parameter types do not match the delegate parameter types</value>
  </data>
  <data name="CSharpErrors_CS1662" xml:space="preserve">
    <value>Cannot convert anonymous method block to delegate type {0} because some of the return types in the block are not implicitly convertible to the delegate return type</value>
  </data>
  <data name="CSharpErrors_CS1663" xml:space="preserve">
    <value>Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double</value>
  </data>
  <data name="CSharpErrors_CS1664" xml:space="preserve">
    <value>Fixed size buffer of length {0} and type {1} is too big</value>
  </data>
  <data name="CSharpErrors_CS1665" xml:space="preserve">
    <value>Fixed size buffers must have a length greater than zero</value>
  </data>
  <data name="CSharpErrors_CS1666" xml:space="preserve">
    <value>You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.</value>
  </data>
  <data name="CSharpErrors_CS1667" xml:space="preserve">
    <value>Attribute {0} is not valid on property or event accessors. It is valid on {1} declarations only.</value>
  </data>
  <data name="CSharpErrors_CS1670" xml:space="preserve">
    <value>params is not valid in this context</value>
  </data>
  <data name="CSharpErrors_CS1671" xml:space="preserve">
    <value>A namespace declaration cannot have modifiers or attributes</value>
  </data>
  <data name="CSharpErrors_CS1672" xml:space="preserve">
    <value>Invalid option {0} for /platform; must be anycpu, x86, Itanium or x64</value>
  </data>
  <data name="CSharpErrors_CS1673" xml:space="preserve">
    <value>Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression or query expression and using the local instead.</value>
  </data>
  <data name="CSharpErrors_CS1674" xml:space="preserve">
    <value>{0}: type used in a using statement must be implicitly convertible to 'System.IDisposable'</value>
  </data>
  <data name="CSharpErrors_CS1675" xml:space="preserve">
    <value>Enums cannot have type parameters</value>
  </data>
  <data name="CSharpErrors_CS1676" xml:space="preserve">
    <value>Parameter {0} must be declared with the {1} keyword</value>
  </data>
  <data name="CSharpErrors_CS1677" xml:space="preserve">
    <value>Parameter {0} should not be declared with the {1} keyword</value>
  </data>
  <data name="CSharpErrors_CS1678" xml:space="preserve">
    <value>Parameter {0} is declared as type {1} but should be {2}</value>
  </data>
  <data name="CSharpErrors_CS1679" xml:space="preserve">
    <value>Invalid extern alias for {0}; {1} is not a valid identifier</value>
  </data>
  <data name="CSharpErrors_CS1680" xml:space="preserve">
    <value>Invalid reference alias option: 'alias=' -- missing filename.</value>
  </data>
  <data name="CSharpErrors_CS1681" xml:space="preserve">
    <value>You cannot redefine the global extern alias</value>
  </data>
  <data name="CSharpErrors_CS1686" xml:space="preserve">
    <value>Local {0} or its members cannot have their address taken and be used inside an anonymous method or lambda expression</value>
  </data>
  <data name="CSharpErrors_CS1688" xml:space="preserve">
    <value>Cannot convert anonymous method block without a parameter list to delegate type {0} because it has one or more out parameters</value>
  </data>
  <data name="CSharpErrors_CS1689" xml:space="preserve">
    <value>Attribute {0} is only valid on methods or attribute classes</value>
  </data>
  <data name="CSharpErrors_CS1703" xml:space="preserve">
    <value>An assembly with the same simple name {0} has already been imported. Try removing one of the references or sign them to enable side-by-side.</value>
  </data>
  <data name="CSharpErrors_CS1704" xml:space="preserve">
    <value>An assembly with the same simple name {0} has already been imported. Try removing one of the references or sign them to enable side-by-side.</value>
  </data>
  <data name="CSharpErrors_CS1705" xml:space="preserve">
    <value>Assembly {0} uses {1} which has a higher version than referenced assembly {2}</value>
  </data>
  <data name="CSharpErrors_CS1706" xml:space="preserve">
    <value>Expression cannot contain anonymous methods or lambda expressions</value>
  </data>
  <data name="CSharpErrors_CS1708" xml:space="preserve">
    <value>Fixed size buffers can only be accessed through locals or fields</value>
  </data>
  <data name="CSharpErrors_CS1713" xml:space="preserve">
    <value>Unexpected error building metadata name for type {0} — {1}</value>
  </data>
  <data name="CSharpErrors_CS1714" xml:space="preserve">
    <value>The base class or interface of {0} could not be resolved or is invalid</value>
  </data>
  <data name="CSharpErrors_CS1715" xml:space="preserve">
    <value>{0}: type must be {1} to match overridden member {2}</value>
  </data>
  <data name="CSharpErrors_CS1716" xml:space="preserve">
    <value>Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.</value>
  </data>
  <data name="CSharpErrors_CS1719" xml:space="preserve">
    <value>Error reading Win32 resource file {0} -- {1}</value>
  </data>
  <data name="CSharpErrors_CS1721" xml:space="preserve">
    <value>Class {0} cannot have multiple base classes: {1} and {2}</value>
  </data>
  <data name="CSharpErrors_CS1722" xml:space="preserve">
    <value>Base class {0} must come before any interfaces</value>
  </data>
  <data name="CSharpErrors_CS1724" xml:space="preserve">
    <value>Value specified for the argument to 'System.Runtime.InteropServices.DefaultCharSetAttribute' is not valid</value>
  </data>
  <data name="CSharpErrors_CS1725" xml:space="preserve">
    <value>Friend assembly reference {0} is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.</value>
  </data>
  <data name="CSharpErrors_CS1726" xml:space="preserve">
    <value>Friend assembly reference {0} is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.</value>
  </data>
  <data name="CSharpErrors_CS1727" xml:space="preserve">
    <value>Cannot send error report automatically without authorization. Please visit {0} to authorize sending error report.</value>
  </data>
  <data name="CSharpErrors_CS1728" xml:space="preserve">
    <value>Cannot bind delegate to {0} because it is a member of {1}</value>
  </data>
  <data name="CSharpErrors_CS1729" xml:space="preserve">
    <value>{0} does not contain a constructor that takes {1} arguments.</value>
  </data>
  <data name="CSharpErrors_CS1730" xml:space="preserve">
    <value>Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations.</value>
  </data>
  <data name="CSharpErrors_CS1731" xml:space="preserve">
    <value>Cannot convert {0} to delegate because some of the return types in the block are not implicitly convertible to the delegate return type.</value>
  </data>
  <data name="CSharpErrors_CS1732" xml:space="preserve">
    <value>Expected parameter.</value>
  </data>
  <data name="CSharpErrors_CS1733" xml:space="preserve">
    <value>Expected expression.</value>
  </data>
  <data name="CSharpErrors_CS1900" xml:space="preserve">
    <value>Warning level must be in the range 0-4</value>
  </data>
  <data name="CSharpErrors_CS1902" xml:space="preserve">
    <value>Invalid option {0} for /debug; must be full or pdbonly</value>
  </data>
  <data name="CSharpErrors_CS1906" xml:space="preserve">
    <value>Invalid option {0}; Resource visibility must be either 'public' or 'private'</value>
  </data>
  <data name="CSharpErrors_CS1908" xml:space="preserve">
    <value>The type of the argument to the DefaultValue attribute must match the parameter type</value>
  </data>
  <data name="CSharpErrors_CS1909" xml:space="preserve">
    <value>The DefaultValue attribute is not applicable on parameters of type {0}</value>
  </data>
  <data name="CSharpErrors_CS1910" xml:space="preserve">
    <value>Argument of type {0} is not applicable for the DefaultValue attribute</value>
  </data>
  <data name="CSharpErrors_CS1912" xml:space="preserve">
    <value>Duplicate initialization of member {0}</value>
  </data>
  <data name="CSharpErrors_CS1913" xml:space="preserve">
    <value>Member {0} cannot be initialized. It is not a field or property.</value>
  </data>
  <data name="CSharpErrors_CS1914" xml:space="preserve">
    <value>Static field {0} cannot be assigned in an object initializer</value>
  </data>
  <data name="CSharpErrors_CS1917" xml:space="preserve">
    <value>Members of read-only field {0} of type {1} cannot be assigned with an object initializer because it is of a value type.</value>
  </data>
  <data name="CSharpErrors_CS1918" xml:space="preserve">
    <value>Members of property {0} of type {1} cannot be assigned with an object initializer because it is of a value type.</value>
  </data>
  <data name="CSharpErrors_CS1919" xml:space="preserve">
    <value>Unsafe type {0} cannot be used in object creation.</value>
  </data>
  <data name="CSharpErrors_CS1920" xml:space="preserve">
    <value>Element initializer cannot be empty.</value>
  </data>
  <data name="CSharpErrors_CS1921" xml:space="preserve">
    <value>The best overloaded method match for {0} has wrong signature for the initializer element. The initializable Add must be an accessible instance method.</value>
  </data>
  <data name="CSharpErrors_CS1922" xml:space="preserve">
    <value>Collection initializer requires its type {0} to implement System.Collections.IEnumerable.</value>
  </data>
  <data name="CSharpErrors_CS1925" xml:space="preserve">
    <value>Cannot initialize object of type {0} with a collection initializer.</value>
  </data>
  <data name="CSharpErrors_CS1926" xml:space="preserve">
    <value>Error reading Win32 manifest file {0} -- {1}.</value>
  </data>
  <data name="CSharpErrors_CS1928" xml:space="preserve">
    <value>{0} does not contain a definition for {1} and the best extension method overload {2} has some invalid arguments.</value>
  </data>
  <data name="CSharpErrors_CS1929" xml:space="preserve">
    <value>Instance argument: cannot convert from {0} to {1}.</value>
  </data>
  <data name="CSharpErrors_CS1930" xml:space="preserve">
    <value>The range variable {0} has already been declared</value>
  </data>
  <data name="CSharpErrors_CS1931" xml:space="preserve">
    <value>The range variable {0} conflicts with a previous declaration of {1}.</value>
  </data>
  <data name="CSharpErrors_CS1932" xml:space="preserve">
    <value>Cannot assign {0} to a range variable.</value>
  </data>
  <data name="CSharpErrors_CS1933" xml:space="preserve">
    <value>Expression cannot contain query expressions</value>
  </data>
  <data name="CSharpErrors_CS1934" xml:space="preserve">
    <value>Could not find an implementation of the query pattern for source type {0}. {1} not found. Consider explicitly specifying the type of the range variable {2}.</value>
  </data>
  <data name="CSharpErrors_CS1935" xml:space="preserve">
    <value>Could not find an implementation of the query pattern for source type {0}. {1} not found. Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?</value>
  </data>
  <data name="CSharpErrors_CS1936" xml:space="preserve">
    <value>Could not find an implementation of the query pattern for source type {0}. {1} not found.</value>
  </data>
  <data name="CSharpErrors_CS1937" xml:space="preserve">
    <value>The name {0} is not in scope on the left side of 'equals'. Consider swapping the expressions on either side of 'equals'.</value>
  </data>
  <data name="CSharpErrors_CS1938" xml:space="preserve">
    <value>The name {0} is not in scope on the right side of 'equals'. Consider swapping the expressions on either side of 'equals'.</value>
  </data>
  <data name="CSharpErrors_CS1939" xml:space="preserve">
    <value>Cannot pass the range variable {0} as an out or ref parameter.</value>
  </data>
  <data name="CSharpErrors_CS1940" xml:space="preserve">
    <value>Multiple implementations of the query pattern were found for source type {0}. Ambiguous call to {1}.</value>
  </data>
  <data name="CSharpErrors_CS1941" xml:space="preserve">
    <value>The type of one of the expressions in the {0} clause is incorrect. Type inference failed in the call to {1}.</value>
  </data>
  <data name="CSharpErrors_CS1942" xml:space="preserve">
    <value>The type of the expression in the {0} clause is incorrect. Type inference failed in the call to {1}.</value>
  </data>
  <data name="CSharpErrors_CS1943" xml:space="preserve">
    <value>An expression of type {0} is not allowed in a subsequent from clause in a query expression with source type {1}. Type inference failed in the call to {2}.</value>
  </data>
  <data name="CSharpErrors_CS1944" xml:space="preserve">
    <value>An expression tree may not contain an unsafe pointer operation</value>
  </data>
  <data name="CSharpErrors_CS1945" xml:space="preserve">
    <value>An expression tree may not contain an anonymous method expression.</value>
  </data>
  <data name="CSharpErrors_CS1946" xml:space="preserve">
    <value>An anonymous method expression cannot be converted to an expression tree.</value>
  </data>
  <data name="CSharpErrors_CS1947" xml:space="preserve">
    <value>Range variable {0} cannot be assigned to -- it is read only.</value>
  </data>
  <data name="CSharpErrors_CS1948" xml:space="preserve">
    <value>The range variable {0} cannot have the same name as a method type parameter</value>
  </data>
  <data name="CSharpErrors_CS1949" xml:space="preserve">
    <value>The contextual keyword 'var' cannot be used in a range variable declaration.</value>
  </data>
  <data name="CSharpErrors_CS1950" xml:space="preserve">
    <value>The best overloaded Add method {0} for the collection initializer has some invalid arguments.</value>
  </data>
  <data name="CSharpErrors_CS1951" xml:space="preserve">
    <value>An expression tree lambda may not contain an out or ref parameter.</value>
  </data>
  <data name="CSharpErrors_CS1952" xml:space="preserve">
    <value>An expression tree lambda may not contain a method with variable arguments</value>
  </data>
  <data name="CSharpErrors_CS1953" xml:space="preserve">
    <value>An expression tree lambda may not contain a method group.</value>
  </data>
  <data name="CSharpErrors_CS1954" xml:space="preserve">
    <value>The best overloaded method match {0} for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.</value>
  </data>
  <data name="CSharpErrors_CS1955" xml:space="preserve">
    <value>Non-invocable member {0} cannot be used like a method.</value>
  </data>
  <data name="CSharpErrors_CS1958" xml:space="preserve">
    <value>Object and collection initializer expressions may not be applied to a delegate creation expression,</value>
  </data>
  <data name="CSharpErrors_CS1959" xml:space="preserve">
    <value>{0} is of type {1}. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.</value>
  </data>
  <data name="CSharpErrors_CS2001" xml:space="preserve">
    <value>Source file {0} could not be found</value>
  </data>
  <data name="CSharpErrors_CS2003" xml:space="preserve">
    <value>Response file {0} included multiple times</value>
  </data>
  <data name="CSharpErrors_CS2005" xml:space="preserve">
    <value>Missing file specification for {0} option</value>
  </data>
  <data name="CSharpErrors_CS2006" xml:space="preserve">
    <value>Command-line syntax error: Missing {0} for {1} option</value>
  </data>
  <data name="CSharpErrors_CS2007" xml:space="preserve">
    <value>Unrecognized command-line option: {0}</value>
  </data>
  <data name="CSharpErrors_CS2008" xml:space="preserve">
    <value>No inputs specified</value>
  </data>
  <data name="CSharpErrors_CS2011" xml:space="preserve">
    <value>Unable to open response file {0}</value>
  </data>
  <data name="CSharpErrors_CS2012" xml:space="preserve">
    <value>Cannot open {0} for writing</value>
  </data>
  <data name="CSharpErrors_CS2013" xml:space="preserve">
    <value>Invalid image base number {0}</value>
  </data>
  <data name="CSharpErrors_CS2015" xml:space="preserve">
    <value>{0} is a binary file instead of a text file</value>
  </data>
  <data name="CSharpErrors_CS2016" xml:space="preserve">
    <value>Code page {0} is invalid or not installed</value>
  </data>
  <data name="CSharpErrors_CS2017" xml:space="preserve">
    <value>Cannot specify /main if building a module or library</value>
  </data>
  <data name="CSharpErrors_CS2018" xml:space="preserve">
    <value>Unable to find messages file 'cscmsgs.dll'</value>
  </data>
  <data name="CSharpErrors_CS2019" xml:space="preserve">
    <value>Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'</value>
  </data>
  <data name="CSharpErrors_CS2020" xml:space="preserve">
    <value>Only the first set of input files can build a target other than 'module'</value>
  </data>
  <data name="CSharpErrors_CS2021" xml:space="preserve">
    <value>File name {0} is too long or invalid</value>
  </data>
  <data name="CSharpErrors_CS2022" xml:space="preserve">
    <value>Options '/out' and '/target' must appear before source file names</value>
  </data>
  <data name="CSharpErrors_CS2024" xml:space="preserve">
    <value>Invalid file section alignment number '#'</value>
  </data>
  <data name="CSharpErrors_CS2032" xml:space="preserve">
    <value>Character {0} is not allowed on the command-line or in response files</value>
  </data>
  <data name="CSharpErrors_CS2033" xml:space="preserve">
    <value>Cannot create short filename {0} when a long filename with the same short filename already exists</value>
  </data>
  <data name="CSharpErrors_CS2034" xml:space="preserve">
    <value>A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.</value>
  </data>
  <data name="CSharpErrors_CS2035" xml:space="preserve">
    <value>&gt;Command-line syntax error: Missing ':&amp;lt;number&amp;gt;' for {0} option</value>
  </data>
  <data name="CSharpErrors_CS2036" xml:space="preserve">
    <value>The /pdb option requires that the /debug option also be used.</value>
  </data>
  <data name="CSharpErrors_CS5001" xml:space="preserve">
    <value>Program {0} does not contain a static 'Main' method suitable for an entry point</value>
  </data>
  <data name="CSharpWarnings_CS0028" xml:space="preserve">
    <value>'{0}' has the wrong signature to be an entry point </value>
  </data>
  <data name="CSharpWarnings_CS0067" xml:space="preserve">
    <value>The event '{0}' is never used.</value>
  </data>
  <data name="CSharpWarnings_CS0078" xml:space="preserve">
    <value>The 'l' suffix is easily confused with the digit '1': use 'L' for clarity.</value>
  </data>
  <data name="CSharpWarnings_CS0105" xml:space="preserve">
    <value>The using directive for '{0}' appeared previously in this namespace.</value>
  </data>
  <data name="CSharpWarnings_CS0108" xml:space="preserve">
    <value>'{0}' hides inherited member '{1}'. Use the new keyword if hiding was intended.</value>
  </data>
  <data name="CSharpWarnings_CS0109" xml:space="preserve">
    <value>The member '{0}' does not hide an inherited member. The new keyword is not required.</value>
  </data>
  <data name="CSharpWarnings_CS0114" xml:space="preserve">
    <value>'{0}' hides inherited member '{1}'. To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.</value>
  </data>
  <data name="CSharpWarnings_CS0162" xml:space="preserve">
    <value>Unreachable code detected</value>
  </data>
  <data name="CSharpWarnings_CS0164" xml:space="preserve">
    <value>This label has not been referenced</value>
  </data>
  <data name="CSharpWarnings_CS0168" xml:space="preserve">
    <value>The variable '{0}' is assigned but its value is never used</value>
  </data>
  <data name="CSharpWarnings_CS0169" xml:space="preserve">
    <value>The private field '{0}' is never used</value>
  </data>
  <data name="CSharpWarnings_CS0183" xml:space="preserve">
    <value>The given expression is always of the provided ({0}) type</value>
  </data>
  <data name="CSharpWarnings_CS0184" xml:space="preserve">
    <value>The given expression is never of the provided ({0}) type</value>
  </data>
  <data name="CSharpWarnings_CS0197" xml:space="preserve">
    <value>Passing '{0}' as ref or out or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class</value>
  </data>
  <data name="CSharpWarnings_CS0219" xml:space="preserve">
    <value>The variable '{0}' is assigned but its value is never used</value>
  </data>
  <data name="CSharpWarnings_CS0251" xml:space="preserve">
    <value>Indexing an array with a negative index (array indices always start at zero)</value>
  </data>
  <data name="CSharpWarnings_CS0252" xml:space="preserve">
    <value>Possible unintended reference comparison; to get a value comparison, cast the left hand side to type '{0}'.</value>
  </data>
  <data name="CSharpWarnings_CS0253" xml:space="preserve">
    <value>Possible unintended reference comparison; to get a value comparison, cast the right hand side to type '{0}'.</value>
  </data>
  <data name="CSharpWarnings_CS0278" xml:space="preserve">
    <value>'{0}' does not implement the '{1}' pattern. '{2}' is ambiguous with '{2}'.</value>
  </data>
  <data name="CSharpWarnings_CS0279" xml:space="preserve">
    <value>'{0}' does not implement the '{1}' pattern. '{2}' is either static or not public.</value>
  </data>
  <data name="CSharpWarnings_CS0280" xml:space="preserve">
    <value>'{0}' does not implement the '{1}' pattern. '{2}' has the wrong signature.</value>
  </data>
  <data name="CSharpWarnings_CS0282" xml:space="preserve">
    <value>There is no defined ordering between fields in multiple declarations of partial class or struct '{0}'. To specify an ordering, all instance fields must be in the same declaration.</value>
  </data>
  <data name="CSharpWarnings_CS0402" xml:space="preserve">
    <value>'{0}' : an entry point cannot be generic or in a generic type</value>
  </data>
  <data name="CSharpWarnings_CS0414" xml:space="preserve">
    <value>The private field '{0}' is assigned but its value is never used</value>
  </data>
  <data name="CSharpWarnings_CS0419" xml:space="preserve">
    <value>Ambiguous reference in cref attribute: '{0}'. Assuming '{1}', but could have also matched other overloads including '{2}'.</value>
  </data>
  <data name="CSharpWarnings_CS0420" xml:space="preserve">
    <value>'{0}': a reference to a volatile field will not be treated as volatile</value>
  </data>
  <data name="CSharpWarnings_CS0422" xml:space="preserve">
    <value>The /incremental option is no longer supported</value>
  </data>
  <data name="CSharpWarnings_CS0429" xml:space="preserve">
    <value>Unreachable expression code detected </value>
  </data>
  <data name="CSharpWarnings_CS0435" xml:space="preserve">
    <value>The namespace '{0}' in '{1}' conflicts with the imported type '{2}' in '{3}'. Using the namespace defined in '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0436" xml:space="preserve">
    <value>The type '{0}' in '{1}' conflicts with the imported type '{2}' in '{3}'. Using the type defined in '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0437" xml:space="preserve">
    <value>The type '{0}' in '{1}' conflicts with the imported namespace '{2}' in '{3}'. Using the type defined in '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0440" xml:space="preserve">
    <value>Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias</value>
  </data>
  <data name="CSharpWarnings_CS0444" xml:space="preserve">
    <value>Predefined type '{0}' was not found in '{1}' but was found in '{2}'</value>
  </data>
  <data name="CSharpWarnings_CS0458" xml:space="preserve">
    <value>The result of the expression is always 'null' of type '{0}'</value>
  </data>
  <data name="CSharpWarnings_CS0464" xml:space="preserve">
    <value>Comparing with null of type '{0}' always produces 'false'</value>
  </data>
  <data name="CSharpWarnings_CS0465" xml:space="preserve">
    <value>Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?</value>
  </data>
  <data name="CSharpWarnings_CS0467" xml:space="preserve">
    <value>Ambiguity between method '{0}' and non-method '{1}'. Using method group.</value>
  </data>
  <data name="CSharpWarnings_CS0469" xml:space="preserve">
    <value>The '{0}' value is not implicitly convertible to type '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0472" xml:space="preserve">
    <value>The result of the expression is always '{0}' since a value of type '{1}' is never equal to 'null' of type '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0602" xml:space="preserve">
    <value>The feature '{0}' is deprecated. Please use '{1}' instead.</value>
  </data>
  <data name="CSharpWarnings_CS0612" xml:space="preserve">
    <value>'{0}' is obsolete.</value>
  </data>
  <data name="CSharpWarnings_CS0618" xml:space="preserve">
    <value>'{0}' is obsolete: '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0626" xml:space="preserve">
    <value>Method, operator, or accessor '{0}' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.</value>
  </data>
  <data name="CSharpWarnings_CS0628" xml:space="preserve">
    <value>'{0}' : new protected member declared in sealed class.</value>
  </data>
  <data name="CSharpWarnings_CS0642" xml:space="preserve">
    <value>Possible mistaken empty statement</value>
  </data>
  <data name="CSharpWarnings_CS0649" xml:space="preserve">
    <value>Field '{0}' is never assigned to, and will always have its default value '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0652" xml:space="preserve">
    <value>Comparison to integral constant is useless; the constant is outside the range of type '{0}'.</value>
  </data>
  <data name="CSharpWarnings_CS0657" xml:space="preserve">
    <value>'{0}' is not a valid attribute location for this declaration. Valid attribute locations for this declaration are '{1}'. All attributes in this block will be ignored.</value>
  </data>
  <data name="CSharpWarnings_CS0658" xml:space="preserve">
    <value>'{0}' is not a recognized attribute location. All attributes in this block will be ignored.</value>
  </data>
  <data name="CSharpWarnings_CS0659" xml:space="preserve">
    <value>'{0}' overrides Object.Equals(object o) but does not override 'Object.GetHashCode()'.</value>
  </data>
  <data name="CSharpWarnings_CS0660" xml:space="preserve">
    <value>'{0}' defines operator == or operator != but does not override 'Object.Equals(object o)'.</value>
  </data>
  <data name="CSharpWarnings_CS0661" xml:space="preserve">
    <value>'{0}' defines operator == or operator != but does not override 'Object.GetHashCode()'.</value>
  </data>
  <data name="CSharpWarnings_CS0665" xml:space="preserve">
    <value>Assignment in conditional expression is always constant; did you mean to use '==' instead of '='?</value>
  </data>
  <data name="CSharpWarnings_CS0672" xml:space="preserve">
    <value>Member '{0}' overrides obsolete member '{1}'. Add the Obsolete attribute to '{0}'.</value>
  </data>
  <data name="CSharpWarnings_CS0675" xml:space="preserve">
    <value>Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first</value>
  </data>
  <data name="CSharpWarnings_CS0693" xml:space="preserve">
    <value>Type parameter '{0}' has the same name as the type parameter from outer type '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0728" xml:space="preserve">
    <value>Possibly incorrect assignment to local '{0}' which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.</value>
  </data>
  <data name="CSharpWarnings_CS0809" xml:space="preserve">
    <value>Obsolete member '{0}' overrides non-obsolete member '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS0824" xml:space="preserve">
    <value>Constructor '{0}' is marked external.</value>
  </data>
  <data name="CSharpWarnings_CS1030" xml:space="preserve">
    <value>#warning: '{0}'.</value>
  </data>
  <data name="CSharpWarnings_CS1058" xml:space="preserve">
    <value>A previous catch clause already catches all exceptions. All exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException</value>
  </data>
  <data name="CSharpWarnings_CS1060" xml:space="preserve">
    <value>Use of possibly unassigned field 'name'. Struct instance variables are initially unassigned if struct is unassigned.</value>
  </data>
  <data name="CSharpWarnings_CS1522" xml:space="preserve">
    <value>Empty switch block</value>
  </data>
  <data name="CSharpWarnings_CS1570" xml:space="preserve">
    <value>XML comment on '{0}' has badly formed XML: {1}</value>
  </data>
  <data name="CSharpWarnings_CS1571" xml:space="preserve">
    <value>XML comment on '{0}' has a duplicate param tag for '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS1572" xml:space="preserve">
    <value>XML comment on '{0}' has a param tag for '{1}', but there is no parameter by that name.</value>
  </data>
  <data name="CSharpWarnings_CS1573" xml:space="preserve">
    <value>Parameter '{0}' has no matching param tag in the XML comment for '{0}' (but other parameters do).</value>
  </data>
  <data name="CSharpWarnings_CS1574" xml:space="preserve">
    <value>XML comment on '{0}' has cref attribute '{1}' that could not be resolved.</value>
  </data>
  <data name="CSharpWarnings_CS1580" xml:space="preserve">
    <value>Invalid type for parameter '{0}' in XML comment cref attribute.</value>
  </data>
  <data name="CSharpWarnings_CS1581" xml:space="preserve">
    <value>Invalid return type in XML comment cref attribute</value>
  </data>
  <data name="CSharpWarnings_CS1584" xml:space="preserve">
    <value>XML comment on '{0}' has syntactically incorrect cref attribute '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS1587" xml:space="preserve">
    <value>XML comment is not placed on a valid language element</value>
  </data>
  <data name="CSharpWarnings_CS1589" xml:space="preserve">
    <value>Unable to include XML fragment '{0}' of file '{1}': {2}</value>
  </data>
  <data name="CSharpWarnings_CS1590" xml:space="preserve">
    <value>Invalid XML include element -- Missing file attribute</value>
  </data>
  <data name="CSharpWarnings_CS1591" xml:space="preserve">
    <value>Missing XML comment for publicly visible type or member '{0}'.</value>
  </data>
  <data name="CSharpWarnings_CS1592" xml:space="preserve">
    <value>Badly formed XML in included comments file -- '{0}'.</value>
  </data>
  <data name="CSharpWarnings_CS1598" xml:space="preserve">
    <value>XML parser could not be loaded for the following reason: '{0}'. The XML documentation file '{1}' will not be generated.</value>
  </data>
  <data name="CSharpWarnings_CS1607" xml:space="preserve">
    <value>Assembly generation: {0}</value>
  </data>
  <data name="CSharpWarnings_CS1610" xml:space="preserve">
    <value>Unable to delete temporary file '{0}' used for default Win32 resource -- {1}</value>
  </data>
  <data name="CSharpWarnings_CS1616" xml:space="preserve">
    <value>Option '{0}' overrides attribute '{1}' given in a source file or added module.</value>
  </data>
  <data name="CSharpWarnings_CS1633" xml:space="preserve">
    <value>Unrecognized #pragma directive</value>
  </data>
  <data name="CSharpWarnings_CS1634" xml:space="preserve">
    <value>Expected disable or restore</value>
  </data>
  <data name="CSharpWarnings_CS1635" xml:space="preserve">
    <value>Cannot restore warning '{0}' because it was disabled globally.</value>
  </data>
  <data name="CSharpWarnings_CS1645" xml:space="preserve">
    <value>Feature '{0}' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers.</value>
  </data>
  <data name="CSharpWarnings_CS1658" xml:space="preserve">
    <value>{0}. See also error: {1}</value>
  </data>
  <data name="CSharpWarnings_CS1668" xml:space="preserve">
    <value>Invalid search path '{0}' specified in '{1}': {2}</value>
  </data>
  <data name="CSharpWarnings_CS1682" xml:space="preserve">
    <value>Reference to type '{0}' claims it is nested within '{1}', but it could not be found.</value>
  </data>
  <data name="CSharpWarnings_CS1683" xml:space="preserve">
    <value>Reference to type '{0}' claims it is defined in this assembly, but it is not defined in source or any added modules.</value>
  </data>
  <data name="CSharpWarnings_CS1684" xml:space="preserve">
    <value>Reference to type '{0}' claims it is defined in '{1}', but it could not be found.</value>
  </data>
  <data name="CSharpWarnings_CS1685" xml:space="preserve">
    <value>The predefined type '{0}' is defined in multiple assemblies in the global alias; using definition from '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS1687" xml:space="preserve">
    <value>Source file has exceeded the limit of 16,707,565 lines representable in the PDB, debug information will be incorrect</value>
  </data>
  <data name="CSharpWarnings_CS1690" xml:space="preserve">
    <value>Accessing a member on '{0}' may cause a runtime exception because it is a field of a marshal-by-reference class</value>
  </data>
  <data name="CSharpWarnings_CS1691" xml:space="preserve">
    <value>'{0}' is not a valid warning number</value>
  </data>
  <data name="CSharpWarnings_CS1692" xml:space="preserve">
    <value>Invalid number.</value>
  </data>
  <data name="CSharpWarnings_CS1694" xml:space="preserve">
    <value>Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.</value>
  </data>
  <data name="CSharpWarnings_CS1695" xml:space="preserve">
    <value>Invalid #pragma checksum syntax; should be #pragma checksum "filename" "{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}" "XXXX...".</value>
  </data>
  <data name="CSharpWarnings_CS1696" xml:space="preserve">
    <value>Single-line comment or end-of-line expected.</value>
  </data>
  <data name="CSharpWarnings_CS1697" xml:space="preserve">
    <value>Different checksum values given for '{0}'.</value>
  </data>
  <data name="CSharpWarnings_CS1698" xml:space="preserve">
    <value>Circular assembly reference '{0}' does not match the output assembly name '{1}'. Try adding a reference to '{0}' or changing the output assembly name to match.</value>
  </data>
  <data name="CSharpWarnings_CS1699" xml:space="preserve">
    <value>Use command line option '{0}' or appropriate project settings instead of '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS1700" xml:space="preserve">
    <value>Assembly reference Assembly Name is invalid and cannot be resolved</value>
  </data>
  <data name="CSharpWarnings_CS1701" xml:space="preserve">
    <value>Assuming assembly reference '{0}' matches '{1}', you may need to supply runtime policy.</value>
  </data>
  <data name="CSharpWarnings_CS1702" xml:space="preserve">
    <value>Assuming assembly reference '{0}' matches '{1}', you may need to supply runtime policy.</value>
  </data>
  <data name="CSharpWarnings_CS1707" xml:space="preserve">
    <value>Delegate '{0}' bound to '{1}' instead of '{2}' because of new language rules</value>
  </data>
  <data name="CSharpWarnings_CS1709" xml:space="preserve">
    <value>Filename specified for preprocessor directive is empty.</value>
  </data>
  <data name="CSharpWarnings_CS1710" xml:space="preserve">
    <value>XML comment on '{0}' has a duplicate typeparam tag for '{1}'.</value>
  </data>
  <data name="CSharpWarnings_CS1711" xml:space="preserve">
    <value>XML comment on '{0}' has a typeparam tag for '{1}', but there is no type parameter by that name.</value>
  </data>
  <data name="CSharpWarnings_CS1712" xml:space="preserve">
    <value>Type parameter '{0}' has no matching typeparam tag in the XML comment on '{1}' (but other type parameters do.)</value>
  </data>
  <data name="CSharpWarnings_CS1717" xml:space="preserve">
    <value>Assignment made to same variable; did you mean to assign something else?</value>
  </data>
  <data name="CSharpWarnings_CS1718" xml:space="preserve">
    <value>Comparison made to same variable; did you mean to compare something else?</value>
  </data>
  <data name="CSharpWarnings_CS1720" xml:space="preserve">
    <value>Expression will always cause a System.NullReferenceException because the default value of {0} is null</value>
  </data>
  <data name="CSharpWarnings_CS1723" xml:space="preserve">
    <value>XML comment on {0} has cref attribute {1} that refers to a type parameter</value>
  </data>
  <data name="CSharpWarnings_CS1911" xml:space="preserve">
    <value>Access to member {0} through a 'base' keyword from an anonymous method, lambda expression, query expression, or iterator results in unverifiable code. Consider moving the access into a helper method on the containing type.</value>
  </data>
  <data name="CSharpWarnings_CS1927" xml:space="preserve">
    <value>Ignoring /win32manifest for module because it only applies to assemblies.</value>
  </data>
  <data name="CSharpWarnings_CS1956" xml:space="preserve">
    <value>Member {0} implements interface member {0} in type {1}. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.</value>
  </data>
  <data name="CSharpWarnings_CS1957" xml:space="preserve">
    <value>Member {0} overrides {1}. There are multiple override candidates at run-time. It is implementation dependent which method will be called.</value>
  </data>
  <data name="CSharpWarnings_CS2002" xml:space="preserve">
    <value>Source file {0} specified multiple times</value>
  </data>
  <data name="CSharpWarnings_CS2014" xml:space="preserve">
    <value>Compiler option {0} is obsolete, please use {1} instead</value>
  </data>
  <data name="CSharpWarnings_CS2023" xml:space="preserve">
    <value>Ignoring /noconfig option because it was specified in a response file</value>
  </data>
  <data name="CSharpWarnings_CS2029" xml:space="preserve">
    <value>Invalid value for '/define'; {0} is not a valid identifier</value>
  </data>
  <data name="CSharpWarnings_CS3000" xml:space="preserve">
    <value>Methods with variable arguments are not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3001" xml:space="preserve">
    <value>Argument type {0} is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3002" xml:space="preserve">
    <value>Return type of {0} is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3003" xml:space="preserve">
    <value>Type of {0} is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3004" xml:space="preserve">
    <value>Mixed and decomposed Unicode characters are not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3005" xml:space="preserve">
    <value>Identifier {0} differing only in case is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3006" xml:space="preserve">
    <value>Overloaded method {0} differing only in ref or out, or in array rank, is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3007" xml:space="preserve">
    <value>Overloaded method {0} differing only by unnamed array types is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3008" xml:space="preserve">
    <value>Identifier {0} differing only in case is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3009" xml:space="preserve">
    <value>{0}: base type {0} is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3010" xml:space="preserve">
    <value>{0}: CLS-compliant interfaces must have only CLS-compliant members</value>
  </data>
  <data name="CSharpWarnings_CS3011" xml:space="preserve">
    <value>{0}: only CLS-compliant members can be abstract</value>
  </data>
  <data name="CSharpWarnings_CS3012" xml:space="preserve">
    <value>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</value>
  </data>
  <data name="CSharpWarnings_CS3013" xml:space="preserve">
    <value>Added modules must be marked with the CLSCompliant attribute to match the assembly</value>
  </data>
  <data name="CSharpWarnings_CS3014" xml:space="preserve">
    <value>{0} does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</value>
  </data>
  <data name="CSharpWarnings_CS3015" xml:space="preserve">
    <value>{0} has no accessible constructors which use only CLS-compliant types</value>
  </data>
  <data name="CSharpWarnings_CS3016" xml:space="preserve">
    <value>Arrays as attribute arguments is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS3017" xml:space="preserve">
    <value>You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly</value>
  </data>
  <data name="CSharpWarnings_CS3018" xml:space="preserve">
    <value>{0} cannot be marked as CLS-Compliant because it is a member of non CLS-compliant type {1}</value>
  </data>
  <data name="CSharpWarnings_CS3019" xml:space="preserve">
    <value>CLS compliance checking will not be performed on {0} because it is not visible from outside this assembly.</value>
  </data>
  <data name="CSharpWarnings_CS3021" xml:space="preserve">
    <value>{0} does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute</value>
  </data>
  <data name="CSharpWarnings_CS3022" xml:space="preserve">
    <value>CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.</value>
  </data>
  <data name="CSharpWarnings_CS3023" xml:space="preserve">
    <value>CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.</value>
  </data>
  <data name="CSharpWarnings_CS3026" xml:space="preserve">
    <value>CLS-compliant field {0} cannot be volatile</value>
  </data>
  <data name="CSharpWarnings_CS3027" xml:space="preserve">
    <value>{0} is not CLS-compliant because base interface {1} is not CLS-compliant</value>
  </data>
  <data name="CSharpWarnings_CS5000" xml:space="preserve">
    <value>Unknown compiler option {0}</value>
  </data>
  <data name="Exception_ArgumentNull_CustomAttribute_ctor_data" xml:space="preserve">
    <value>Error, the custom attribute type defined in the parameter '{0}' is null.</value>
  </data>
  <data name="Exception_Argument_CoercionType_CannotBeInterface" xml:space="preserve">
    <value>Error, the specified type for the coercion type is an interface.  This is illegal by convention.  Try implementing the interface instead.</value>
  </data>
  <data name="Exception_Argument_CustomAttribute_Type_MustBeAttribute" xml:space="preserve">
    <value>Error, the specified type for the custom attribute definition is not derived from attribute.  Attributes cannot be applied unless they derive from Attribute.</value>
  </data>
  <data name="Exception_InvalidOperation_CompilerState" xml:space="preserve">
    <value>Compiler in invalid state, {0}.</value>
  </data>
  <data name="Exception_InvalidOperation_ContainingSideIsBoth" xml:space="preserve">
    <value>Error, the containing type is set to occupy both the left and right parameters of the binary operation.  Alter ContainingSide first.</value>
  </data>
  <data name="Exception_ParameterCount_Mismatch" xml:space="preserve">
    <value>Parameter count must match.</value>
  </data>
  <data name="Exception_Precompiled_Mismatch" xml:space="preserve">
    <value>Delegate already compiled, signature does not match.</value>
  </data>
  <data name="Exception_ReturnType_Mismatch" xml:space="preserve">
    <value>Result type does not match.</value>
  </data>
  <data name="Statement_Return_Keyword" xml:space="preserve">
    <value>return</value>
  </data>
</root>