using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AllenCopeland.Abstraction.Slf.Compilers
{
    public static class CSCompilerMessages
    {
        public static readonly ICompilerReferenceWarning CS0028 = new CompilerReferenceWarning(@"{0} has the wrong signature to be an entry point ", 4, 28);
        public static readonly ICompilerReferenceWarning CS0067 = new CompilerReferenceWarning(@"The event {0} is never used", 3, 67);
        public static readonly ICompilerReferenceWarning CS0078 = new CompilerReferenceWarning(@"The 'l' suffix is easily confused with the digit '1' -- use 'L' for clarity", 4, 78);
        public static readonly ICompilerReferenceWarning CS0105 = new CompilerReferenceWarning(@"The using directive for {0} appeared previously in this namespace", 3, 105);
        public static readonly ICompilerReferenceWarning CS0108 = new CompilerReferenceWarning(@"{0} hides inherited member {1}. Use the new keyword if hiding was intended.", 2, 108);
        public static readonly ICompilerReferenceWarning CS0109 = new CompilerReferenceWarning(@"The member {0} does not hide an inherited member. The new keyword is not required", 4, 109);
        public static readonly ICompilerReferenceWarning CS0114 = new CompilerReferenceWarning(@"{0} hides inherited member {1}. To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.", 2, 114);
        public static readonly ICompilerReferenceWarning CS0162 = new CompilerReferenceWarning(@"Unreachable code detected", 2, 162);
        public static readonly ICompilerReferenceWarning CS0164 = new CompilerReferenceWarning(@"This label has not been referenced", 2, 164);
        public static readonly ICompilerReferenceWarning CS0168 = new CompilerReferenceWarning(@"The variable {0} is assigned but its value is never used", 3, 168);
        public static readonly ICompilerReferenceWarning CS0169 = new CompilerReferenceWarning(@"The private field {0} is never used", 3, 169);
        public static readonly ICompilerReferenceWarning CS0183 = new CompilerReferenceWarning(@"The given expression is always of the provided ({0}) type", 1, 183);
        public static readonly ICompilerReferenceWarning CS0184 = new CompilerReferenceWarning(@"The given expression is never of the provided ({0}) type", 1, 184);
        public static readonly ICompilerReferenceWarning CS0197 = new CompilerReferenceWarning(@"Passing {0} as ref or out or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class", 1, 197);
        public static readonly ICompilerReferenceWarning CS0219 = new CompilerReferenceWarning(@"The variable {0} is assigned but its value is never used", 3, 219);
        public static readonly ICompilerReferenceWarning CS0251 = new CompilerReferenceWarning(@"Indexing an array with a negative index (array indices always start at zero)", 2, 251);
        public static readonly ICompilerReferenceWarning CS0252 = new CompilerReferenceWarning(@"Possible unintended reference comparison; to get a value comparison, cast the left hand side to type {0}", 2, 252);
        public static readonly ICompilerReferenceWarning CS0253 = new CompilerReferenceWarning(@"Possible unintended reference comparison; to get a value comparison, cast the right hand side to type {0}", 2, 253);
        public static readonly ICompilerReferenceWarning CS0278 = new CompilerReferenceWarning(@"{0} does not implement the {1} pattern. {2} is ambiguous with {2}.", 2, 278);
        public static readonly ICompilerReferenceWarning CS0279 = new CompilerReferenceWarning(@"{0} does not implement the {1} pattern. {2} is either static or not public.", 2, 279);
        public static readonly ICompilerReferenceWarning CS0280 = new CompilerReferenceWarning(@"{0} does not implement the {1} pattern. {2} has the wrong signature.", 2, 280);
        public static readonly ICompilerReferenceWarning CS0282 = new CompilerReferenceWarning(@"There is no defined ordering between fields in multiple declarations of partial class or struct {0}. To specify an ordering, all instance fields must be in the same declaration.", 3, 282);
        public static readonly ICompilerReferenceWarning CS0402 = new CompilerReferenceWarning(@"{0} : an entry point cannot be generic or in a generic type", 4, 402);
        public static readonly ICompilerReferenceWarning CS0414 = new CompilerReferenceWarning(@"The private field {0} is assigned but its value is never used", 3, 414);
        public static readonly ICompilerReferenceWarning CS0419 = new CompilerReferenceWarning(@"Ambiguous reference in cref attribute: {0}. Assuming {1}, but could have also matched other overloads including {2}.", 3, 419);
        public static readonly ICompilerReferenceWarning CS0420 = new CompilerReferenceWarning(@"{0}: a reference to a volatile field will not be treated as volatile", 1, 420);
        public static readonly ICompilerReferenceWarning CS0422 = new CompilerReferenceWarning(@"The /incremental option is no longer supported", 4, 422);
        public static readonly ICompilerReferenceWarning CS0429 = new CompilerReferenceWarning(@"Unreachable expression code detected ", 4, 429);
        public static readonly ICompilerReferenceWarning CS0435 = new CompilerReferenceWarning(@"The namespace {0} in {1} conflicts with the imported type {2} in {3}. Using the namespace defined in {1}..", 2, 435);
        public static readonly ICompilerReferenceWarning CS0436 = new CompilerReferenceWarning(@"The type {0} in {1} conflicts with the imported type {2} in {3}. Using the type defined in {1}.", 2, 436);
        public static readonly ICompilerReferenceWarning CS0437 = new CompilerReferenceWarning(@"The type {0} in {1} conflicts with the imported namespace {2} in {3}. Using the type defined in {1}.", 2, 437);
        public static readonly ICompilerReferenceWarning CS0440 = new CompilerReferenceWarning(@"Defining an alias named 'global' is ill-advised since 'global::' always references the global namespace and not an alias", 2, 440);
        public static readonly ICompilerReferenceWarning CS0444 = new CompilerReferenceWarning(@"Predefined type {0} was not found in {1} but was found in {2}", 2, 444);
        public static readonly ICompilerReferenceWarning CS0458 = new CompilerReferenceWarning(@"The result of the expression is always 'null' of type {0}", 2, 458);
        public static readonly ICompilerReferenceWarning CS0464 = new CompilerReferenceWarning(@"Comparing with null of type {0} always produces 'false'", 2, 464);
        public static readonly ICompilerReferenceWarning CS0465 = new CompilerReferenceWarning(@"Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?", 1, 465);
        public static readonly ICompilerReferenceWarning CS0467 = new CompilerReferenceWarning(@"Ambiguity between method {0} and non-method {1}. Using method group.", 2, 467);
        public static readonly ICompilerReferenceWarning CS0469 = new CompilerReferenceWarning(@"The {0} value is not implicitly convertible to type {1}", 2, 469);
        public static readonly ICompilerReferenceWarning CS0472 = new CompilerReferenceWarning(@"The result of the expression is always {0} since a value of type {1} is never equal to 'null' of type {1}", 2, 472);
        public static readonly ICompilerReferenceWarning CS0602 = new CompilerReferenceWarning(@"The feature {0} is deprecated. Please use {1} instead", 1, 602);
        public static readonly ICompilerReferenceWarning CS0612 = new CompilerReferenceWarning(@"{0} is obsolete", 1, 612);
        public static readonly ICompilerReferenceWarning CS0618 = new CompilerReferenceWarning(@"{0} is obsolete: {1}", 2, 618);
        public static readonly ICompilerReferenceWarning CS0626 = new CompilerReferenceWarning(@"Method, operator, or accessor {0} is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation", 1, 626);
        public static readonly ICompilerReferenceWarning CS0628 = new CompilerReferenceWarning(@"{0} : new protected member declared in sealed class", 4, 628);
        public static readonly ICompilerReferenceWarning CS0642 = new CompilerReferenceWarning(@"Possible mistaken empty statement", 3, 642);
        public static readonly ICompilerReferenceWarning CS0649 = new CompilerReferenceWarning(@"Field {0} is never assigned to, and will always have its default value {1}", 4, 649);
        public static readonly ICompilerReferenceWarning CS0652 = new CompilerReferenceWarning(@"Comparison to integral constant is useless; the constant is outside the range of type {0}", 2, 652);
        public static readonly ICompilerReferenceWarning CS0657 = new CompilerReferenceWarning(@"{0} is not a valid attribute location for this declaration. Valid attribute locations for this declaration are {1}. All attributes in this block will be ignored.", 1, 657);
        public static readonly ICompilerReferenceWarning CS0658 = new CompilerReferenceWarning(@"{0} is not a recognized attribute location. All attributes in this block will be ignored.", 1, 658);
        public static readonly ICompilerReferenceWarning CS0659 = new CompilerReferenceWarning(@"{0} overrides Object.Equals(object o) but does not override Object.GetHashCode()", 3, 659);
        public static readonly ICompilerReferenceWarning CS0660 = new CompilerReferenceWarning(@"{0} defines operator == or operator != but does not override Object.Equals(object o)", 3, 660);
        public static readonly ICompilerReferenceWarning CS0661 = new CompilerReferenceWarning(@"{0} defines operator == or operator != but does not override Object.GetHashCode()", 3, 661);
        public static readonly ICompilerReferenceWarning CS0665 = new CompilerReferenceWarning(@"Assignment in conditional expression is always constant; did you mean to use '==' instead of '='?", 3, 665);
        public static readonly ICompilerReferenceWarning CS0672 = new CompilerReferenceWarning(@"Member {0} overrides obsolete member '{1}. Add the Obsolete attribute to {0}", 1, 672);
        public static readonly ICompilerReferenceWarning CS0675 = new CompilerReferenceWarning(@"Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first", 3, 675);
        public static readonly ICompilerReferenceWarning CS0693 = new CompilerReferenceWarning(@"Type parameter {0} has the same name as the type parameter from outer type {1}", 3, 693);
        public static readonly ICompilerReferenceWarning CS0728 = new CompilerReferenceWarning(@"Possibly incorrect assignment to local {0} which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local.", 2, 728);
        public static readonly ICompilerReferenceWarning CS0809 = new CompilerReferenceWarning(@"Obsolete member {0} overrides non-obsolete member {1}.", 1, 809);
        public static readonly ICompilerReferenceWarning CS0824 = new CompilerReferenceWarning(@"Constructor {0} is marked external.", 1, 824);
        public static readonly ICompilerReferenceWarning CS1030 = new CompilerReferenceWarning(@"#warning: {0}", 1, 1030);
        public static readonly ICompilerReferenceWarning CS1058 = new CompilerReferenceWarning(@"A previous catch clause already catches all exceptions. All exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException", 1, 1058);
        public static readonly ICompilerReferenceWarning CS1060 = new CompilerReferenceWarning(@"Use of possibly unassigned field 'name'. Struct instance variables are initially unassigned if struct is unassigned.", 1, 1060);
        public static readonly ICompilerReferenceWarning CS1522 = new CompilerReferenceWarning(@"Empty switch block", 1, 1522);
        public static readonly ICompilerReferenceWarning CS1570 = new CompilerReferenceWarning(@"XML comment on {0} has badly formed XML — {1}", 1, 1570);
        public static readonly ICompilerReferenceWarning CS1571 = new CompilerReferenceWarning(@"XML comment on {0} has a duplicate param tag for {1}", 2, 1571);
        public static readonly ICompilerReferenceWarning CS1572 = new CompilerReferenceWarning(@"XML comment on {0} has a param tag for {1}, but there is no parameter by that name", 2, 1572);
        public static readonly ICompilerReferenceWarning CS1573 = new CompilerReferenceWarning(@"Parameter {0} has no matching param tag in the XML comment for {0} (but other parameters do)", 4, 1573);
        public static readonly ICompilerReferenceWarning CS1574 = new CompilerReferenceWarning(@"XML comment on {0} has syntactically incorrect cref attribute {1}", 1, 1574);
        public static readonly ICompilerReferenceWarning CS1580 = new CompilerReferenceWarning(@"Invalid type for parameter {0} in XML comment cref attribute", 1, 1580);
        public static readonly ICompilerReferenceWarning CS1581 = new CompilerReferenceWarning(@"Invalid return type in XML comment cref attribute", 1, 1581);
        public static readonly ICompilerReferenceWarning CS1584 = new CompilerReferenceWarning(@"XML comment on {0} has syntactically incorrect cref attribute {1}", 1, 1584);
        public static readonly ICompilerReferenceWarning CS1587 = new CompilerReferenceWarning(@"XML comment is not placed on a valid language element", 2, 1587);
        public static readonly ICompilerReferenceWarning CS1589 = new CompilerReferenceWarning(@"Unable to include XML fragment {0} of file {1} -- {1}", 1, 1589);
        public static readonly ICompilerReferenceWarning CS1590 = new CompilerReferenceWarning(@"Invalid XML include element -- Missing file attribute", 1, 1590);
        public static readonly ICompilerReferenceWarning CS1591 = new CompilerReferenceWarning(@"Missing XML comment for publicly visible type or member {0}", 4, 1591);
        public static readonly ICompilerReferenceWarning CS1592 = new CompilerReferenceWarning(@"Badly formed XML in included comments file -- {0}", 1, 1592);
        public static readonly ICompilerReferenceWarning CS1598 = new CompilerReferenceWarning(@"XML parser could not be loaded for the following reason: {0}. The XML documentation file {1} will not be generated.", 1, 1598);
        public static readonly ICompilerReferenceWarning CS1607 = new CompilerReferenceWarning(@"Assembly generation -- {0}", 1, 1607);
        public static readonly ICompilerReferenceWarning CS1610 = new CompilerReferenceWarning(@"Unable to delete temporary file {0} used for default Win32 resource -- {1}", 4, 1610);
        public static readonly ICompilerReferenceWarning CS1616 = new CompilerReferenceWarning(@"Option {0} overrides attribute {1} given in a source file or added module", 1, 1616);
        public static readonly ICompilerReferenceWarning CS1633 = new CompilerReferenceWarning(@"Unrecognized #pragma directive", 1, 1633);
        public static readonly ICompilerReferenceWarning CS1634 = new CompilerReferenceWarning(@"Expected disable or restore", 1, 1634);
        public static readonly ICompilerReferenceWarning CS1635 = new CompilerReferenceWarning(@"Cannot restore warning {0} because it was disabled globally", 1, 1635);
        public static readonly ICompilerReferenceWarning CS1645 = new CompilerReferenceWarning(@"Feature {0} is not part of the standardized ISO C# language specification, and may not be accepted by other compilers", 1, 1645);
        public static readonly ICompilerReferenceWarning CS1658 = new CompilerReferenceWarning(@"{0}. See also error: {1}", 1, 1658);
        public static readonly ICompilerReferenceWarning CS1668 = new CompilerReferenceWarning(@"Invalid search path 'path' specified in {0} -- {1}", 2, 1668);
        public static readonly ICompilerReferenceWarning CS1682 = new CompilerReferenceWarning(@"Reference to type {0} claims it is nested within {1}, but it could not be found", 1, 1682);
        public static readonly ICompilerReferenceWarning CS1683 = new CompilerReferenceWarning(@"Reference to type {0} claims it is defined in this assembly, but it is not defined in source or any added modules", 1, 1683);
        public static readonly ICompilerReferenceWarning CS1684 = new CompilerReferenceWarning(@"Reference to type {0} claims it is defined in {1}, but it could not be found", 1, 1684);
        //System variation of CS0436
        public static readonly ICompilerReferenceWarning CS1685 = new CompilerReferenceWarning(@"The predefined type {0} is defined in multiple assemblies in the global alias; using definition from {1}", 1, 1685);
        public static readonly ICompilerReferenceWarning CS1687 = new CompilerReferenceWarning(@"Source file has exceeded the limit of 16,707,565 lines representable in the PDB, debug information will be incorrect", 1, 1687);
        public static readonly ICompilerReferenceWarning CS1690 = new CompilerReferenceWarning(@"Accessing a member on {0} may cause a runtime exception because it is a field of a marshal-by-reference class", 1, 1690);
        public static readonly ICompilerReferenceWarning CS1691 = new CompilerReferenceWarning(@"{0} is not a valid warning number", 1, 1691);
        public static readonly ICompilerReferenceWarning CS1692 = new CompilerReferenceWarning(@"Invalid number", 1, 1692);
        public static readonly ICompilerReferenceWarning CS1694 = new CompilerReferenceWarning(@"Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename.", 1, 1694);
        public static readonly ICompilerReferenceWarning CS1695 = new CompilerReferenceWarning(@"Invalid #pragma checksum syntax; should be #pragma checksum ""filename"" ""{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}"" ""XXXX...""", 1, 1695);
        public static readonly ICompilerReferenceWarning CS1696 = new CompilerReferenceWarning(@"Single-line comment or end-of-line expected", 1, 1696);
        public static readonly ICompilerReferenceWarning CS1697 = new CompilerReferenceWarning(@"Different checksum values given for {0}", 1, 1697);
        public static readonly ICompilerReferenceWarning CS1698 = new CompilerReferenceWarning(@"Circular assembly reference {0} does not match the output assembly name {1}. Try adding a reference to {0} or changing the output assembly name to match.", 2, 1698);
        public static readonly ICompilerReferenceWarning CS1699 = new CompilerReferenceWarning(@"Use command line option {0} or appropriate project settings instead of {1}", 1, 1699);
        public static readonly ICompilerReferenceWarning CS1700 = new CompilerReferenceWarning(@"Assembly reference Assembly Name is invalid and cannot be resolved", 3, 1700);
        public static readonly ICompilerReferenceWarning CS1701 = new CompilerReferenceWarning(@"Assuming assembly reference {0} matches {1}, you may need to supply runtime policy ", 2, 1701);
        public static readonly ICompilerReferenceWarning CS1702 = new CompilerReferenceWarning(@"Assuming assembly reference {0} matches {1}, you may need to supply runtime policy", 3, 1702);
        public static readonly ICompilerReferenceWarning CS1707 = new CompilerReferenceWarning(@"Delegate {0} bound to {1} instead of {2} because of new language rules", 1, 1707);
        public static readonly ICompilerReferenceWarning CS1709 = new CompilerReferenceWarning(@"Filename specified for preprocessor directive is empty", 1, 1709);
        public static readonly ICompilerReferenceWarning CS1710 = new CompilerReferenceWarning(@"XML comment on {0} has a duplicate typeparam tag for {1}", 2, 1710);
        public static readonly ICompilerReferenceWarning CS1711 = new CompilerReferenceWarning(@"XML comment on {0} has a typeparam tag for {1}, but there is no type parameter by that name", 2, 1711);
        public static readonly ICompilerReferenceWarning CS1712 = new CompilerReferenceWarning(@"Type parameter {0} has no matching typeparam tag in the XML comment on {1} (but other type parameters do)", 4, 1712);
        public static readonly ICompilerReferenceWarning CS1717 = new CompilerReferenceWarning(@"Assignment made to same variable; did you mean to assign something else?", 3, 1717);
        public static readonly ICompilerReferenceWarning CS1718 = new CompilerReferenceWarning(@"Comparison made to same variable; did you mean to compare something else?", 3, 1718);
        public static readonly ICompilerReferenceWarning CS1720 = new CompilerReferenceWarning(@"Expression will always cause a System.NullReferenceException because the default value of {0} is null", 1, 1720);
        public static readonly ICompilerReferenceWarning CS1723 = new CompilerReferenceWarning(@"XML comment on {0} has cref attribute {1} that refers to a type parameter", 1, 1723);
        public static readonly ICompilerReferenceWarning CS1911 = new CompilerReferenceWarning(@"Access to member {0} through a 'base' keyword from an anonymous method, lambda expression, query expression, or iterator results in unverifiable code. Consider moving the access into a helper method on the containing type.", 1, 1911);
        public static readonly ICompilerReferenceWarning CS1927 = new CompilerReferenceWarning(@"Ignoring /win32manifest for module because it only applies to assemblies.", 2, 1927);
        public static readonly ICompilerReferenceWarning CS1956 = new CompilerReferenceWarning(@"Member {0} implements interface member {0} in type {1}. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called.", 1, 1956);
        public static readonly ICompilerReferenceWarning CS1957 = new CompilerReferenceWarning(@"Member {0} overrides {1}. There are multiple override candidates at run-time. It is implementation dependent which method will be called.", 1, 1957);
        public static readonly ICompilerReferenceWarning CS2002 = new CompilerReferenceWarning(@"Source file {0} specified multiple times", 1, 2002);
        public static readonly ICompilerReferenceWarning CS2014 = new CompilerReferenceWarning(@"Compiler option {0} is obsolete, please use {1} instead", 1, 2014);
        public static readonly ICompilerReferenceWarning CS2023 = new CompilerReferenceWarning(@"Ignoring /noconfig option because it was specified in a response file", 1, 2023);
        public static readonly ICompilerReferenceWarning CS2029 = new CompilerReferenceWarning(@"Invalid value for '/define'; {0} is not a valid identifier", 1, 2029);
        public static readonly ICompilerReferenceWarning CS3000 = new CompilerReferenceWarning(@"Methods with variable arguments are not CLS-compliant", 1, 3000);
        public static readonly ICompilerReferenceWarning CS3001 = new CompilerReferenceWarning(@"Argument type {0} is not CLS-compliant", 1, 3001);
        public static readonly ICompilerReferenceWarning CS3002 = new CompilerReferenceWarning(@"Return type of {0} is not CLS-compliant", 1, 3002);
        public static readonly ICompilerReferenceWarning CS3003 = new CompilerReferenceWarning(@"Type of {0} is not CLS-compliant", 1, 3003);
        public static readonly ICompilerReferenceWarning CS3004 = new CompilerReferenceWarning(@"Mixed and decomposed Unicode characters are not CLS-compliant", 1, 3004);
        public static readonly ICompilerReferenceWarning CS3005 = new CompilerReferenceWarning(@"Identifier {0} differing only in case is not CLS-compliant", 1, 3005);
        public static readonly ICompilerReferenceWarning CS3006 = new CompilerReferenceWarning(@"Overloaded method {0} differing only in ref or out, or in array rank, is not CLS-compliant", 1, 3006);
        public static readonly ICompilerReferenceWarning CS3007 = new CompilerReferenceWarning(@"Overloaded method {0} differing only by unnamed array types is not CLS-compliant", 1, 3007);
        public static readonly ICompilerReferenceWarning CS3008 = new CompilerReferenceWarning(@"Identifier {0} differing only in case is not CLS-compliant", 1, 3008);
        public static readonly ICompilerReferenceWarning CS3009 = new CompilerReferenceWarning(@"{0}: base type {0} is not CLS-compliant", 1, 3009);
        public static readonly ICompilerReferenceWarning CS3010 = new CompilerReferenceWarning(@"{0}: CLS-compliant interfaces must have only CLS-compliant members", 1, 3010);
        public static readonly ICompilerReferenceWarning CS3011 = new CompilerReferenceWarning(@"{0}: only CLS-compliant members can be abstract", 1, 3011);
        public static readonly ICompilerReferenceWarning CS3012 = new CompilerReferenceWarning(@"You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly", 1, 3012);
        public static readonly ICompilerReferenceWarning CS3013 = new CompilerReferenceWarning(@"Added modules must be marked with the CLSCompliant attribute to match the assembly", 1, 3013);
        public static readonly ICompilerReferenceWarning CS3014 = new CompilerReferenceWarning(@"{0} does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute", 1, 3014);
        public static readonly ICompilerReferenceWarning CS3015 = new CompilerReferenceWarning(@"{0} has no accessible constructors which use only CLS-compliant types", 1, 3015);
        public static readonly ICompilerReferenceWarning CS3016 = new CompilerReferenceWarning(@"Arrays as attribute arguments is not CLS-compliant", 1, 3016);
        public static readonly ICompilerReferenceWarning CS3017 = new CompilerReferenceWarning(@"You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly", 1, 3017);
        public static readonly ICompilerReferenceWarning CS3018 = new CompilerReferenceWarning(@"{0} cannot be marked as CLS-Compliant because it is a member of non CLS-compliant type {1}", 1, 3018);
        public static readonly ICompilerReferenceWarning CS3019 = new CompilerReferenceWarning(@"CLS compliance checking will not be performed on {0} because it is not visible from outside this assembly.", 2, 3019);
        public static readonly ICompilerReferenceWarning CS3021 = new CompilerReferenceWarning(@"{0} does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute", 2, 3021);
        public static readonly ICompilerReferenceWarning CS3022 = new CompilerReferenceWarning(@"CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead.", 1, 3022);
        public static readonly ICompilerReferenceWarning CS3023 = new CompilerReferenceWarning(@"CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead.", 1, 3023);
        public static readonly ICompilerReferenceWarning CS3026 = new CompilerReferenceWarning(@"CLS-compliant field {0} cannot be volatile", 1, 3026);
        public static readonly ICompilerReferenceWarning CS3027 = new CompilerReferenceWarning(@"{0} is not CLS-compliant because base interface {1} is not CLS-compliant", 1, 3027);
        public static readonly ICompilerReferenceWarning CS5000 = new CompilerReferenceWarning(@"Unknown compiler option {0}", 1, 5000);
        public static readonly ICompilerReferenceError CS0001 = new CompilerReferenceError(@"Internal compiler error", 1);
        public static readonly ICompilerReferenceError CS0003 = new CompilerReferenceError(@"Out of memory", 3);
        public static readonly ICompilerReferenceError CS0004 = new CompilerReferenceError(@"Warning treated as error", 4);
        public static readonly ICompilerReferenceError CS0005 = new CompilerReferenceError(@"Compiler option {0} must be followed by an argument", 5);
        public static readonly ICompilerReferenceError CS0006 = new CompilerReferenceError(@"Metadata file {0} could not be found", 6);
        public static readonly ICompilerReferenceError CS0007 = new CompilerReferenceError(@"Unexpected common language runtime initialization error — {0}", 7);
        public static readonly ICompilerReferenceError CS0008 = new CompilerReferenceError(@"Unexpected error reading metadata from file 'file' — {0}", 8);
        public static readonly ICompilerReferenceError CS0009 = new CompilerReferenceError(@"Metadata file {0} could not be opened — {1}", 9);
        public static readonly ICompilerReferenceError CS0010 = new CompilerReferenceError(@"Unexpected fatal error -- {0}.", 10);
        public static readonly ICompilerReferenceError CS0011 = new CompilerReferenceError(@"The base class or interface {0} in assembly {1} referenced by type {2} could not be resolved", 11);
        public static readonly ICompilerReferenceError CS0012 = new CompilerReferenceError(@"The type {0} is defined in an assembly that is not referenced. You must add a reference to assembly {1}.", 12);
        public static readonly ICompilerReferenceError CS0013 = new CompilerReferenceError(@"Unexpected error writing metadata to file {0} -- {1}", 13);
        public static readonly ICompilerReferenceError CS0014 = new CompilerReferenceError(@"Required file {0} could not be found", 14);
        public static readonly ICompilerReferenceError CS0015 = new CompilerReferenceError(@"The name of type {0} is too long", 15);
        public static readonly ICompilerReferenceError CS0016 = new CompilerReferenceError(@"Could not write to output file {0} — {1}", 16);
        public static readonly ICompilerReferenceError CS0017 = new CompilerReferenceError(@"Program {0} has more than one entry point defined. Compile with /main to specify the type that contains the entry point.", 17);
        public static readonly ICompilerReferenceError CS0019 = new CompilerReferenceError(@"Operator {0} cannot be applied to operands of type {1} and {2}", 19);
        public static readonly ICompilerReferenceError CS0020 = new CompilerReferenceError(@"Division by constant zero", 20);
        public static readonly ICompilerReferenceError CS0021 = new CompilerReferenceError(@"Cannot apply indexing with [] to an expression of type {0}", 21);
        public static readonly ICompilerReferenceError CS0022 = new CompilerReferenceError(@"Wrong number of indices inside [], expected {0}", 22);
        public static readonly ICompilerReferenceError CS0023 = new CompilerReferenceError(@"Operator {0} cannot be applied to operand of type {1}", 23);
        public static readonly ICompilerReferenceError CS0025 = new CompilerReferenceError(@"Standard library file {0} could not be found", 25);
        public static readonly ICompilerReferenceError CS0026 = new CompilerReferenceError(@"Keyword 'this' is not valid in a static property, static method, or static field initializer", 26);
        public static readonly ICompilerReferenceError CS0027 = new CompilerReferenceError(@"Keyword 'this' is not available in the current context", 27);
        public static readonly ICompilerReferenceError CS0029 = new CompilerReferenceError(@"Cannot implicitly convert type {0} to {1}", 29);
        public static readonly ICompilerReferenceError CS0030 = new CompilerReferenceError(@"Cannot convert type {0} to {1}", 30);
        public static readonly ICompilerReferenceError CS0031 = new CompilerReferenceError(@"Constant value {0} cannot be converted to a {1}. (use 'unchecked' syntax to override)", 31);
        public static readonly ICompilerReferenceError CS0034 = new CompilerReferenceError(@"Operator {0} is ambiguous on operands of type {1} and {2}", 34);
        public static readonly ICompilerReferenceError CS0035 = new CompilerReferenceError(@"Operator {0} is ambiguous on an operand of type {1}", 35);
        public static readonly ICompilerReferenceError CS0036 = new CompilerReferenceError(@"An out parameter cannot have the '[In]' attribute", 36);
        public static readonly ICompilerReferenceError CS0037 = new CompilerReferenceError(@"Cannot convert null to {0} because it is a non-nullable value type", 37);
        public static readonly ICompilerReferenceError CS0038 = new CompilerReferenceError(@"Cannot access a nonstatic member of outer type {0} via nested type {1}", 38);
        public static readonly ICompilerReferenceError CS0039 = new CompilerReferenceError(@"Cannot convert type {0} to {1} via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion", 39);
        public static readonly ICompilerReferenceError CS0040 = new CompilerReferenceError(@"Unexpected error creating debug information file — {0}", 40);
        public static readonly ICompilerReferenceError CS0041 = new CompilerReferenceError(@"The fully qualified name for {0} is too long for debug information. Compile without '/debug' option.", 41);
        public static readonly ICompilerReferenceError CS0042 = new CompilerReferenceError(@"Unexpected error creating debug information file {0} — {1}", 42);
        public static readonly ICompilerReferenceError CS0043 = new CompilerReferenceError(@"PDB file {0} has an incorrect or out-of-date format. Delete it and rebuild.", 43);
        public static readonly ICompilerReferenceError CS0050 = new CompilerReferenceError(@"Inconsistent accessibility: return type {0} is less accessible than method {1}", 50);
        public static readonly ICompilerReferenceError CS0051 = new CompilerReferenceError(@"Inconsistent accessibility: parameter type {0} is less accessible than method {1}", 51);
        public static readonly ICompilerReferenceError CS0052 = new CompilerReferenceError(@"Inconsistent accessibility: field type {0} is less accessible than field {1}", 52);
        public static readonly ICompilerReferenceError CS0053 = new CompilerReferenceError(@"Inconsistent accessibility: property type {0} is less accessible than property {1}", 53);
        public static readonly ICompilerReferenceError CS0054 = new CompilerReferenceError(@"Inconsistent accessibility: indexer return type {0} is less accessible than indexer {1}", 54);
        public static readonly ICompilerReferenceError CS0055 = new CompilerReferenceError(@"Inconsistent accessibility: parameter type {0} is less accessible than indexer {1}", 55);
        public static readonly ICompilerReferenceError CS0056 = new CompilerReferenceError(@"Inconsistent accessibility: return type {0} is less accessible than operator {1}", 56);
        public static readonly ICompilerReferenceError CS0057 = new CompilerReferenceError(@"Inconsistent accessibility: parameter type {0} is less accessible than operator {1}", 57);
        public static readonly ICompilerReferenceError CS0058 = new CompilerReferenceError(@"Inconsistent accessibility: return type {0} is less accessible than delegate {1}", 58);
        public static readonly ICompilerReferenceError CS0059 = new CompilerReferenceError(@"Inconsistent accessibility: parameter type {0} is less accessible than delegate {1}", 59);
        public static readonly ICompilerReferenceError CS0060 = new CompilerReferenceError(@"Inconsistent accessibility: base class {0} is less accessible than class {1}", 60);
        public static readonly ICompilerReferenceError CS0061 = new CompilerReferenceError(@"Inconsistent accessibility: base interface {0} is less accessible than interface {1}", 61);
        public static readonly ICompilerReferenceError CS0065 = new CompilerReferenceError(@"{0}: event property must have both add and remove accessors", 65);
        public static readonly ICompilerReferenceError CS0066 = new CompilerReferenceError(@"{0}: event must be of a delegate type", 66);
        public static readonly ICompilerReferenceError CS0068 = new CompilerReferenceError(@"{0}: event in interface cannot have initializer", 68);
        public static readonly ICompilerReferenceError CS0069 = new CompilerReferenceError(@"An event in an interface cannot have add or remove accessors", 69);
        public static readonly ICompilerReferenceError CS0070 = new CompilerReferenceError(@"The event {0} can only appear on the left hand side of += or -= (except when used from within the type {1})", 70);
        public static readonly ICompilerReferenceError CS0071 = new CompilerReferenceError(@"An explicit interface implementation of an event must use event accessor syntax", 71);
        public static readonly ICompilerReferenceError CS0072 = new CompilerReferenceError(@"{0} : cannot override; {1} is not an event", 72);
        public static readonly ICompilerReferenceError CS0073 = new CompilerReferenceError(@"An add or remove accessor must have a body", 73);
        public static readonly ICompilerReferenceError CS0074 = new CompilerReferenceError(@"{0}: abstract event cannot have initializer", 74);
        public static readonly ICompilerReferenceError CS0075 = new CompilerReferenceError(@"To cast a negative value, you must enclose the value in parentheses", 75);
        public static readonly ICompilerReferenceError CS0076 = new CompilerReferenceError(@"The enumerator name 'value__' is reserved and cannot be used", 76);
        public static readonly ICompilerReferenceError CS0077 = new CompilerReferenceError(@"The as operator must be used with a reference type or nullable type ({0} is a non-nullable value type).", 77);
        public static readonly ICompilerReferenceError CS0079 = new CompilerReferenceError(@"The event {0} can only appear on the left hand side of += or -=", 79);
        public static readonly ICompilerReferenceError CS0080 = new CompilerReferenceError(@"Constraints are not allowed on non-generic declarations", 80);
        public static readonly ICompilerReferenceError CS0081 = new CompilerReferenceError(@"Type parameter declaration must be an identifier not a type", 81);
        public static readonly ICompilerReferenceError CS0082 = new CompilerReferenceError(@"Type {0} already reserves a member called {1} with the same parameter types", 82);
        public static readonly ICompilerReferenceError CS0100 = new CompilerReferenceError(@"The parameter name {0} is a duplicate", 100);
        public static readonly ICompilerReferenceError CS0101 = new CompilerReferenceError(@"The namespace {0} already contains a definition for {1}", 101);
        public static readonly ICompilerReferenceError CS0102 = new CompilerReferenceError(@"The type {0} already contains a definition for {1}", 102);
        public static readonly ICompilerReferenceError CS0103 = new CompilerReferenceError(@"The name {0} does not exist in the current context", 103);
        public static readonly ICompilerReferenceError CS0104 = new CompilerReferenceError(@"{0} is an ambiguous reference between {1} and {2}", 104);
        public static readonly ICompilerReferenceError CS0106 = new CompilerReferenceError(@"The modifier {0} is not valid for this item", 106);
        public static readonly ICompilerReferenceError CS0107 = new CompilerReferenceError(@"More than one protection modifier", 107);
        public static readonly ICompilerReferenceError CS0110 = new CompilerReferenceError(@"The evaluation of the constant value for {0} involves a circular definition", 110);
        public static readonly ICompilerReferenceError CS0111 = new CompilerReferenceError(@"Type {0} already defines a member called {1} with the same parameter types", 111);
        public static readonly ICompilerReferenceError CS0112 = new CompilerReferenceError(@"A static member {0} cannot be marked as override, virtual or abstract", 112);
        public static readonly ICompilerReferenceError CS0113 = new CompilerReferenceError(@"A member {0} marked as override cannot be marked as new or virtual", 113);
        public static readonly ICompilerReferenceError CS0115 = new CompilerReferenceError(@"{0} : no suitable method found to override", 115);
        public static readonly ICompilerReferenceError CS0116 = new CompilerReferenceError(@"A namespace does not directly contain members such as fields or methods", 116);
        public static readonly ICompilerReferenceError CS0117 = new CompilerReferenceError(@"{0} does not contain a definition for 'identifier'", 117);
        public static readonly ICompilerReferenceError CS0118 = new CompilerReferenceError(@"{0} is a {1} but is used like a {2}", 118);
        public static readonly ICompilerReferenceError CS0119 = new CompilerReferenceError(@"{0} is a {1}, which is not valid in the given context.", 119);
        public static readonly ICompilerReferenceError CS0120 = new CompilerReferenceError(@"An object reference is required for the nonstatic field, method, or property {0}", 120);
        public static readonly ICompilerReferenceError CS0121 = new CompilerReferenceError(@"The call is ambiguous between the following methods or properties: {0} and {1}", 121);
        public static readonly ICompilerReferenceError CS0122 = new CompilerReferenceError(@"{0} is inaccessible due to its protection level", 122);
        public static readonly ICompilerReferenceError CS0123 = new CompilerReferenceError(@"No overload for {0} matches delegate {1}", 123);
        public static readonly ICompilerReferenceError CS0126 = new CompilerReferenceError(@"An object of a type convertible to {0} is required", 126);
        public static readonly ICompilerReferenceError CS0127 = new CompilerReferenceError(@"Since {0} returns void, a return keyword must not be followed by an object expression", 127);
        public static readonly ICompilerReferenceError CS0128 = new CompilerReferenceError(@"A local variable named {0} is already defined in this scope", 128);
        public static readonly ICompilerReferenceError CS0131 = new CompilerReferenceError(@"The left-hand side of an assignment must be a variable, property or indexer", 131);
        public static readonly ICompilerReferenceError CS0132 = new CompilerReferenceError(@"{0} : a static constructor must be parameterless", 132);
        public static readonly ICompilerReferenceError CS0133 = new CompilerReferenceError(@"The expression being assigned to {0} must be constant", 133);
        public static readonly ICompilerReferenceError CS0134 = new CompilerReferenceError(@"{0} is of type {1}. A const field of a reference type other than string can only be initialized with null.", 134);
        public static readonly ICompilerReferenceError CS0135 = new CompilerReferenceError(@"{0} conflicts with the declaration {1}", 135);
        public static readonly ICompilerReferenceError CS0136 = new CompilerReferenceError(@"A local variable named {0} cannot be declared in this scope because it would give a different meaning to {0}, which is already used in a 'parent or current/child' scope to denote something else", 136);
        public static readonly ICompilerReferenceError CS0138 = new CompilerReferenceError(@"A using namespace directive can only be applied to namespaces; {0} is a type not a namespace", 138);
        public static readonly ICompilerReferenceError CS0139 = new CompilerReferenceError(@"No enclosing loop out of which to break or continue", 139);
        public static readonly ICompilerReferenceError CS0140 = new CompilerReferenceError(@"The label {0} is a duplicate", 140);
        public static readonly ICompilerReferenceError CS0143 = new CompilerReferenceError(@"The type {0} has no constructors defined", 143);
        public static readonly ICompilerReferenceError CS0144 = new CompilerReferenceError(@"Cannot create an instance of the abstract class or interface {0}", 144);
        public static readonly ICompilerReferenceError CS0145 = new CompilerReferenceError(@"A const field requires a value to be provided", 145);
        public static readonly ICompilerReferenceError CS0146 = new CompilerReferenceError(@"Circular base class dependency involving {0} and {1}", 146);
        public static readonly ICompilerReferenceError CS0148 = new CompilerReferenceError(@"The delegate {0} does not have a valid constructor", 148);
        public static readonly ICompilerReferenceError CS0149 = new CompilerReferenceError(@"Method name expected", 149);
        public static readonly ICompilerReferenceError CS0150 = new CompilerReferenceError(@"A constant value is expected", 150);
        public static readonly ICompilerReferenceError CS0151 = new CompilerReferenceError(@"A value of an integral type expected", 151);
        public static readonly ICompilerReferenceError CS0152 = new CompilerReferenceError(@"The label {0} already occurs in this switch statement", 152);
        public static readonly ICompilerReferenceError CS0153 = new CompilerReferenceError(@"A goto case is only valid inside a switch statement", 153);
        public static readonly ICompilerReferenceError CS0154 = new CompilerReferenceError(@"The property or indexer 'property' cannot be used in this context because it lacks the get accessor", 154);
        public static readonly ICompilerReferenceError CS0155 = new CompilerReferenceError(@"The type caught or thrown must be derived from System.Exception", 155);
        public static readonly ICompilerReferenceError CS0156 = new CompilerReferenceError(@"A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause", 156);
        public static readonly ICompilerReferenceError CS0157 = new CompilerReferenceError(@"Control cannot leave the body of a finally clause", 157);
        public static readonly ICompilerReferenceError CS0158 = new CompilerReferenceError(@"The label {0} shadows another label by the same name in a contained scope", 158);
        public static readonly ICompilerReferenceError CS0159 = new CompilerReferenceError(@"No such label {0} within the scope of the goto statement", 159);
        public static readonly ICompilerReferenceError CS0160 = new CompilerReferenceError(@"A previous catch clause already catches all exceptions of this or of a super type ({0})", 160);
        public static readonly ICompilerReferenceError CS0161 = new CompilerReferenceError(@"{0}: not all code paths return a value", 161);
        public static readonly ICompilerReferenceError CS0163 = new CompilerReferenceError(@"Control cannot fall through from one case label ({0}) to another", 163);
        public static readonly ICompilerReferenceError CS0165 = new CompilerReferenceError(@"Use of unassigned local variable {0}", 165);
        public static readonly ICompilerReferenceError CS0167 = new CompilerReferenceError(@"The delegate {0} is missing the Invoke method", 167);
        public static readonly ICompilerReferenceError CS0170 = new CompilerReferenceError(@"Use of possibly unassigned field {0}", 170);
        public static readonly ICompilerReferenceError CS0171 = new CompilerReferenceError(@"Backing field for automatically implemented property {0} must be fully assigned before control is returned to the caller. Consider calling the default constructor from a constructor initializer.", 171);
        public static readonly ICompilerReferenceError CS0172 = new CompilerReferenceError(@"Type of conditional expression cannot be determined because {0} and {1} implicitly convert to one another", 172);
        public static readonly ICompilerReferenceError CS0173 = new CompilerReferenceError(@"Type of conditional expression cannot be determined because there is no implicit conversion between {0} and {1}", 173);
        public static readonly ICompilerReferenceError CS0174 = new CompilerReferenceError(@"A base class is required for a 'base' reference", 174);
        public static readonly ICompilerReferenceError CS0175 = new CompilerReferenceError(@"Use of keyword 'base' is not valid in this context", 175);
        public static readonly ICompilerReferenceError CS0176 = new CompilerReferenceError(@"Static member {0} cannot be accessed with an instance reference; qualify it with a type name instead", 176);
        public static readonly ICompilerReferenceError CS0177 = new CompilerReferenceError(@"The out parameter {0} must be assigned to before control leaves the current method", 177);
        public static readonly ICompilerReferenceError CS0178 = new CompilerReferenceError(@"Invalid rank specifier: expected ',' or ']'", 178);
        public static readonly ICompilerReferenceError CS0179 = new CompilerReferenceError(@"{0} cannot be extern and declare a body", 179);
        public static readonly ICompilerReferenceError CS0180 = new CompilerReferenceError(@"{0} cannot be both extern and abstract", 180);
        public static readonly ICompilerReferenceError CS0182 = new CompilerReferenceError(@"An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type", 182);
        public static readonly ICompilerReferenceError CS0185 = new CompilerReferenceError(@"{0} is not a reference type as required by the lock statement", 185);
        public static readonly ICompilerReferenceError CS0186 = new CompilerReferenceError(@"Use of null is not valid in this context ", 186);
        public static readonly ICompilerReferenceError CS0188 = new CompilerReferenceError(@"The 'this' object cannot be used before all of its fields are assigned to", 188);
        public static readonly ICompilerReferenceError CS0191 = new CompilerReferenceError(@"Property or indexer {0} cannot be assigned to -- it is read only", 191);
        public static readonly ICompilerReferenceError CS0192 = new CompilerReferenceError(@"Fields of static readonly field {0} cannot be passed ref or out (except in a static constructor)", 192);
        public static readonly ICompilerReferenceError CS0193 = new CompilerReferenceError(@"The * or -> operator must be applied to a pointer", 193);
        public static readonly ICompilerReferenceError CS0196 = new CompilerReferenceError(@"A pointer must be indexed by only one value", 196);
        public static readonly ICompilerReferenceError CS0198 = new CompilerReferenceError(@"Fields of static readonly field {0} cannot be assigned to (except in a static constructor or a variable initializer)", 198);
        public static readonly ICompilerReferenceError CS0199 = new CompilerReferenceError(@"Fields of static readonly field {0} cannot be passed ref or out (except in a static constructor)", 199);
        public static readonly ICompilerReferenceError CS0200 = new CompilerReferenceError(@"Property or indexer {0} cannot be assigned to — it is read only", 200);
        public static readonly ICompilerReferenceError CS0201 = new CompilerReferenceError(@"Only assignment, call, increment, decrement, and new object expressions can be used as a statement", 201);
        public static readonly ICompilerReferenceError CS0202 = new CompilerReferenceError(@"foreach requires that the return type {0} of '{1}.GetEnumerator()' must have a suitable public MoveNext method and public Current property", 202);
        public static readonly ICompilerReferenceError CS0204 = new CompilerReferenceError(@"Only 65534 locals are allowed", 204);
        public static readonly ICompilerReferenceError CS0205 = new CompilerReferenceError(@"Cannot call an abstract base member: {0}", 205);
        public static readonly ICompilerReferenceError CS0206 = new CompilerReferenceError(@"A property or indexer may not be passed as an out or ref parameter", 206);
        public static readonly ICompilerReferenceError CS0208 = new CompilerReferenceError(@"Cannot take the address of, get the size of, or declare a pointer to a managed type ({0})", 208);
        public static readonly ICompilerReferenceError CS0209 = new CompilerReferenceError(@"The type of local declared in a fixed statement must be a pointer type", 209);
        public static readonly ICompilerReferenceError CS0210 = new CompilerReferenceError(@"You must provide an initializer in a fixed or using statement declaration", 210);
        public static readonly ICompilerReferenceError CS0211 = new CompilerReferenceError(@"Cannot take the address of the given expression", 211);
        public static readonly ICompilerReferenceError CS0212 = new CompilerReferenceError(@"You can only take the address of an unfixed expression inside of a fixed statement initializer", 212);
        public static readonly ICompilerReferenceError CS0213 = new CompilerReferenceError(@"You cannot use the fixed statement to take the address of an already fixed expression", 213);
        public static readonly ICompilerReferenceError CS0214 = new CompilerReferenceError(@"Pointers and fixed size buffers may only be used in an unsafe context", 214);
        public static readonly ICompilerReferenceError CS0215 = new CompilerReferenceError(@"The return type of operator True or False must be bool", 215);
        public static readonly ICompilerReferenceError CS0216 = new CompilerReferenceError(@"The operator {0} requires a matching operator {1} to also be defined", 216);
        public static readonly ICompilerReferenceError CS0217 = new CompilerReferenceError(@"In order to be applicable as a short circuit operator a user-defined logical operator ({0}) must have the same return type as the type of its 2 parameters.", 217);
        public static readonly ICompilerReferenceError CS0218 = new CompilerReferenceError(@"The type ({0}) must contain declarations of operator true and operator false", 218);
        public static readonly ICompilerReferenceError CS0220 = new CompilerReferenceError(@"The operation overflows at compile time in checked mode", 220);
        public static readonly ICompilerReferenceError CS0221 = new CompilerReferenceError(@"Constant value {0} cannot be converted to a {1} (use 'unchecked' syntax to override)", 221);
        public static readonly ICompilerReferenceError CS0225 = new CompilerReferenceError(@"The params parameter must be a single dimensional array", 225);
        public static readonly ICompilerReferenceError CS0226 = new CompilerReferenceError(@"An __arglist expression may only appear inside of a call or new expression.", 226);
        public static readonly ICompilerReferenceError CS0227 = new CompilerReferenceError(@"Unsafe code may only appear if compiling with /unsafe", 227);
        public static readonly ICompilerReferenceError CS0228 = new CompilerReferenceError(@"{0} does not contain a definition for {1}, or it is not accessible", 228);
        public static readonly ICompilerReferenceError CS0229 = new CompilerReferenceError(@"Ambiguity between {0} and {1}", 229);
        public static readonly ICompilerReferenceError CS0230 = new CompilerReferenceError(@"Type and identifier are both required in a foreach statement", 230);
        public static readonly ICompilerReferenceError CS0231 = new CompilerReferenceError(@"A params parameter must be the last parameter in a formal parameter list.", 231);
        public static readonly ICompilerReferenceError CS0233 = new CompilerReferenceError(@"{0} does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf)", 233);
        public static readonly ICompilerReferenceError CS0234 = new CompilerReferenceError(@"The type or namespace name {0} does not exist in the namespace {1} (are you missing an assembly reference?)", 234);
        public static readonly ICompilerReferenceError CS0236 = new CompilerReferenceError(@"A field initializer cannot reference the nonstatic field, method, or property {0}", 236);
        public static readonly ICompilerReferenceError CS0238 = new CompilerReferenceError(@"{0} cannot be sealed because it is not an override", 238);
        public static readonly ICompilerReferenceError CS0239 = new CompilerReferenceError(@"{0} : cannot override inherited member {1} because it is sealed", 239);
        public static readonly ICompilerReferenceError CS0241 = new CompilerReferenceError(@"Default parameter specifiers are not permitted", 241);
        public static readonly ICompilerReferenceError CS0242 = new CompilerReferenceError(@"The operation in question is undefined on void pointers", 242);
        public static readonly ICompilerReferenceError CS0243 = new CompilerReferenceError(@"The Conditional attribute is not valid on 'method' because it is an override method", 243);
        public static readonly ICompilerReferenceError CS0244 = new CompilerReferenceError(@"Neither 'is' nor 'as' is valid on pointer types", 244);
        public static readonly ICompilerReferenceError CS0245 = new CompilerReferenceError(@"Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available.", 245);
        public static readonly ICompilerReferenceError CS0246 = new CompilerReferenceError(@"The type or namespace name {0} could not be found (are you missing a using directive or an assembly reference?)", 246);
        public static readonly ICompilerReferenceError CS0247 = new CompilerReferenceError(@"Cannot use a negative size with stackalloc", 247);
        public static readonly ICompilerReferenceError CS0248 = new CompilerReferenceError(@"Cannot create an array with a negative size", 248);
        public static readonly ICompilerReferenceError CS0249 = new CompilerReferenceError(@"Do not override object.Finalize. Instead, provide a destructor.", 249);
        public static readonly ICompilerReferenceError CS0250 = new CompilerReferenceError(@"Do not directly call your base class Finalize method. It is called automatically from your destructor.", 250);
        public static readonly ICompilerReferenceError CS0254 = new CompilerReferenceError(@"The right hand side of a fixed statement assignment may not be a cast expression", 254);
        public static readonly ICompilerReferenceError CS0255 = new CompilerReferenceError(@"stackalloc may not be used in a catch or finally block", 255);
        public static readonly ICompilerReferenceError CS0260 = new CompilerReferenceError(@"Missing partial modifier on declaration of type {0}; another partial declaration of this type exists", 260);
        public static readonly ICompilerReferenceError CS0261 = new CompilerReferenceError(@"Partial declarations of {0} must be all classes, all structs, or all interfaces", 261);
        public static readonly ICompilerReferenceError CS0262 = new CompilerReferenceError(@"Partial declarations of {0} have conflicting accessibility modifiers", 262);
        public static readonly ICompilerReferenceError CS0263 = new CompilerReferenceError(@"Partial declarations of {0} must not specify different base classes", 263);
        public static readonly ICompilerReferenceError CS0264 = new CompilerReferenceError(@"Partial declarations of {0} must have the same type parameter names in the same order", 264);
        public static readonly ICompilerReferenceError CS0265 = new CompilerReferenceError(@"Partial declarations of {0} have inconsistent constraints for type parameter {1}", 265);
        public static readonly ICompilerReferenceError CS0266 = new CompilerReferenceError(@"Cannot implicitly convert type {0} to {1}. An explicit conversion exists (are you missing a cast?)", 266);
        public static readonly ICompilerReferenceError CS0267 = new CompilerReferenceError(@"The partial modifier can only appear immediately before 'class', 'struct', or 'interface'", 267);
        public static readonly ICompilerReferenceError CS0268 = new CompilerReferenceError(@"Imported type {0} is invalid. It contains a circular base class dependency.", 268);
        public static readonly ICompilerReferenceError CS0269 = new CompilerReferenceError(@"Use of unassigned out parameter {0}", 269);
        public static readonly ICompilerReferenceError CS0270 = new CompilerReferenceError(@"Array size cannot be specified in a variable declaration (try initializing with a 'new' expression)", 270);
        public static readonly ICompilerReferenceError CS0271 = new CompilerReferenceError(@"The property or indexer {0} cannot be used in this context because the get accessor is inaccessible", 271);
        public static readonly ICompilerReferenceError CS0272 = new CompilerReferenceError(@"The property or indexer {0} cannot be used in this context because the set accessor is inaccessible", 272);
        public static readonly ICompilerReferenceError CS0273 = new CompilerReferenceError(@"The accessibility modifier of the {0} accessor must be more restrictive than the property or indexer {1}", 273);
        public static readonly ICompilerReferenceError CS0274 = new CompilerReferenceError(@"Cannot specify accessibility modifiers for both accessors of the property or indexer {0}", 274);
        public static readonly ICompilerReferenceError CS0275 = new CompilerReferenceError(@"{0}: accessibility modifiers may not be used on accessors in an interface", 275);
        public static readonly ICompilerReferenceError CS0276 = new CompilerReferenceError(@"{0}: accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor", 276);
        public static readonly ICompilerReferenceError CS0277 = new CompilerReferenceError(@"{0} does not implement interface member {1}. {2} is not public", 277);
        public static readonly ICompilerReferenceError CS0281 = new CompilerReferenceError(@"Friend access was granted to {0}, but the output assembly is named {1}. Try adding a reference to {0} or changing the output assembly name to match.", 281);
        public static readonly ICompilerReferenceError CS0283 = new CompilerReferenceError(@"The type {0} cannot be declared const", 283);
        public static readonly ICompilerReferenceError CS0304 = new CompilerReferenceError(@"Cannot create an instance of the variable type {0} because it does not have the new() constraint", 304);
        public static readonly ICompilerReferenceError CS0305 = new CompilerReferenceError(@"Using the generic type {0} requires {1} type arguments", 305);
        public static readonly ICompilerReferenceError CS0306 = new CompilerReferenceError(@"The type {0} may not be used as a type argument", 306);
        public static readonly ICompilerReferenceError CS0307 = new CompilerReferenceError(@"The {0} {1} is not a generic method. If you intended an expression list, use parentheses around the < expression.", 307);
        public static readonly ICompilerReferenceError CS0308 = new CompilerReferenceError(@"The non-generic type-or-method {0} cannot be used with type arguments.", 308);
        public static readonly ICompilerReferenceError CS0310 = new CompilerReferenceError(@"The type {0} must be a non-abstract type with a public parameterless constructor in order to use it as parameter {1} in the generic type or method {2}", 310);
        public static readonly ICompilerReferenceError CS0311 = new CompilerReferenceError(@"The type {0} cannot be used as type parameter {2} in the generic type or method {3}. There is no implicit reference conversion from {0} to {1}.", 311);
        public static readonly ICompilerReferenceError CS0312 = new CompilerReferenceError(@"The type {0} cannot be used as type parameter 'name' in the generic type or method 'name'. The nullable type 'type1' does not satisfy the constraint of 'type2'.", 312);
        public static readonly ICompilerReferenceError CS0313 = new CompilerReferenceError(@"The type {0} cannot be used as type parameter 'parameter name' in the generic type or method 'type2'. The nullable type 'type1' does not satisfy the constraint of 'type2'. Nullable types cannot satisfy any interface constraints.", 313);
        public static readonly ICompilerReferenceError CS0314 = new CompilerReferenceError(@"The type {0} cannot be used as type parameter 'name' in the generic type or method 'name'. There is no boxing conversion or type parameter conversion from 'type1' to 'type2'.", 314);
        public static readonly ICompilerReferenceError CS0315 = new CompilerReferenceError(@"The type {0} cannot be used as type parameter 'T' in the generic type or method 'TypeorMethod<T>'. There is no boxing conversion from 'valueType' to 'referenceType'.", 315);
        public static readonly ICompilerReferenceError CS0316 = new CompilerReferenceError(@"The parameter name {0} conflicts with an automatically-generated parameter name.", 316);
        public static readonly ICompilerReferenceError CS0400 = new CompilerReferenceError(@"The type or namespace name {0} could not be found in the global namespace (are you missing an assembly reference?)", 400);
        public static readonly ICompilerReferenceError CS0401 = new CompilerReferenceError(@"The new() constraint must be the last constraint specified", 401);
        public static readonly ICompilerReferenceError CS0403 = new CompilerReferenceError(@"Cannot convert null to type parameter {0} because it could be a non-nullable value type. Consider using default({0}) instead.", 403);
        public static readonly ICompilerReferenceError CS0404 = new CompilerReferenceError(@"'<' unexpected : attributes cannot be generic", 404);
        public static readonly ICompilerReferenceError CS0405 = new CompilerReferenceError(@"Duplicate constraint {0} for type parameter {1}", 405);
        public static readonly ICompilerReferenceError CS0406 = new CompilerReferenceError(@"The class type constraint 'constraint' must come before any other constraints", 406);
        public static readonly ICompilerReferenceError CS0407 = new CompilerReferenceError(@"'return-type method' has the wrong return type", 407);
        public static readonly ICompilerReferenceError CS0409 = new CompilerReferenceError(@"A constraint clause has already been specified for type parameter 'type parameter'. All of the constraints for a type parameter must be specified in a single where clause.", 409);
        public static readonly ICompilerReferenceError CS0410 = new CompilerReferenceError(@"No overload for 'method' has the correct parameter and return types", 410);
        public static readonly ICompilerReferenceError CS0411 = new CompilerReferenceError(@"The type arguments for method 'method' cannot be inferred from the usage. Try specifying the type arguments explicitly.", 411);
        public static readonly ICompilerReferenceError CS0412 = new CompilerReferenceError(@"'generic': a parameter or local variable cannot have the same name as a method type parameter", 412);
        public static readonly ICompilerReferenceError CS0413 = new CompilerReferenceError(@"The type parameter 'type parameter' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint", 413);
        public static readonly ICompilerReferenceError CS0415 = new CompilerReferenceError(@"The 'IndexerName' attribute is valid only on an indexer that is not an explicit interface member declaration", 415);
        public static readonly ICompilerReferenceError CS0416 = new CompilerReferenceError(@"'type parameter': an attribute argument cannot use type parameters", 416);
        public static readonly ICompilerReferenceError CS0417 = new CompilerReferenceError(@"'identifier': cannot provide arguments when creating an instance of a variable type", 417);
        public static readonly ICompilerReferenceError CS0418 = new CompilerReferenceError(@"'class name': an abstract class cannot be sealed or static", 418);
        public static readonly ICompilerReferenceError CS0423 = new CompilerReferenceError(@"Since 'class' has the ComImport attribute, 'method' must be extern or abstract", 423);
        public static readonly ICompilerReferenceError CS0424 = new CompilerReferenceError(@"'class': a class with the ComImport attribute cannot specify a base class", 424);
        public static readonly ICompilerReferenceError CS0425 = new CompilerReferenceError(@"The constraints for type parameter 'type parameter' of method 'method' must match the constraints for type parameter 'type parameter' of interface method 'method'. Consider using an explicit interface implementation instead.", 425);
        public static readonly ICompilerReferenceError CS0426 = new CompilerReferenceError(@"The type name 'identifier' does not exist in the type 'type'", 426);
        public static readonly ICompilerReferenceError CS0428 = new CompilerReferenceError(@"Cannot convert method group 'Identifier' to non-delegate type 'type'. Did you intend to invoke the method?", 428);
        public static readonly ICompilerReferenceError CS0430 = new CompilerReferenceError(@"The extern alias 'alias' was not specified in a /reference option", 430);
        public static readonly ICompilerReferenceError CS0431 = new CompilerReferenceError(@"Cannot use alias 'identifier' with '::' since the alias references a type. Use '.' instead.", 431);
        public static readonly ICompilerReferenceError CS0432 = new CompilerReferenceError(@"Alias 'identifier' not found", 432);
        public static readonly ICompilerReferenceError CS0433 = new CompilerReferenceError(@"The type TypeName1 exists in both TypeName2 and TypeName3", 433);
        public static readonly ICompilerReferenceError CS0434 = new CompilerReferenceError(@"The namespace NamespaceName1 in NamespaceName2 conflicts with the type TypeName1 in NamespaceName3", 434);
        public static readonly ICompilerReferenceError CS0438 = new CompilerReferenceError(@"The type 'type' in 'module_1' conflicts with the namespace 'namespace' in 'module_2'.", 438);
        public static readonly ICompilerReferenceError CS0439 = new CompilerReferenceError(@"An extern alias declaration must precede all other elements defined in the namespace", 439);
        public static readonly ICompilerReferenceError CS0441 = new CompilerReferenceError(@"'class': a class cannot be both static and sealed", 441);
        public static readonly ICompilerReferenceError CS0442 = new CompilerReferenceError(@"'Property': abstract properties cannot have private accessors", 442);
        public static readonly ICompilerReferenceError CS0443 = new CompilerReferenceError(@"Syntax error, value expected", 443);
        public static readonly ICompilerReferenceError CS0445 = new CompilerReferenceError(@"Cannot modify the result of an unboxing conversion", 445);
        public static readonly ICompilerReferenceError CS0446 = new CompilerReferenceError(@"Foreach cannot operate on a 'Method or Delegate'. Did you intend to invoke the 'Method or Delegate'?", 446);
        public static readonly ICompilerReferenceError CS0447 = new CompilerReferenceError(@"Attributes cannot be used on type arguments, only on type parameters", 447);
        public static readonly ICompilerReferenceError CS0448 = new CompilerReferenceError(@"The return type for ++ or -- operator must be the containing type or derived from the containing type", 448);
        public static readonly ICompilerReferenceError CS0449 = new CompilerReferenceError(@"The 'class' or 'struct' constraint must come before any other constraints", 449);
        public static readonly ICompilerReferenceError CS0450 = new CompilerReferenceError(@"'Type Parameter Name': cannot specify both a constraint class and the 'class' or 'struct' constraint", 450);
        public static readonly ICompilerReferenceError CS0451 = new CompilerReferenceError(@"The 'new()' constraint cannot be used with the 'struct' constraint", 451);
        public static readonly ICompilerReferenceError CS0452 = new CompilerReferenceError(@"The type 'type name' must be a reference type in order to use it as parameter 'parameter name' in the generic type or method 'identifier of generic'", 452);
        public static readonly ICompilerReferenceError CS0453 = new CompilerReferenceError(@"The type 'Type Name' must be a non-nullable value type in order to use it as parameter 'Parameter Name' in the generic type or method 'Generic Identifier'", 453);
        public static readonly ICompilerReferenceError CS0454 = new CompilerReferenceError(@"Circular constraint dependency involving 'Type Parameter 1' and 'Type Parameter 2'", 454);
        public static readonly ICompilerReferenceError CS0455 = new CompilerReferenceError(@"Type parameter 'Type Parameter Name' inherits conflicting constraints 'Constraint Name 1' and 'Constraint Name 2'", 455);
        public static readonly ICompilerReferenceError CS0456 = new CompilerReferenceError(@"Type parameter 'Type Parameter Name 1' has the 'struct' constraint so 'Type Parameter Name 1' cannot be used as a constraint for 'Type Parameter Name 2'", 456);
        public static readonly ICompilerReferenceError CS0457 = new CompilerReferenceError(@"Ambiguous user defined conversions 'Conversion method name 1' and 'Conversion method name 2' when converting from 'type name 1' to 'type name 2'", 457);
        public static readonly ICompilerReferenceError CS0459 = new CompilerReferenceError(@"Cannot take the address of a read-only local variable", 459);
        public static readonly ICompilerReferenceError CS0460 = new CompilerReferenceError(@"Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly", 460);
        public static readonly ICompilerReferenceError CS0462 = new CompilerReferenceError(@"The inherited members 'member1' and 'member2' have the same signature in type 'type', so they cannot be overridden", 462);
        public static readonly ICompilerReferenceError CS0463 = new CompilerReferenceError(@"Evaluation of the decimal constant expression failed with error: 'error'", 463);
        public static readonly ICompilerReferenceError CS0466 = new CompilerReferenceError(@"'method1' should not have a params parameter since 'method2' does not", 466);
        public static readonly ICompilerReferenceError CS0468 = new CompilerReferenceError(@"Ambiguity between type 'type1' and type 'type2'", 468);
        public static readonly ICompilerReferenceError CS0470 = new CompilerReferenceError(@"Method 'method' cannot implement interface accessor 'accessor' for type 'type'. Use an explicit interface implementation.", 470);
        public static readonly ICompilerReferenceError CS0471 = new CompilerReferenceError(@"The method 'name' is not a generic method. If you intended an expression list, use parentheses around the < expression.", 471);
        public static readonly ICompilerReferenceError CS0473 = new CompilerReferenceError(@"Explicit interface implementation 'method name' matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead.", 473);
        public static readonly ICompilerReferenceError CS0500 = new CompilerReferenceError(@"'class member' cannot declare a body because it is marked abstract", 500);
        public static readonly ICompilerReferenceError CS0501 = new CompilerReferenceError(@"'member function' must declare a body because it is not marked abstract, extern, or partial", 501);
        public static readonly ICompilerReferenceError CS0502 = new CompilerReferenceError(@"'member' cannot be both abstract and sealed", 502);
        public static readonly ICompilerReferenceError CS0503 = new CompilerReferenceError(@"The abstract method 'method' cannot be marked virtual", 503);
        public static readonly ICompilerReferenceError CS0504 = new CompilerReferenceError(@"The constant 'variable' cannot be marked static", 504);
        public static readonly ICompilerReferenceError CS0505 = new CompilerReferenceError(@"'member1': cannot override because 'member2' is not a function", 505);
        public static readonly ICompilerReferenceError CS0506 = new CompilerReferenceError(@"'function1' : cannot override inherited member 'function2' because it is not marked ""virtual"", ""abstract"", or ""override""", 506);
        public static readonly ICompilerReferenceError CS0507 = new CompilerReferenceError(@"'function1' : cannot change access modifiers when overriding 'access' inherited member 'function2'", 507);
        public static readonly ICompilerReferenceError CS0508 = new CompilerReferenceError(@"'Type 1': return type must be 'Type 2' to match overridden member 'Member Name'", 508);
        public static readonly ICompilerReferenceError CS0509 = new CompilerReferenceError(@"'class1' : cannot derive from sealed type 'class2'", 509);
        public static readonly ICompilerReferenceError CS0513 = new CompilerReferenceError(@"'function' is abstract but it is contained in nonabstract class 'class'", 513);
        public static readonly ICompilerReferenceError CS0514 = new CompilerReferenceError(@"'constructor' : static constructor cannot have an explicit 'this' or 'base' constructor call", 514);
        public static readonly ICompilerReferenceError CS0515 = new CompilerReferenceError(@"'function' : access modifiers are not allowed on static constructors", 515);
        public static readonly ICompilerReferenceError CS0516 = new CompilerReferenceError(@"Constructor 'constructor' can not call itself", 516);
        public static readonly ICompilerReferenceError CS0517 = new CompilerReferenceError(@"'class' has no base class and cannot call a base constructor", 517);
        public static readonly ICompilerReferenceError CS0518 = new CompilerReferenceError(@"Predefined type 'type' is not defined or imported", 518);
        public static readonly ICompilerReferenceError CS0520 = new CompilerReferenceError(@"Predefined type 'name' is declared incorrectly", 520);
        public static readonly ICompilerReferenceError CS0522 = new CompilerReferenceError(@"'constructor' : structs cannot call base class constructors", 522);
        public static readonly ICompilerReferenceError CS0523 = new CompilerReferenceError(@"Struct member 'struct2 field' of type 'struct1' causes a cycle in the struct layout", 523);
        public static readonly ICompilerReferenceError CS0524 = new CompilerReferenceError(@"'type' : interfaces cannot declare types", 524);
        public static readonly ICompilerReferenceError CS0525 = new CompilerReferenceError(@"Interfaces cannot contain fields", 525);
        public static readonly ICompilerReferenceError CS0526 = new CompilerReferenceError(@"Interfaces cannot contain constructors", 526);
        public static readonly ICompilerReferenceError CS0527 = new CompilerReferenceError(@"Type 'type' in interface list is not an interface", 527);
        public static readonly ICompilerReferenceError CS0528 = new CompilerReferenceError(@"'interface' is already listed in interface list", 528);
        public static readonly ICompilerReferenceError CS0529 = new CompilerReferenceError(@"Inherited interface 'interface1' causes a cycle in the interface hierarchy of 'interface2'", 529);
        public static readonly ICompilerReferenceError CS0531 = new CompilerReferenceError(@"'member' : interface members cannot have a definition", 531);
        public static readonly ICompilerReferenceError CS0533 = new CompilerReferenceError(@"'derived-class member' hides inherited abstract member 'base-class member'", 533);
        public static readonly ICompilerReferenceError CS0534 = new CompilerReferenceError(@"'function1' does not implement inherited abstract member 'function2'", 534);
        public static readonly ICompilerReferenceError CS0535 = new CompilerReferenceError(@"'class' does not implement interface member 'member'", 535);
        public static readonly ICompilerReferenceError CS0537 = new CompilerReferenceError(@"The class System.Object cannot have a base class or implement an interface", 537);
        public static readonly ICompilerReferenceError CS0538 = new CompilerReferenceError(@"'name' in explicit interface declaration is not an interface", 538);
        public static readonly ICompilerReferenceError CS0539 = new CompilerReferenceError(@"'member' in explicit interface declaration is not a member of interface", 539);
        public static readonly ICompilerReferenceError CS0540 = new CompilerReferenceError(@"'interface member' : containing type does not implement interface 'interface'", 540);
        public static readonly ICompilerReferenceError CS0541 = new CompilerReferenceError(@"'declaration' : explicit interface declaration can only be declared in a class or struct", 541);
        public static readonly ICompilerReferenceError CS0542 = new CompilerReferenceError(@"'user-defined type' : member names cannot be the same as their enclosing type", 542);
        public static readonly ICompilerReferenceError CS0543 = new CompilerReferenceError(@"'enumeration' : the enumerator value is too large to fit in its type", 543);
        public static readonly ICompilerReferenceError CS0544 = new CompilerReferenceError(@"'property override': cannot override because 'non-property' is not a property", 544);
        public static readonly ICompilerReferenceError CS0545 = new CompilerReferenceError(@"'function' : cannot override because 'property' does not have an overridable get accessor", 545);
        public static readonly ICompilerReferenceError CS0546 = new CompilerReferenceError(@"'accessor' : cannot override because 'property' does not have an overridable set accessor", 546);
        public static readonly ICompilerReferenceError CS0547 = new CompilerReferenceError(@"'property' : property or indexer cannot have void type", 547);
        public static readonly ICompilerReferenceError CS0548 = new CompilerReferenceError(@"'property' : property or indexer must have at least one accessor", 548);
        public static readonly ICompilerReferenceError CS0549 = new CompilerReferenceError(@"'function' is a new virtual member in sealed class 'class'", 549);
        public static readonly ICompilerReferenceError CS0550 = new CompilerReferenceError(@"'accessor' adds an accessor not found in interface member 'property'", 550);
        public static readonly ICompilerReferenceError CS0551 = new CompilerReferenceError(@"Explicit interface implementation 'implementation' is missing accessor 'accessor'", 551);
        public static readonly ICompilerReferenceError CS0552 = new CompilerReferenceError(@"'conversion routine' : user defined conversion to/from interface", 552);
        public static readonly ICompilerReferenceError CS0553 = new CompilerReferenceError(@"'conversion routine' : user defined conversion to/from base class", 553);
        public static readonly ICompilerReferenceError CS0554 = new CompilerReferenceError(@"'conversion routine' : user defined conversion to/from derived class", 554);
        public static readonly ICompilerReferenceError CS0555 = new CompilerReferenceError(@"User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type", 555);
        public static readonly ICompilerReferenceError CS0556 = new CompilerReferenceError(@"User-defined conversion must convert to or from the enclosing type", 556);
        public static readonly ICompilerReferenceError CS0557 = new CompilerReferenceError(@"Duplicate user-defined conversion in type 'class'", 557);
        public static readonly ICompilerReferenceError CS0558 = new CompilerReferenceError(@"User-defined operator 'operator' must be declared static and public", 558);
        public static readonly ICompilerReferenceError CS0559 = new CompilerReferenceError(@"The parameter type for ++ or -- operator must be the containing type", 559);
        public static readonly ICompilerReferenceError CS0562 = new CompilerReferenceError(@"The parameter of a unary operator must be the containing type", 562);
        public static readonly ICompilerReferenceError CS0563 = new CompilerReferenceError(@"One of the parameters of a binary operator must be the containing type", 563);
        public static readonly ICompilerReferenceError CS0564 = new CompilerReferenceError(@"The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int", 564);
        public static readonly ICompilerReferenceError CS0567 = new CompilerReferenceError(@"Interfaces cannot contain operators", 567);
        public static readonly ICompilerReferenceError CS0568 = new CompilerReferenceError(@"Structs cannot contain explicit parameterless constructors", 568);
        public static readonly ICompilerReferenceError CS0569 = new CompilerReferenceError(@"'method2' : cannot override 'method1' because it is not supported by the language", 569);
        public static readonly ICompilerReferenceError CS0570 = new CompilerReferenceError(@"Property, indexer, or event 'name' is not supported by the language; try directly calling accessor method 'name!'", 570);
        public static readonly ICompilerReferenceError CS0571 = new CompilerReferenceError(@"'function' : cannot explicitly call operator or accessor", 571);
        public static readonly ICompilerReferenceError CS0572 = new CompilerReferenceError(@"'type' : cannot reference a type through an expression; try 'path_to_type' instead", 572);
        public static readonly ICompilerReferenceError CS0573 = new CompilerReferenceError(@"'field declaration' : cannot have instance field initializers in structs", 573);
        public static readonly ICompilerReferenceError CS0574 = new CompilerReferenceError(@"Name of destructor must match name of class", 574);
        public static readonly ICompilerReferenceError CS0575 = new CompilerReferenceError(@"Only class types can contain destructors", 575);
        public static readonly ICompilerReferenceError CS0576 = new CompilerReferenceError(@"Namespace 'namespace' contains a definition conflicting with alias 'identifier'", 576);
        public static readonly ICompilerReferenceError CS0577 = new CompilerReferenceError(@"The Conditional attribute is not valid on 'function' because it is a constructor, destructor, operator, or explicit interface implementation", 577);
        public static readonly ICompilerReferenceError CS0578 = new CompilerReferenceError(@"The Conditional attribute is not valid on 'function' because its return type is not void", 578);
        public static readonly ICompilerReferenceError CS0579 = new CompilerReferenceError(@"Duplicate 'attribute' attribute", 579);
        public static readonly ICompilerReferenceError CS0582 = new CompilerReferenceError(@"The Conditional not valid on interface members", 582);
        public static readonly ICompilerReferenceError CS0583 = new CompilerReferenceError(@"Internal Compiler Error. An internal error has occurred in the compiler. To work around this problem, try simplifying or changing the program near the locations listed below. Locations at the top of the list are closer to the point at which the internal error occurred. Errors such as this can be reported to Microsoft by using the /errorreport option.", 583);
        public static readonly ICompilerReferenceError CS0584 = new CompilerReferenceError(@"Internal Compiler Error: stage 'stage' symbol 'symbol'", 584);
        public static readonly ICompilerReferenceError CS0585 = new CompilerReferenceError(@"Internal Compiler Error: stage 'stage'", 585);
        public static readonly ICompilerReferenceError CS0586 = new CompilerReferenceError(@"Internal Compiler Error: stage 'stage'", 586);
        public static readonly ICompilerReferenceError CS0587 = new CompilerReferenceError(@"Internal Compiler Error: stage 'stage'", 587);
        public static readonly ICompilerReferenceError CS0588 = new CompilerReferenceError(@"Internal Compiler Error: stage 'LEX'", 588);
        public static readonly ICompilerReferenceError CS0589 = new CompilerReferenceError(@"Internal Compiler Error: stage 'PARSE'", 589);
        public static readonly ICompilerReferenceError CS0590 = new CompilerReferenceError(@"User-defined operators cannot return void", 590);
        public static readonly ICompilerReferenceError CS0591 = new CompilerReferenceError(@"Invalid value for argument to 'attribute' attribute", 591);
        public static readonly ICompilerReferenceError CS0592 = new CompilerReferenceError(@"Attribute 'attribute' is not valid on this declaration type. It is valid on 'type' declarations only.", 592);
        public static readonly ICompilerReferenceError CS0594 = new CompilerReferenceError(@"Floating-point constant is outside the range of type 'type'", 594);
        public static readonly ICompilerReferenceError CS0596 = new CompilerReferenceError(@"The Guid attribute must be specified with the ComImport attribute", 596);
        public static readonly ICompilerReferenceError CS0599 = new CompilerReferenceError(@"Invalid value for named attribute argument 'argument'", 599);
        public static readonly ICompilerReferenceError CS0601 = new CompilerReferenceError(@"The DllImport attribute must be specified on a method marked 'static' and 'extern'", 601);
        public static readonly ICompilerReferenceError CS0609 = new CompilerReferenceError(@"Cannot set the IndexerName attribute on an indexer marked override", 609);
        public static readonly ICompilerReferenceError CS0610 = new CompilerReferenceError(@"Field or property cannot be of type 'type'", 610);
        public static readonly ICompilerReferenceError CS0611 = new CompilerReferenceError(@"Array elements cannot be of type 'type'", 611);
        public static readonly ICompilerReferenceError CS0616 = new CompilerReferenceError(@"'class' is not an attribute class", 616);
        public static readonly ICompilerReferenceError CS0617 = new CompilerReferenceError(@"'reference' is not a valid named attribute argument because it is not a valid attribute parameter type", 617);
        public static readonly ICompilerReferenceError CS0619 = new CompilerReferenceError(@"'member' is obsolete: 'text'", 619);
        public static readonly ICompilerReferenceError CS0620 = new CompilerReferenceError(@"Indexers cannot have void type", 620);
        public static readonly ICompilerReferenceError CS0621 = new CompilerReferenceError(@"'member' : virtual or abstract members cannot be private", 621);
        public static readonly ICompilerReferenceError CS0622 = new CompilerReferenceError(@"Can only use array initializer expressions to assign to array types. Try using a new expression instead.", 622);
        public static readonly ICompilerReferenceError CS0623 = new CompilerReferenceError(@"Array initializers can only be used in a variable or field initializer. Try using a new expression instead.", 623);
        public static readonly ICompilerReferenceError CS0625 = new CompilerReferenceError(@"'field': instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute", 625);
        public static readonly ICompilerReferenceError CS0629 = new CompilerReferenceError(@"Conditional member 'member' cannot implement interface member 'base class member' in type 'Type Name'", 629);
        public static readonly ICompilerReferenceError CS0631 = new CompilerReferenceError(@"ref and out are not valid in this context", 631);
        public static readonly ICompilerReferenceError CS0633 = new CompilerReferenceError(@"The argument to the 'attribute' attribute must be a valid identifier", 633);
        public static readonly ICompilerReferenceError CS0635 = new CompilerReferenceError(@"'attribute' : System.Interop.UnmanagedType.CustomMarshaller requires named arguments ComType and Marshal", 635);
        public static readonly ICompilerReferenceError CS0636 = new CompilerReferenceError(@"The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit)", 636);
        public static readonly ICompilerReferenceError CS0637 = new CompilerReferenceError(@"The FieldOffset attribute is not allowed on static or const fields", 637);
        public static readonly ICompilerReferenceError CS0641 = new CompilerReferenceError(@"'attribute' : attribute is only valid on classes derived from System.Attribute", 641);
        public static readonly ICompilerReferenceError CS0643 = new CompilerReferenceError(@"'arg' duplicate named attribute argument", 643);
        public static readonly ICompilerReferenceError CS0644 = new CompilerReferenceError(@"'class1' cannot derive from special class 'class2'", 644);
        public static readonly ICompilerReferenceError CS0645 = new CompilerReferenceError(@"Identifier too long", 645);
        public static readonly ICompilerReferenceError CS0646 = new CompilerReferenceError(@"Cannot specify the DefaultMember attribute on a type containing an indexer", 646);
        public static readonly ICompilerReferenceError CS0647 = new CompilerReferenceError(@"Error emitting 'attribute' attribute -- 'reason'", 647);
        public static readonly ICompilerReferenceError CS0648 = new CompilerReferenceError(@"'type' is a type not supported by the language", 648);
        public static readonly ICompilerReferenceError CS0650 = new CompilerReferenceError(@"Bad array declarator: To declare a managed array the rank specifier precedes the variable's identifier. To declare a fixed size buffer field, use the fixed keyword before the field type.", 650);
        public static readonly ICompilerReferenceError CS0653 = new CompilerReferenceError(@"Cannot apply attribute class 'class' because it is abstract", 653);
        public static readonly ICompilerReferenceError CS0655 = new CompilerReferenceError(@"'parameter' is not a valid named attribute argument because it is not a valid attribute parameter type", 655);
        public static readonly ICompilerReferenceError CS0656 = new CompilerReferenceError(@"Missing compiler required member 'object.member'", 656);
        public static readonly ICompilerReferenceError CS0662 = new CompilerReferenceError(@"'method' cannot specify only Out attribute on a ref parameter. Use both In and Out attributes, or neither.", 662);
        public static readonly ICompilerReferenceError CS0663 = new CompilerReferenceError(@"Cannot define overloaded methods that differ only on ref and out.", 663);
        public static readonly ICompilerReferenceError CS0664 = new CompilerReferenceError(@"Literal of type double cannot be implicitly converted to type 'type'; use an 'suffix' suffix to create a literal of this type", 664);
        public static readonly ICompilerReferenceError CS0666 = new CompilerReferenceError(@"'member' : new protected member declared in struct", 666);
        public static readonly ICompilerReferenceError CS0667 = new CompilerReferenceError(@"The feature 'invalid feature' is deprecated. Please use 'valid feature' instead'.", 667);
        public static readonly ICompilerReferenceError CS0668 = new CompilerReferenceError(@"Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type", 668);
        public static readonly ICompilerReferenceError CS0669 = new CompilerReferenceError(@"A class with the ComImport attribute cannot have a user-defined constructor", 669);
        public static readonly ICompilerReferenceError CS0670 = new CompilerReferenceError(@"Field cannot have void type", 670);
        public static readonly ICompilerReferenceError CS0673 = new CompilerReferenceError(@"System.Void cannot be used from C# -- use typeof(void) to get the void type object.", 673);
        public static readonly ICompilerReferenceError CS0674 = new CompilerReferenceError(@"Do not use 'System.ParamArrayAttribute'. Use the 'params' keyword instead.", 674);
        public static readonly ICompilerReferenceError CS0677 = new CompilerReferenceError(@"'variable': a volatile field cannot be of the type 'type'", 677);
        public static readonly ICompilerReferenceError CS0678 = new CompilerReferenceError(@"'variable': a field can not be both volatile and readonly", 678);
        public static readonly ICompilerReferenceError CS0681 = new CompilerReferenceError(@"The modifier 'abstract' is not valid on fields. Try using a property instead", 681);
        public static readonly ICompilerReferenceError CS0682 = new CompilerReferenceError(@"'type1' cannot implement 'type2' because it is not supported by the language", 682);
        public static readonly ICompilerReferenceError CS0683 = new CompilerReferenceError(@"'explicitmethod' explicit method implementation cannot implement 'method' because it is an accessor", 683);
        public static readonly ICompilerReferenceError CS0685 = new CompilerReferenceError(@"Conditional member 'member' cannot have an out parameter", 685);
        public static readonly ICompilerReferenceError CS0686 = new CompilerReferenceError(@"Accessor 'accessor' cannot implement interface member 'member' for type 'type'. Use an explicit interface implementation.", 686);
        public static readonly ICompilerReferenceError CS0687 = new CompilerReferenceError(@"The namespace alias qualifier '::' always resolves to a type or namespace so is illegal here. Consider using '.' instead.", 687);
        public static readonly ICompilerReferenceError CS0689 = new CompilerReferenceError(@"Cannot derive from 'identifier' because it is a type parameter", 689);
        public static readonly ICompilerReferenceError CS0690 = new CompilerReferenceError(@"Input file 'file' contains invalid metadata.", 690);
        public static readonly ICompilerReferenceError CS0692 = new CompilerReferenceError(@"Duplicate type parameter 'identifier'", 692);
        public static readonly ICompilerReferenceError CS0694 = new CompilerReferenceError(@"Type parameter 'identifier' has the same name as the containing type, or method", 694);
        public static readonly ICompilerReferenceError CS0695 = new CompilerReferenceError(@"'generic type' cannot implement both 'generic interface' and 'generic interface' because they may unify for some type parameter substitutions", 695);
        public static readonly ICompilerReferenceError CS0698 = new CompilerReferenceError(@"A generic type cannot derive from 'class' because it is an attribute class", 698);
        public static readonly ICompilerReferenceError CS0699 = new CompilerReferenceError(@"'generic' does not define type parameter 'identifier'", 699);
        public static readonly ICompilerReferenceError CS0701 = new CompilerReferenceError(@"'identifier' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.", 701);
        public static readonly ICompilerReferenceError CS0702 = new CompilerReferenceError(@"Constraint cannot be special class 'identifier'", 702);
        public static readonly ICompilerReferenceError CS0703 = new CompilerReferenceError(@"Inconsistent accessibility: constraint type 'identifier' is less accessible than 'identifier'", 703);
        public static readonly ICompilerReferenceError CS0704 = new CompilerReferenceError(@"Cannot do member lookup in 'type' because it is a type parameter", 704);
        public static readonly ICompilerReferenceError CS0706 = new CompilerReferenceError(@"Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.", 706);
        public static readonly ICompilerReferenceError CS0708 = new CompilerReferenceError(@"'field': cannot declare instance members in a static class", 708);
        public static readonly ICompilerReferenceError CS0709 = new CompilerReferenceError(@"'derived class': cannot derive from static class 'base class'", 709);
        public static readonly ICompilerReferenceError CS0710 = new CompilerReferenceError(@"Static classes cannot have instance constructors", 710);
        public static readonly ICompilerReferenceError CS0711 = new CompilerReferenceError(@"Static classes cannot contain destructors", 711);
        public static readonly ICompilerReferenceError CS0712 = new CompilerReferenceError(@"Cannot create an instance of the static class 'static class'", 712);
        public static readonly ICompilerReferenceError CS0713 = new CompilerReferenceError(@"Static class 'static type' cannot derive from type 'type'. Static classes must derive from object.", 713);
        public static readonly ICompilerReferenceError CS0714 = new CompilerReferenceError(@"'static type' : static classes cannot implement interfaces", 714);
        public static readonly ICompilerReferenceError CS0715 = new CompilerReferenceError(@"'static class' : static classes cannot contain user defined operators", 715);
        public static readonly ICompilerReferenceError CS0716 = new CompilerReferenceError(@"Cannot convert to static type 'type'", 716);
        public static readonly ICompilerReferenceError CS0717 = new CompilerReferenceError(@"'static class': static classes cannot be used as constraints", 717);
        public static readonly ICompilerReferenceError CS0718 = new CompilerReferenceError(@"'type': static types cannot be used as type arguments", 718);
        public static readonly ICompilerReferenceError CS0719 = new CompilerReferenceError(@"'type': array elements cannot be of static type", 719);
        public static readonly ICompilerReferenceError CS0720 = new CompilerReferenceError(@"'static class': cannot declare indexers in a static class", 720);
        public static readonly ICompilerReferenceError CS0721 = new CompilerReferenceError(@"'type': static types cannot be used as parameters", 721);
        public static readonly ICompilerReferenceError CS0722 = new CompilerReferenceError(@"'type': static types cannot be used as return types", 722);
        public static readonly ICompilerReferenceError CS0723 = new CompilerReferenceError(@"Cannot declare variable of static type 'type'", 723);
        public static readonly ICompilerReferenceError CS0724 = new CompilerReferenceError(@"does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute", 724);
        public static readonly ICompilerReferenceError CS0726 = new CompilerReferenceError(@"'format specifier' is not a valid format specifier", 726);
        public static readonly ICompilerReferenceError CS0727 = new CompilerReferenceError(@"Invalid format specifier", 727);
        public static readonly ICompilerReferenceError CS0729 = new CompilerReferenceError(@"Type 'type' is defined in this assembly, but a type forwarder is specified for it", 729);
        public static readonly ICompilerReferenceError CS0730 = new CompilerReferenceError(@"Cannot forward type 'type' because it is a nested type of 'type'", 730);
        public static readonly ICompilerReferenceError CS0731 = new CompilerReferenceError(@"The type forwarder for type 'type' in assembly 'assembly' causes a cycle", 731);
        public static readonly ICompilerReferenceError CS0733 = new CompilerReferenceError(@"Cannot forward generic type, 'GenericType<>'", 733);
        public static readonly ICompilerReferenceError CS0734 = new CompilerReferenceError(@"The /moduleassemblyname option may only be specified when building a target type of 'module'", 734);
        public static readonly ICompilerReferenceError CS0735 = new CompilerReferenceError(@"Invalid type specified as an argument for TypeForwardedTo attribute", 735);
        public static readonly ICompilerReferenceError CS0736 = new CompilerReferenceError(@"'type name' does not implement interface member 'member name'. 'method name' cannot implement an interface member because it is static.", 736);
        public static readonly ICompilerReferenceError CS0737 = new CompilerReferenceError(@"'type name' does not implement interface member 'member name'. 'method name' cannot implement an interface member because it is not public.", 737);
        public static readonly ICompilerReferenceError CS0738 = new CompilerReferenceError(@"'type name' does not implement interface member 'member name'. 'method name' cannot implement 'interface member' because it does not have the matching return type of ' type name'.", 738);
        public static readonly ICompilerReferenceError CS0739 = new CompilerReferenceError(@"'type name' duplicate TypeForwardedToAttribute.", 739);
        public static readonly ICompilerReferenceError CS0742 = new CompilerReferenceError(@"A query body must end with a select clause or a group clause", 742);
        public static readonly ICompilerReferenceError CS0743 = new CompilerReferenceError(@"Expected contextual keyword 'on'", 743);
        public static readonly ICompilerReferenceError CS0744 = new CompilerReferenceError(@"Expected contextual keyword 'equals'", 744);
        public static readonly ICompilerReferenceError CS0745 = new CompilerReferenceError(@"Expected contextual keyword 'by'", 745);
        public static readonly ICompilerReferenceError CS0746 = new CompilerReferenceError(@"Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access.", 746);
        public static readonly ICompilerReferenceError CS0747 = new CompilerReferenceError(@"Invalid initializer member declarator.", 747);
        public static readonly ICompilerReferenceError CS0748 = new CompilerReferenceError(@"Inconsistent lambda parameter usage; all parameter types must either be explicit or implicit.", 748);
        public static readonly ICompilerReferenceError CS0750 = new CompilerReferenceError(@"A partial method cannot have access modifiers or the virtual, abstract, override, new, sealed, or extern modifiers.", 750);
        public static readonly ICompilerReferenceError CS0751 = new CompilerReferenceError(@"A partial method must be declared in a partial class or partial struct", 751);
        public static readonly ICompilerReferenceError CS0752 = new CompilerReferenceError(@"A partial method cannot have out parameters", 752);
        public static readonly ICompilerReferenceError CS0753 = new CompilerReferenceError(@"Only methods, classes, structs, or interfaces may be partial.", 753);
        public static readonly ICompilerReferenceError CS0754 = new CompilerReferenceError(@"A partial method may not explicitly implement an interface method.", 754);
        public static readonly ICompilerReferenceError CS0755 = new CompilerReferenceError(@"Both partial method declarations must be extension methods or neither may be an extension method.", 755);
        public static readonly ICompilerReferenceError CS0756 = new CompilerReferenceError(@"A partial method may not have multiple defining declarations.", 756);
        public static readonly ICompilerReferenceError CS0757 = new CompilerReferenceError(@"A partial method may not have multiple implementing declarations.", 757);
        public static readonly ICompilerReferenceError CS0758 = new CompilerReferenceError(@"Both partial method declarations must use a params parameter or neither may use a params parameter", 758);
        public static readonly ICompilerReferenceError CS0759 = new CompilerReferenceError(@"No defining declaration found for implementing declaration of partial method 'method'.", 759);
        public static readonly ICompilerReferenceError CS0761 = new CompilerReferenceError(@"Partial method declarations of 'method<T>' have inconsistent type parameter constraints.", 761);
        public static readonly ICompilerReferenceError CS0762 = new CompilerReferenceError(@"Cannot create delegate from method 'method' because it is a partial method without an implementing declaration", 762);
        public static readonly ICompilerReferenceError CS0763 = new CompilerReferenceError(@"Both partial method declarations must be static or neither may be static.", 763);
        public static readonly ICompilerReferenceError CS0764 = new CompilerReferenceError(@"Both partial method declarations must be unsafe or neither may be unsafe", 764);
        public static readonly ICompilerReferenceError CS0765 = new CompilerReferenceError(@"Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees", 765);
        public static readonly ICompilerReferenceError CS0766 = new CompilerReferenceError(@"Partial methods must have a void return type.", 766);
        public static readonly ICompilerReferenceError CS0811 = new CompilerReferenceError(@"The fully qualified name for 'name' is too long for debug information. Compile without '/debug' option.", 811);
        public static readonly ICompilerReferenceError CS0815 = new CompilerReferenceError(@"Cannot assign 'expression' to an implicitly typed local", 815);
        public static readonly ICompilerReferenceError CS0818 = new CompilerReferenceError(@"Implicitly typed locals must be initialized", 818);
        public static readonly ICompilerReferenceError CS0819 = new CompilerReferenceError(@"Implicitly typed locals cannot have multiple declarators.", 819);
        public static readonly ICompilerReferenceError CS0820 = new CompilerReferenceError(@"Cannot assign array initializer to an implicitly typed local", 820);
        public static readonly ICompilerReferenceError CS0821 = new CompilerReferenceError(@"Implicitly typed locals cannot be fixed", 821);
        public static readonly ICompilerReferenceError CS0822 = new CompilerReferenceError(@"Implicitly typed locals cannot be const", 822);
        public static readonly ICompilerReferenceError CS0825 = new CompilerReferenceError(@"The contextual keyword 'var' may only appear within a local variable declaration.", 825);
        public static readonly ICompilerReferenceError CS0826 = new CompilerReferenceError(@"No best type found for implicitly typed array.", 826);
        public static readonly ICompilerReferenceError CS0828 = new CompilerReferenceError(@"Cannot assign 'expression' to anonymous type property.", 828);
        public static readonly ICompilerReferenceError CS0831 = new CompilerReferenceError(@"An expression tree may not contain a base access.", 831);
        public static readonly ICompilerReferenceError CS0832 = new CompilerReferenceError(@"An expression tree may not contain an assignment operator.", 832);
        public static readonly ICompilerReferenceError CS0833 = new CompilerReferenceError(@"An anonymous type cannot have multiple properties with the same name.", 833);
        public static readonly ICompilerReferenceError CS0834 = new CompilerReferenceError(@"A lambda expression must have an expression body to be converted to an expression tree.", 834);
        public static readonly ICompilerReferenceError CS0835 = new CompilerReferenceError(@"Cannot convert lambda to an expression tree whose type argument 'type' is not a delegate type.", 835);
        public static readonly ICompilerReferenceError CS0836 = new CompilerReferenceError(@"Cannot use anonymous type in a constant expression.", 836);
        public static readonly ICompilerReferenceError CS0837 = new CompilerReferenceError(@"The first operand of an ""is"" or ""as"" operator may not be a lambda expression or anonymous method.", 837);
        public static readonly ICompilerReferenceError CS0838 = new CompilerReferenceError(@"An expression tree may not contain a multidimensional array initializer.", 838);
        public static readonly ICompilerReferenceError CS0839 = new CompilerReferenceError(@"Argument missing.", 839);
        public static readonly ICompilerReferenceError CS0840 = new CompilerReferenceError(@"'Property name' must declare a body because it is not marked abstract or extern. Automatically implemented properties must define both get and set accessors.", 840);
        public static readonly ICompilerReferenceError CS0841 = new CompilerReferenceError(@"Cannot use variable 'name' before it is declared.", 841);
        public static readonly ICompilerReferenceError CS0842 = new CompilerReferenceError(@"Automatically implemented properties cannot be used inside a type marked with StructLayout(LayoutKind.Explicit).", 842);
        public static readonly ICompilerReferenceError CS0843 = new CompilerReferenceError(@"Backing field for automatically implemented property 'name' must be fully assigned before control is returned to the caller. Consider calling the default constructor from a constructor initializer.", 843);
        public static readonly ICompilerReferenceError CS0844 = new CompilerReferenceError(@"Cannot use local variable 'name' before it is declared. The declaration of the local variable hides the field 'name'.", 844);
        public static readonly ICompilerReferenceError CS0845 = new CompilerReferenceError(@"An expression tree lambda may not contain a coalescing operator with a null literal left-hand side.", 845);
        public static readonly ICompilerReferenceError CS1001 = new CompilerReferenceError(@"Identifier expected", 1001);
        public static readonly ICompilerReferenceError CS1002 = new CompilerReferenceError(@"; expected", 1002);
        public static readonly ICompilerReferenceError CS1003 = new CompilerReferenceError(@"Syntax error, 'char' expected", 1003);
        public static readonly ICompilerReferenceError CS1004 = new CompilerReferenceError(@"Duplicate 'modifier' modifier", 1004);
        public static readonly ICompilerReferenceError CS1007 = new CompilerReferenceError(@"Property accessor already defined", 1007);
        public static readonly ICompilerReferenceError CS1008 = new CompilerReferenceError(@"Type byte, sbyte, short, ushort, int, uint, long, or ulong expected", 1008);
        public static readonly ICompilerReferenceError CS1009 = new CompilerReferenceError(@"Unrecognized escape sequence", 1009);
        public static readonly ICompilerReferenceError CS1010 = new CompilerReferenceError(@"Newline in constant", 1010);
        public static readonly ICompilerReferenceError CS1011 = new CompilerReferenceError(@"Empty character literal", 1011);
        public static readonly ICompilerReferenceError CS1012 = new CompilerReferenceError(@"Too many characters in character literal", 1012);
        public static readonly ICompilerReferenceError CS1013 = new CompilerReferenceError(@"Invalid number", 1013);
        public static readonly ICompilerReferenceError CS1014 = new CompilerReferenceError(@"A get or set accessor expected", 1014);
        public static readonly ICompilerReferenceError CS1015 = new CompilerReferenceError(@"An object, string, or class type expected", 1015);
        public static readonly ICompilerReferenceError CS1016 = new CompilerReferenceError(@"Named attribute argument expected", 1016);
        public static readonly ICompilerReferenceError CS1017 = new CompilerReferenceError(@"Catch clauses cannot follow the general catch clause of a try statement", 1017);
        public static readonly ICompilerReferenceError CS1018 = new CompilerReferenceError(@"Keyword 'this' or 'base' expected", 1018);
        public static readonly ICompilerReferenceError CS1019 = new CompilerReferenceError(@"Overloadable unary operator expected", 1019);
        public static readonly ICompilerReferenceError CS1020 = new CompilerReferenceError(@"Overloadable binary operator expected", 1020);
        public static readonly ICompilerReferenceError CS1021 = new CompilerReferenceError(@"Integral constant is too large", 1021);
        public static readonly ICompilerReferenceError CS1022 = new CompilerReferenceError(@"Type or namespace definition, or end-of-file expected", 1022);
        public static readonly ICompilerReferenceError CS1023 = new CompilerReferenceError(@"Embedded statement cannot be a declaration or labeled statement", 1023);
        public static readonly ICompilerReferenceError CS1024 = new CompilerReferenceError(@"Preprocessor directive expected", 1024);
        public static readonly ICompilerReferenceError CS1025 = new CompilerReferenceError(@"Single-line comment or end-of-line expected", 1025);
        public static readonly ICompilerReferenceError CS1026 = new CompilerReferenceError(@") expected", 1026);
        public static readonly ICompilerReferenceError CS1027 = new CompilerReferenceError(@"#endif directive expected", 1027);
        public static readonly ICompilerReferenceError CS1028 = new CompilerReferenceError(@"Unexpected preprocessor directive", 1028);
        public static readonly ICompilerReferenceError CS1029 = new CompilerReferenceError(@"#error: 'text'", 1029);
        public static readonly ICompilerReferenceError CS1031 = new CompilerReferenceError(@"Type expected", 1031);
        public static readonly ICompilerReferenceError CS1032 = new CompilerReferenceError(@"Cannot define/undefine preprocessor symbols after first token in file", 1032);
        public static readonly ICompilerReferenceError CS1033 = new CompilerReferenceError(@"Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect", 1033);
        public static readonly ICompilerReferenceError CS1034 = new CompilerReferenceError(@"Compiler limit exceeded: Line cannot exceed 'number' characters", 1034);
        public static readonly ICompilerReferenceError CS1035 = new CompilerReferenceError(@"End-of-file found, '*/' expected", 1035);
        public static readonly ICompilerReferenceError CS1036 = new CompilerReferenceError(@"( or . expected", 1036);
        public static readonly ICompilerReferenceError CS1037 = new CompilerReferenceError(@"Overloadable operator expected", 1037);
        public static readonly ICompilerReferenceError CS1038 = new CompilerReferenceError(@"#endregion directive expected", 1038);
        public static readonly ICompilerReferenceError CS1039 = new CompilerReferenceError(@"Unterminated string literal", 1039);
        public static readonly ICompilerReferenceError CS1040 = new CompilerReferenceError(@"Preprocessor directives must appear as the first non-whitespace character on a line", 1040);
        public static readonly ICompilerReferenceError CS1041 = new CompilerReferenceError(@"Identifier expected, 'keyword' is a keyword", 1041);
        public static readonly ICompilerReferenceError CS1043 = new CompilerReferenceError(@"{ or ; expected", 1043);
        public static readonly ICompilerReferenceError CS1044 = new CompilerReferenceError(@"Cannot use more than one type in a for, using, fixed, or declaration statement", 1044);
        public static readonly ICompilerReferenceError CS1055 = new CompilerReferenceError(@"An add or remove accessor expected", 1055);
        public static readonly ICompilerReferenceError CS1056 = new CompilerReferenceError(@"Unexpected character 'character'", 1056);
        public static readonly ICompilerReferenceError CS1057 = new CompilerReferenceError(@"'member': static classes cannot contain protected members", 1057);
        public static readonly ICompilerReferenceError CS1059 = new CompilerReferenceError(@"The operand of an increment or decrement operator must be a variable, property or indexer.", 1059);
        public static readonly ICompilerReferenceError CS1061 = new CompilerReferenceError(@"'type' does not contain a definition for 'member' and no extension method 'name' accepting a first argument of type 'type' could be found (are you missing a using directive or an assembly reference?).", 1061);
        public static readonly ICompilerReferenceError CS1100 = new CompilerReferenceError(@"Method 'name' has a parameter modifier 'this' which is not on the first parameter.", 1100);
        public static readonly ICompilerReferenceError CS1101 = new CompilerReferenceError(@"The parameter modifier 'ref' cannot be used with 'this'.", 1101);
        public static readonly ICompilerReferenceError CS1102 = new CompilerReferenceError(@"The parameter modifier 'out' cannot be used with 'this'.", 1102);
        public static readonly ICompilerReferenceError CS1103 = new CompilerReferenceError(@"The first parameter of an extension method cannot be of type 'type'.", 1103);
        public static readonly ICompilerReferenceError CS1104 = new CompilerReferenceError(@"A parameter array cannot be used with 'this' modifier on an extension method.", 1104);
        public static readonly ICompilerReferenceError CS1105 = new CompilerReferenceError(@"Extension methods must be static.", 1105);
        public static readonly ICompilerReferenceError CS1106 = new CompilerReferenceError(@"Extension methods must be defined in a non generic static class.", 1106);
        public static readonly ICompilerReferenceError CS1107 = new CompilerReferenceError(@"A parameter can only have one 'modifier name' modifier.", 1107);
        public static readonly ICompilerReferenceError CS1108 = new CompilerReferenceError(@"A parameter cannot have all the specified modifiers; there are too many modifiers on the parameter.", 1108);
        public static readonly ICompilerReferenceError CS1109 = new CompilerReferenceError(@"Extension Methods must be defined on top level static classes, 'name' is a nested class.", 1109);
        public static readonly ICompilerReferenceError CS1110 = new CompilerReferenceError(@"Cannot use 'this' modifier on first parameter of method declaration without a reference to System.Core.dll. Add a reference to System.Core.dll or remove 'this' modifier from the method declaration.", 1110);
        public static readonly ICompilerReferenceError CS1112 = new CompilerReferenceError(@"Do not use 'System.Runtime.CompilerServices.ExtensionAttribute'. Use the 'this' keyword instead.", 1112);
        public static readonly ICompilerReferenceError CS1113 = new CompilerReferenceError(@"Extension methods 'name' defined on value type 'name' cannot be used to create delegates.", 1113);
        public static readonly ICompilerReferenceError CS1501 = new CompilerReferenceError(@"No overload for method 'method' takes 'number' arguments", 1501);
        public static readonly ICompilerReferenceError CS1502 = new CompilerReferenceError(@"The best overloaded Add method 'name' for the collection initializer has some invalid arguments", 1502);
        public static readonly ICompilerReferenceError CS1503 = new CompilerReferenceError(@"The best overloaded Add method 'name for the collection initializer has some invalid arguments", 1503);
        public static readonly ICompilerReferenceError CS1504 = new CompilerReferenceError(@"Source file 'file' could not be opened ('reason')", 1504);
        public static readonly ICompilerReferenceError CS1507 = new CompilerReferenceError(@"Cannot link resource file 'file' when building a module", 1507);
        public static readonly ICompilerReferenceError CS1508 = new CompilerReferenceError(@"Resource identifier 'identifier' has already been used in this assembly", 1508);
        public static readonly ICompilerReferenceError CS1509 = new CompilerReferenceError(@"Referenced file 'file' is not an assembly; use '/addmodule' option instead", 1509);
        public static readonly ICompilerReferenceError CS1510 = new CompilerReferenceError(@"A ref or out argument must be an assignable variable", 1510);
        public static readonly ICompilerReferenceError CS1511 = new CompilerReferenceError(@"Keyword 'base' is not available in a static method", 1511);
        public static readonly ICompilerReferenceError CS1512 = new CompilerReferenceError(@"Keyword 'base' is not available in the current context", 1512);
        public static readonly ICompilerReferenceError CS1513 = new CompilerReferenceError(@"} expected", 1513);
        public static readonly ICompilerReferenceError CS1514 = new CompilerReferenceError(@"{ expected", 1514);
        public static readonly ICompilerReferenceError CS1515 = new CompilerReferenceError(@"'in' expected", 1515);
        public static readonly ICompilerReferenceError CS1517 = new CompilerReferenceError(@"Invalid preprocessor expression", 1517);
        public static readonly ICompilerReferenceError CS1518 = new CompilerReferenceError(@"Expected class, delegate, enum, interface, or struct", 1518);
        public static readonly ICompilerReferenceError CS1519 = new CompilerReferenceError(@"Invalid token 'token' in class, struct, or interface member declaration", 1519);
        public static readonly ICompilerReferenceError CS1520 = new CompilerReferenceError(@"Method must have a return type", 1520);
        public static readonly ICompilerReferenceError CS1521 = new CompilerReferenceError(@"Invalid base type", 1521);
        public static readonly ICompilerReferenceError CS1524 = new CompilerReferenceError(@"Expected catch or finally", 1524);
        public static readonly ICompilerReferenceError CS1525 = new CompilerReferenceError(@"Invalid expression term 'character'", 1525);
        public static readonly ICompilerReferenceError CS1526 = new CompilerReferenceError(@"A new expression requires (), [], or {} after type", 1526);
        public static readonly ICompilerReferenceError CS1527 = new CompilerReferenceError(@"Elements defined in a namespace cannot be explicitly declared as private, protected, or protected internal", 1527);
        public static readonly ICompilerReferenceError CS1528 = new CompilerReferenceError(@"Expected ; or = (cannot specify constructor arguments in declaration)", 1528);
        public static readonly ICompilerReferenceError CS1529 = new CompilerReferenceError(@"A using clause must precede all other elements defined in the namespace except extern alias declarations", 1529);
        public static readonly ICompilerReferenceError CS1530 = new CompilerReferenceError(@"Keyword 'new' is not allowed on elements defined in a namespace", 1530);
        public static readonly ICompilerReferenceError CS1534 = new CompilerReferenceError(@"Overloaded binary operator 'operator' takes two parameters", 1534);
        public static readonly ICompilerReferenceError CS1535 = new CompilerReferenceError(@"Overloaded unary operator 'operator' takes one parameter", 1535);
        public static readonly ICompilerReferenceError CS1536 = new CompilerReferenceError(@"Invalid parameter type void", 1536);
        public static readonly ICompilerReferenceError CS1537 = new CompilerReferenceError(@"The using alias 'alias' appeared previously in this namespace", 1537);
        public static readonly ICompilerReferenceError CS1540 = new CompilerReferenceError(@"Cannot access protected member 'member' via a qualifier of type 'type1'; the qualifier must be of type 'type2' (or derived from it)", 1540);
        public static readonly ICompilerReferenceError CS1541 = new CompilerReferenceError(@"Invalid reference option: 'symbol' — cannot reference directories", 1541);
        public static readonly ICompilerReferenceError CS1542 = new CompilerReferenceError(@"'dll' cannot be added to this assembly because it already is an assembly; use '/R' option instead", 1542);
        public static readonly ICompilerReferenceError CS1545 = new CompilerReferenceError(@"Property, indexer, or event 'property' is not supported by the language; try directly calling accessor methods 'set accessor' or 'get accessor'", 1545);
        public static readonly ICompilerReferenceError CS1546 = new CompilerReferenceError(@"Property, indexer, or event 'property' is not supported by the language; try directly calling accessor method 'accessor'", 1546);
        public static readonly ICompilerReferenceError CS1547 = new CompilerReferenceError(@"Keyword 'void' cannot be used in this context", 1547);
        public static readonly ICompilerReferenceError CS1548 = new CompilerReferenceError(@"Cryptographic failure while signing assembly 'assembly' — 'reason'", 1548);
        public static readonly ICompilerReferenceError CS1549 = new CompilerReferenceError(@"Appropriate cryptographic service not found", 1549);
        public static readonly ICompilerReferenceError CS1551 = new CompilerReferenceError(@"Indexers must have at least one parameter", 1551);
        public static readonly ICompilerReferenceError CS1552 = new CompilerReferenceError(@"Array type specifier, [], must appear before parameter name", 1552);
        public static readonly ICompilerReferenceError CS1553 = new CompilerReferenceError(@"Declaration is not valid; use 'modifier operator <dest-type> (...' instead", 1553);
        public static readonly ICompilerReferenceError CS1554 = new CompilerReferenceError(@"Declaration is not valid; use '<type> operator op (...' instead", 1554);
        public static readonly ICompilerReferenceError CS1555 = new CompilerReferenceError(@"Could not find 'class' specified for Main method", 1555);
        public static readonly ICompilerReferenceError CS1556 = new CompilerReferenceError(@"'construct' specified for Main method must be a valid class or struct", 1556);
        public static readonly ICompilerReferenceError CS1557 = new CompilerReferenceError(@"Cannot use 'class' for Main method because it is in a different output file", 1557);
        public static readonly ICompilerReferenceError CS1558 = new CompilerReferenceError(@"'class' does not have a suitable static Main method", 1558);
        public static readonly ICompilerReferenceError CS1559 = new CompilerReferenceError(@"Cannot use 'object' for Main method because it is imported", 1559);
        public static readonly ICompilerReferenceError CS1560 = new CompilerReferenceError(@"Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename", 1560);
        public static readonly ICompilerReferenceError CS1561 = new CompilerReferenceError(@"Output filename is too long or invalid", 1561);
        public static readonly ICompilerReferenceError CS1562 = new CompilerReferenceError(@"Outputs without source must have the /out option specified", 1562);
        public static readonly ICompilerReferenceError CS1563 = new CompilerReferenceError(@"Output 'output file' does not have any source files", 1563);
        public static readonly ICompilerReferenceError CS1564 = new CompilerReferenceError(@"Conflicting options specified: Win32 resource file; Win32 manifest.", 1564);
        public static readonly ICompilerReferenceError CS1565 = new CompilerReferenceError(@"Conflicting options specified: Win32 resource file; Win32 icon", 1565);
        public static readonly ICompilerReferenceError CS1566 = new CompilerReferenceError(@"Error reading resource file 'file' — 'reason'", 1566);
        public static readonly ICompilerReferenceError CS1567 = new CompilerReferenceError(@"Error generating Win32 resource: 'file'", 1567);
        public static readonly ICompilerReferenceError CS1569 = new CompilerReferenceError(@"Error generating XML documentation file 'Filename' ('reason')", 1569);
        public static readonly ICompilerReferenceError CS1575 = new CompilerReferenceError(@"A stackalloc expression requires [] after type", 1575);
        public static readonly ICompilerReferenceError CS1576 = new CompilerReferenceError(@"The line number specified for #line directive is missing or invalid", 1576);
        public static readonly ICompilerReferenceError CS1577 = new CompilerReferenceError(@"Assembly generation failed — reason", 1577);
        public static readonly ICompilerReferenceError CS1578 = new CompilerReferenceError(@"Filename, single-line comment or end-of-line expected", 1578);
        public static readonly ICompilerReferenceError CS1579 = new CompilerReferenceError(@"foreach statement cannot operate on variables of type 'type1' because 'type2' does not contain a public definition for 'identifier'", 1579);
        public static readonly ICompilerReferenceError CS1583 = new CompilerReferenceError(@"'file' is not a valid Win32 resource file", 1583);
        public static readonly ICompilerReferenceError CS1585 = new CompilerReferenceError(@"Member modifier 'keyword' must precede the member type and name", 1585);
        public static readonly ICompilerReferenceError CS1586 = new CompilerReferenceError(@"Array creation must have array size or array initializer", 1586);
        public static readonly ICompilerReferenceError CS1588 = new CompilerReferenceError(@"Cannot determine common language runtime directory -- 'reason'", 1588);
        public static readonly ICompilerReferenceError CS1593 = new CompilerReferenceError(@"Delegate 'del' does not take 'number' arguments", 1593);
        public static readonly ICompilerReferenceError CS1594 = new CompilerReferenceError(@"Delegate 'delegate' has some invalid arguments", 1594);
        public static readonly ICompilerReferenceError CS1597 = new CompilerReferenceError(@"Semicolon after method or accessor block is not valid", 1597);
        public static readonly ICompilerReferenceError CS1599 = new CompilerReferenceError(@"Method or delegate cannot return type 'type'", 1599);
        public static readonly ICompilerReferenceError CS1600 = new CompilerReferenceError(@"Compilation cancelled by user", 1600);
        public static readonly ICompilerReferenceError CS1601 = new CompilerReferenceError(@"Method or delegate parameter cannot be of type 'type'", 1601);
        public static readonly ICompilerReferenceError CS1604 = new CompilerReferenceError(@"Cannot assign to 'variable' because it is read-only", 1604);
        public static readonly ICompilerReferenceError CS1605 = new CompilerReferenceError(@"Cannot pass 'var' as a ref or out argument because it is read-only", 1605);
        public static readonly ICompilerReferenceError CS1606 = new CompilerReferenceError(@"Assembly signing failed; output may not be signed -- reason", 1606);
        public static readonly ICompilerReferenceError CS1608 = new CompilerReferenceError(@"The Required attribute is not permitted on C# types", 1608);
        public static readonly ICompilerReferenceError CS1609 = new CompilerReferenceError(@"Modifiers cannot be placed on event accessor declarations", 1609);
        public static readonly ICompilerReferenceError CS1611 = new CompilerReferenceError(@"The params parameter cannot be declared as ref or out", 1611);
        public static readonly ICompilerReferenceError CS1612 = new CompilerReferenceError(@"Cannot modify the return value of 'expression' because it is not a variable", 1612);
        public static readonly ICompilerReferenceError CS1613 = new CompilerReferenceError(@"The managed coclass wrapper class 'class' for interface 'interface' cannot be found (are you missing an assembly reference?)", 1613);
        public static readonly ICompilerReferenceError CS1614 = new CompilerReferenceError(@"'name' is ambiguous; between 'attribute1' and 'attribute2'. use either '@attribute' or 'attributeAttribute'", 1614);
        public static readonly ICompilerReferenceError CS1615 = new CompilerReferenceError(@"Argument 'number' should not be passed with the 'keyword' keyword", 1615);
        public static readonly ICompilerReferenceError CS1617 = new CompilerReferenceError(@"Invalid option 'option' for /langversion; must be ISO-1, ISO-2 or Default", 1617);
        public static readonly ICompilerReferenceError CS1618 = new CompilerReferenceError(@"Cannot create delegate with 'method' because it has a Conditional attribute", 1618);
        public static readonly ICompilerReferenceError CS1619 = new CompilerReferenceError(@"Cannot create temporary file 'filename' -- reason", 1619);
        public static readonly ICompilerReferenceError CS1620 = new CompilerReferenceError(@"Argument 'number' must be passed with the 'keyword' keyword", 1620);
        public static readonly ICompilerReferenceError CS1621 = new CompilerReferenceError(@"The yield statement cannot be used inside an anonymous method or lambda expression", 1621);
        public static readonly ICompilerReferenceError CS1622 = new CompilerReferenceError(@"Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration.", 1622);
        public static readonly ICompilerReferenceError CS1623 = new CompilerReferenceError(@"Iterators cannot have ref or out parameters", 1623);
        public static readonly ICompilerReferenceError CS1624 = new CompilerReferenceError(@"The body of 'accessor' cannot be an iterator block because 'type' is not an iterator interface type", 1624);
        public static readonly ICompilerReferenceError CS1625 = new CompilerReferenceError(@"Cannot yield in the body of a finally clause", 1625);
        public static readonly ICompilerReferenceError CS1626 = new CompilerReferenceError(@"Cannot yield a value in the body of a try block with a catch clause", 1626);
        public static readonly ICompilerReferenceError CS1627 = new CompilerReferenceError(@"Expression expected after yield return", 1627);
        public static readonly ICompilerReferenceError CS1628 = new CompilerReferenceError(@"Cannot use ref or out parameter 'parameter' inside an anonymous method, lambda expression, or query expression", 1628);
        public static readonly ICompilerReferenceError CS1629 = new CompilerReferenceError(@"Unsafe code may not appear in iterators", 1629);
        public static readonly ICompilerReferenceError CS1630 = new CompilerReferenceError(@"Invalid option 'option' for /errorreport; must be prompt, send, queue, or none", 1630);
        public static readonly ICompilerReferenceError CS1631 = new CompilerReferenceError(@"Cannot yield a value in the body of a catch clause", 1631);
        public static readonly ICompilerReferenceError CS1632 = new CompilerReferenceError(@"Control cannot leave the body of an anonymous method or lambda expression", 1632);
        public static readonly ICompilerReferenceError CS1637 = new CompilerReferenceError(@"Iterators cannot have unsafe parameters or yield types", 1637);
        public static readonly ICompilerReferenceError CS1638 = new CompilerReferenceError(@"'identifier' is a reserved identifier and cannot be used when ISO language version mode is used", 1638);
        public static readonly ICompilerReferenceError CS1639 = new CompilerReferenceError(@"The managed coclass wrapper class signature 'signature' for interface 'interface' is not a valid class name signature", 1639);
        public static readonly ICompilerReferenceError CS1640 = new CompilerReferenceError(@"foreach statement cannot operate on variables of type 'type' because it implements multiple instantiations of 'interface', try casting to a specific interface instantiation", 1640);
        public static readonly ICompilerReferenceError CS1641 = new CompilerReferenceError(@"A fixed size buffer field must have the array size specifier after the field name", 1641);
        public static readonly ICompilerReferenceError CS1642 = new CompilerReferenceError(@"Fixed size buffer fields may only be members of structs.", 1642);
        public static readonly ICompilerReferenceError CS1643 = new CompilerReferenceError(@"Not all code paths return a value in method of type 'type!'", 1643);
        public static readonly ICompilerReferenceError CS1644 = new CompilerReferenceError(@"Feature 'feature' is not part of the standardized ISO C# language specification, and may not be accepted by other compilers", 1644);
        public static readonly ICompilerReferenceError CS1646 = new CompilerReferenceError(@"Keyword, identifier, or string expected after verbatim specifier: @", 1646);
        public static readonly ICompilerReferenceError CS1647 = new CompilerReferenceError(@"An expression is too long or complex to compile near 'code'", 1647);
        public static readonly ICompilerReferenceError CS1648 = new CompilerReferenceError(@"Members of readonly field 'identifier' cannot be modified (except in a constructor or a variable initializer)", 1648);
        public static readonly ICompilerReferenceError CS1649 = new CompilerReferenceError(@"Members of readonly field 'identifier' cannot be passed ref or out (except in a constructor)", 1649);
        public static readonly ICompilerReferenceError CS1650 = new CompilerReferenceError(@"Fields of static readonly field 'identifier' cannot be assigned to (except in a static constructor or a variable initializer)", 1650);
        public static readonly ICompilerReferenceError CS1651 = new CompilerReferenceError(@"Fields of static readonly field 'identifier' cannot be passed ref or out (except in a static constructor)", 1651);
        public static readonly ICompilerReferenceError CS1654 = new CompilerReferenceError(@"Cannot modify members of 'variable' because it is a 'read-only variable type'", 1654);
        public static readonly ICompilerReferenceError CS1655 = new CompilerReferenceError(@"Cannot pass fields of 'variable' as a ref or out argument because it is a 'readonly variable type'", 1655);
        public static readonly ICompilerReferenceError CS1656 = new CompilerReferenceError(@"Cannot assign to 'variable' because it is a 'read-only variable type'", 1656);
        public static readonly ICompilerReferenceError CS1657 = new CompilerReferenceError(@"Cannot pass 'parameter' as a ref or out argument because 'reason''", 1657);
        public static readonly ICompilerReferenceError CS1660 = new CompilerReferenceError(@"Cannot convert anonymous method block to type 'type' because it is not a delegate type", 1660);
        public static readonly ICompilerReferenceError CS1661 = new CompilerReferenceError(@"Cannot convert anonymous method block to delegate type 'delegate type' because the specified block's parameter types do not match the delegate parameter types", 1661);
        public static readonly ICompilerReferenceError CS1662 = new CompilerReferenceError(@"Cannot convert anonymous method block to delegate type 'delegate type' because some of the return types in the block are not implicitly convertible to the delegate return type", 1662);
        public static readonly ICompilerReferenceError CS1663 = new CompilerReferenceError(@"Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double", 1663);
        public static readonly ICompilerReferenceError CS1664 = new CompilerReferenceError(@"Fixed size buffer of length 'length' and type 'type' is too big", 1664);
        public static readonly ICompilerReferenceError CS1665 = new CompilerReferenceError(@"Fixed size buffers must have a length greater than zero", 1665);
        public static readonly ICompilerReferenceError CS1666 = new CompilerReferenceError(@"You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement.", 1666);
        public static readonly ICompilerReferenceError CS1667 = new CompilerReferenceError(@"Attribute 'attribute' is not valid on property or event accessors. It is valid on 'declaration type' declarations only.", 1667);
        public static readonly ICompilerReferenceError CS1670 = new CompilerReferenceError(@"params is not valid in this context", 1670);
        public static readonly ICompilerReferenceError CS1671 = new CompilerReferenceError(@"A namespace declaration cannot have modifiers or attributes", 1671);
        public static readonly ICompilerReferenceError CS1672 = new CompilerReferenceError(@"Invalid option 'option' for /platform; must be anycpu, x86, Itanium or x64", 1672);
        public static readonly ICompilerReferenceError CS1673 = new CompilerReferenceError(@"Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of 'this'. Consider copying 'this' to a local variable outside the anonymous method, lambda expression or query expression and using the local instead.", 1673);
        public static readonly ICompilerReferenceError CS1674 = new CompilerReferenceError(@"'T': type used in a using statement must be implicitly convertible to 'System.IDisposable'", 1674);
        public static readonly ICompilerReferenceError CS1675 = new CompilerReferenceError(@"Enums cannot have type parameters", 1675);
        public static readonly ICompilerReferenceError CS1676 = new CompilerReferenceError(@"Parameter 'number' must be declared with the 'keyword' keyword", 1676);
        public static readonly ICompilerReferenceError CS1677 = new CompilerReferenceError(@"Parameter 'number' should not be declared with the 'keyword' keyword", 1677);
        public static readonly ICompilerReferenceError CS1678 = new CompilerReferenceError(@"Parameter 'number' is declared as type 'type1' but should be 'type2'", 1678);
        public static readonly ICompilerReferenceError CS1679 = new CompilerReferenceError(@"Invalid extern alias for '/reference'; 'identifier' is not a valid identifier", 1679);
        public static readonly ICompilerReferenceError CS1680 = new CompilerReferenceError(@"Invalid reference alias option: 'alias=' -- missing filename.", 1680);
        public static readonly ICompilerReferenceError CS1681 = new CompilerReferenceError(@"You cannot redefine the global extern alias", 1681);
        public static readonly ICompilerReferenceError CS1686 = new CompilerReferenceError(@"Local 'variable' or its members cannot have their address taken and be used inside an anonymous method or lambda expression", 1686);
        public static readonly ICompilerReferenceError CS1688 = new CompilerReferenceError(@"Cannot convert anonymous method block without a parameter list to delegate type 'delegate' because it has one or more out parameters", 1688);
        public static readonly ICompilerReferenceError CS1689 = new CompilerReferenceError(@"Attribute 'Attribute Name' is only valid on methods or attribute classes", 1689);
        public static readonly ICompilerReferenceError CS1703 = new CompilerReferenceError(@"An assembly with the same simple name 'name' has already been imported. Try removing one of the references or sign them to enable side-by-side.", 1703);
        public static readonly ICompilerReferenceError CS1704 = new CompilerReferenceError(@"An assembly with the same simple name 'Assembly Name' has already been imported. Try removing one of the references or sign them to enable side-by-side.", 1704);
        public static readonly ICompilerReferenceError CS1705 = new CompilerReferenceError(@"Assembly 'AssemblyName1' uses 'TypeName' which has a higher version than referenced assembly 'AssemblyName2'", 1705);
        public static readonly ICompilerReferenceError CS1706 = new CompilerReferenceError(@"Expression cannot contain anonymous methods or lambda expressions", 1706);
        public static readonly ICompilerReferenceError CS1708 = new CompilerReferenceError(@"Fixed size buffers can only be accessed through locals or fields", 1708);
        public static readonly ICompilerReferenceError CS1713 = new CompilerReferenceError(@"Unexpected error building metadata name for type Typename1—'Reason'", 1713);
        public static readonly ICompilerReferenceError CS1714 = new CompilerReferenceError(@"The base class or interface of TypeName1 could not be resolved or is invalid", 1714);
        public static readonly ICompilerReferenceError CS1715 = new CompilerReferenceError(@"'Type1': type must be 'Type2' to match overridden member 'MemberName'", 1715);
        public static readonly ICompilerReferenceError CS1716 = new CompilerReferenceError(@"Do not use 'System.Runtime.CompilerServices.FixedBuffer' attribute. Use the 'fixed' field modifier instead.", 1716);
        public static readonly ICompilerReferenceError CS1719 = new CompilerReferenceError(@"Error reading Win32 resource file 'File Name' -- 'reason'", 1719);
        public static readonly ICompilerReferenceError CS1721 = new CompilerReferenceError(@"Class 'class' cannot have multiple base classes: 'class_1' and 'class_2'", 1721);
        public static readonly ICompilerReferenceError CS1722 = new CompilerReferenceError(@"Base class 'class' must come before any interfaces", 1722);
        public static readonly ICompilerReferenceError CS1724 = new CompilerReferenceError(@"Value specified for the argument to 'System.Runtime.InteropServices.DefaultCharSetAttribute' is not valid", 1724);
        public static readonly ICompilerReferenceError CS1725 = new CompilerReferenceError(@"Friend assembly reference 'reference' is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified.", 1725);
        public static readonly ICompilerReferenceError CS1726 = new CompilerReferenceError(@"Friend assembly reference 'reference' is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations.", 1726);
        public static readonly ICompilerReferenceError CS1727 = new CompilerReferenceError(@"Cannot send error report automatically without authorization. Please visit '' to authorize sending error report.", 1727);
        public static readonly ICompilerReferenceError CS1728 = new CompilerReferenceError(@"Cannot bind delegate to 'member' because it is a member of 'type'", 1728);
        public static readonly ICompilerReferenceError CS1729 = new CompilerReferenceError(@"'type' does not contain a constructor that takes 'number' arguments.", 1729);
        public static readonly ICompilerReferenceError CS1730 = new CompilerReferenceError(@"Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations.", 1730);
        public static readonly ICompilerReferenceError CS1731 = new CompilerReferenceError(@"Cannot convert 'expression' to delegate because some of the return types in the block are not implicitly convertible to the delegate return type.", 1731);
        public static readonly ICompilerReferenceError CS1732 = new CompilerReferenceError(@"Expected parameter.", 1732);
        public static readonly ICompilerReferenceError CS1733 = new CompilerReferenceError(@"Expected expression.", 1733);
        public static readonly ICompilerReferenceError CS1900 = new CompilerReferenceError(@"Warning level must be in the range 0-4", 1900);
        public static readonly ICompilerReferenceError CS1902 = new CompilerReferenceError(@"Invalid option 'option' for /debug; must be full or pdbonly", 1902);
        public static readonly ICompilerReferenceError CS1906 = new CompilerReferenceError(@"Invalid option 'option'; Resource visibility must be either 'public' or 'private'", 1906);
        public static readonly ICompilerReferenceError CS1908 = new CompilerReferenceError(@"The type of the argument to the DefaultValue attribute must match the parameter type", 1908);
        public static readonly ICompilerReferenceError CS1909 = new CompilerReferenceError(@"The DefaultValue attribute is not applicable on parameters of type 'type'", 1909);
        public static readonly ICompilerReferenceError CS1910 = new CompilerReferenceError(@"Argument of type 'type' is not applicable for the DefaultValue attribute", 1910);
        public static readonly ICompilerReferenceError CS1912 = new CompilerReferenceError(@"Duplicate initialization of member 'name'.", 1912);
        public static readonly ICompilerReferenceError CS1913 = new CompilerReferenceError(@"Member 'name' cannot be initialized. It is not a field or property.", 1913);
        public static readonly ICompilerReferenceError CS1914 = new CompilerReferenceError(@"Static field 'name' cannot be assigned in an object initializer", 1914);
        public static readonly ICompilerReferenceError CS1917 = new CompilerReferenceError(@"Members of read-only field 'name' of type 'struct name' cannot be assigned with an object initializer because it is of a value type.", 1917);
        public static readonly ICompilerReferenceError CS1918 = new CompilerReferenceError(@"Members of property 'name' of type 'type' cannot be assigned with an object initializer because it is of a value type.", 1918);
        public static readonly ICompilerReferenceError CS1919 = new CompilerReferenceError(@"Unsafe type 'type name' cannot be used in object creation.", 1919);
        public static readonly ICompilerReferenceError CS1920 = new CompilerReferenceError(@"Element initializer cannot be empty.", 1920);
        public static readonly ICompilerReferenceError CS1921 = new CompilerReferenceError(@"The best overloaded method match for 'method' has wrong signature for the initializer element. The initializable Add must be an accessible instance method.", 1921);
        public static readonly ICompilerReferenceError CS1922 = new CompilerReferenceError(@"Collection initializer requires its type 'type' to implement System.Collections.IEnumerable.", 1922);
        public static readonly ICompilerReferenceError CS1925 = new CompilerReferenceError(@"Cannot initialize object of type 'type' with a collection initializer.", 1925);
        public static readonly ICompilerReferenceError CS1926 = new CompilerReferenceError(@"Error reading Win32 manifest file 'filename' -- 'error'.", 1926);
        public static readonly ICompilerReferenceError CS1928 = new CompilerReferenceError(@"'Type' does not contain a definition for 'method' and the best extension method overload 'method' has some invalid arguments.", 1928);
        public static readonly ICompilerReferenceError CS1929 = new CompilerReferenceError(@"Instance argument: cannot convert from 'typeA' to 'typeB'.", 1929);
        public static readonly ICompilerReferenceError CS1930 = new CompilerReferenceError(@"The range variable 'name' has already been declared", 1930);
        public static readonly ICompilerReferenceError CS1931 = new CompilerReferenceError(@"The range variable 'variable' conflicts with a previous declaration of 'variable'.", 1931);
        public static readonly ICompilerReferenceError CS1932 = new CompilerReferenceError(@"Cannot assign 'expression' to a range variable.", 1932);
        public static readonly ICompilerReferenceError CS1933 = new CompilerReferenceError(@"Expression cannot contain query expressions", 1933);
        public static readonly ICompilerReferenceError CS1934 = new CompilerReferenceError(@"Could not find an implementation of the query pattern for source type 'type'. 'method' not found. Consider explicitly specifying the type of the range variable 'name'.", 1934);
        public static readonly ICompilerReferenceError CS1935 = new CompilerReferenceError(@"Could not find an implementation of the query pattern for source type 'type'. 'method' not found. Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?", 1935);
        public static readonly ICompilerReferenceError CS1936 = new CompilerReferenceError(@"Could not find an implementation of the query pattern for source type 'type'. 'method' not found.", 1936);
        public static readonly ICompilerReferenceError CS1937 = new CompilerReferenceError(@"The name 'name' is not in scope on the left side of 'equals'. Consider swapping the expressions on either side of 'equals'.", 1937);
        public static readonly ICompilerReferenceError CS1938 = new CompilerReferenceError(@"The name 'name' is not in scope on the right side of 'equals'. Consider swapping the expressions on either side of 'equals'.", 1938);
        public static readonly ICompilerReferenceError CS1939 = new CompilerReferenceError(@"Cannot pass the range variable 'name' as an out or ref parameter.", 1939);
        public static readonly ICompilerReferenceError CS1940 = new CompilerReferenceError(@"Multiple implementations of the query pattern were found for source type 'type'. Ambiguous call to 'method'.", 1940);
        public static readonly ICompilerReferenceError CS1941 = new CompilerReferenceError(@"The type of one of the expressions in the 'clause' clause is incorrect. Type inference failed in the call to 'method'.", 1941);
        public static readonly ICompilerReferenceError CS1942 = new CompilerReferenceError(@"The type of the expression in the 'clause' clause is incorrect. Type inference failed in the call to 'method'.", 1942);
        public static readonly ICompilerReferenceError CS1943 = new CompilerReferenceError(@"An expression of type 'type' is not allowed in a subsequent from clause in a query expression with source type 'type'. Type inference failed in the call to 'method'.", 1943);
        public static readonly ICompilerReferenceError CS1944 = new CompilerReferenceError(@"An expression tree may not contain an unsafe pointer operation", 1944);
        public static readonly ICompilerReferenceError CS1945 = new CompilerReferenceError(@"An expression tree may not contain an anonymous method expression.", 1945);
        public static readonly ICompilerReferenceError CS1946 = new CompilerReferenceError(@"An anonymous method expression cannot be converted to an expression tree.", 1946);
        public static readonly ICompilerReferenceError CS1947 = new CompilerReferenceError(@"Range variable 'variable name' cannot be assigned to -- it is read only.", 1947);
        public static readonly ICompilerReferenceError CS1948 = new CompilerReferenceError(@"The range variable 'name' cannot have the same name as a method type parameter", 1948);
        public static readonly ICompilerReferenceError CS1949 = new CompilerReferenceError(@"The contextual keyword 'var' cannot be used in a range variable declaration.", 1949);
        public static readonly ICompilerReferenceError CS1950 = new CompilerReferenceError(@"The best overloaded Add method 'name' for the collection initializer has some invalid arguments.", 1950);
        public static readonly ICompilerReferenceError CS1951 = new CompilerReferenceError(@"An expression tree lambda may not contain an out or ref parameter.", 1951);
        public static readonly ICompilerReferenceError CS1952 = new CompilerReferenceError(@"An expression tree lambda may not contain a method with variable arguments", 1952);
        public static readonly ICompilerReferenceError CS1953 = new CompilerReferenceError(@"An expression tree lambda may not contain a method group.", 1953);
        public static readonly ICompilerReferenceError CS1954 = new CompilerReferenceError(@"The best overloaded method match 'method' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.", 1954);
        public static readonly ICompilerReferenceError CS1955 = new CompilerReferenceError(@"Non-invocable member 'name' cannot be used like a method.", 1955);
        public static readonly ICompilerReferenceError CS1958 = new CompilerReferenceError(@"Object and collection initializer expressions may not be applied to a delegate creation expression,", 1958);
        public static readonly ICompilerReferenceError CS1959 = new CompilerReferenceError(@"'name' is of type 'type'. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type.", 1959);
        public static readonly ICompilerReferenceError CS2001 = new CompilerReferenceError(@"Source file 'file' could not be found", 2001);
        public static readonly ICompilerReferenceError CS2003 = new CompilerReferenceError(@"Response file 'file' included multiple times", 2003);
        public static readonly ICompilerReferenceError CS2005 = new CompilerReferenceError(@"Missing file specification for 'option' option", 2005);
        public static readonly ICompilerReferenceError CS2006 = new CompilerReferenceError(@"Command-line syntax error: Missing 'text' for 'option' option", 2006);
        public static readonly ICompilerReferenceError CS2007 = new CompilerReferenceError(@"Unrecognized command-line option: 'option'", 2007);
        public static readonly ICompilerReferenceError CS2008 = new CompilerReferenceError(@"No inputs specified", 2008);
        public static readonly ICompilerReferenceError CS2011 = new CompilerReferenceError(@"Unable to open response file 'file'", 2011);
        public static readonly ICompilerReferenceError CS2012 = new CompilerReferenceError(@"Cannot open 'file' for writing", 2012);
        public static readonly ICompilerReferenceError CS2013 = new CompilerReferenceError(@"Invalid image base number 'value'", 2013);
        public static readonly ICompilerReferenceError CS2015 = new CompilerReferenceError(@"'file' is a binary file instead of a text file", 2015);
        public static readonly ICompilerReferenceError CS2016 = new CompilerReferenceError(@"Code page 'codepage' is invalid or not installed", 2016);
        public static readonly ICompilerReferenceError CS2017 = new CompilerReferenceError(@"Cannot specify /main if building a module or library", 2017);
        public static readonly ICompilerReferenceError CS2018 = new CompilerReferenceError(@"Unable to find messages file 'cscmsgs.dll'", 2018);
        public static readonly ICompilerReferenceError CS2019 = new CompilerReferenceError(@"Invalid target type for /target: must specify 'exe', 'winexe', 'library', or 'module'", 2019);
        public static readonly ICompilerReferenceError CS2020 = new CompilerReferenceError(@"Only the first set of input files can build a target other than 'module'", 2020);
        public static readonly ICompilerReferenceError CS2021 = new CompilerReferenceError(@"File name 'file' is too long or invalid", 2021);
        public static readonly ICompilerReferenceError CS2022 = new CompilerReferenceError(@"Options '/out' and '/target' must appear before source file names", 2022);
        public static readonly ICompilerReferenceError CS2024 = new CompilerReferenceError(@"Invalid file section alignment number '#'", 2024);
        public static readonly ICompilerReferenceError CS2032 = new CompilerReferenceError(@"Character 'character' is not allowed on the command-line or in response files", 2032);
        public static readonly ICompilerReferenceError CS2033 = new CompilerReferenceError(@"Cannot create short filename 'filename' when a long filename with the same short filename already exists ", 2033);
        public static readonly ICompilerReferenceError CS2034 = new CompilerReferenceError(@"A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options.", 2034);
        public static readonly ICompilerReferenceError CS2035 = new CompilerReferenceError(@"Command-line syntax error: Missing ':<number>' for 'compiler_option' option", 2035);
        public static readonly ICompilerReferenceError CS2036 = new CompilerReferenceError(@"The /pdb option requires that the /debug option also be used.", 2036);
        public static readonly ICompilerReferenceError CS5001 = new CompilerReferenceError(@"Program 'program' does not contain a static 'Main' method suitable for an entry point", 5001);
    }
}
