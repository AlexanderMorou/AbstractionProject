/* -----------------------------------------------------------\
|  This code was generated by Oilexer.                        |
|  Version: 1.0.0.0                                           |
|-------------------------------------------------------------|
|  To ensure the code works properly,                         |
|  please do not make any changes to the file.                |
|-------------------------------------------------------------|
|  The specific language is C# (Runtime version: v4.0.30319)  |
|  Sub-tool Name: Oilexer.CSharpCodeTranslator                |
|  Sub-tool Version: 1.0.0.0                                  |
\----------------------------------------------------------- */
using System;
using System.IO;
using AllenCopeland.Abstraction.Slf._Internal.Cli.TypeIdParser;
using AllenCopeland.Abstraction.Slf._Internal.Cli.TypeIdParser.Tokens;
using AllenCopeland.Abstraction.Slf._Internal.Cli.TypeIdParser.Tokens;

namespace AllenCopeland.Abstraction.Slf._Internal.Cli.TypeIdParser
{
    // Module: RootModule
    partial class TypeIdentityParser
    {
        #region TypeIdentityParser nested types
        internal class Scanner
        {
            #region Scanner data members
            private TIAssemblyTerminalsTokStateMachine stateMachineForAssemblyTerminals = new TIAssemblyTerminalsTokStateMachine();

            private TICommonSymbolsTokStateMachine stateMachineForCommonSymbols = new TICommonSymbolsTokStateMachine();

            private TICultureIdentifierTokStateMachine stateMachineForCultureIdentifier = new TICultureIdentifierTokStateMachine();

            private TIHexQWordTokStateMachine stateMachineForHexQWord = new TIHexQWordTokStateMachine();

            private TINestedQualifiedAssemblyIdentifierTokStateMachine stateMachineForNestedQualifiedAssemblyIdentifier = new TINestedQualifiedAssemblyIdentifierTokStateMachine();

            private TINumberTokStateMachine stateMachineForNumber = new TINumberTokStateMachine();

            private TIQualifiedAssemblyIdentifierTokStateMachine stateMachineForQualifiedAssemblyIdentifier = new TIQualifiedAssemblyIdentifierTokStateMachine();

            private TIQualifiedIdentifierTokStateMachine stateMachineForQualifiedIdentifier = new TIQualifiedIdentifierTokStateMachine();

            private TIWhitespaceTokStateMachine stateMachineForWhitespace = new TIWhitespaceTokStateMachine();

            private long bufferSize;

            private long bufferPosition;

            private char[] buffer;

            private TextReader sourceReader;
            #endregion // Scanner data members

            public void Reject(long position)
            {
                this.bufferPosition = position;
            }

            public long Accept(TypeIdParserScanData.Entry entry)
            {
                var result = this.bufferPosition;
                var transition = entry.GetTransition();
                switch (transition.Captures)
                {
                    case TypeIdParserTokens.NestedQualifiedAssemblyIdentifier:
                        this.bufferPosition += stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                        break;
                    case TypeIdParserTokens.QualifiedAssemblyIdentifier:
                        this.bufferPosition += stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                        break;
                    case TypeIdParserTokens.CultureIdentifier:
                        this.bufferPosition += stateMachineForCultureIdentifier.BytesConsumed;
                        break;
                    case TypeIdParserTokens.EndOFile:
                        break;
                    case TypeIdParserTokens.Number:
                        this.bufferPosition += stateMachineForNumber.BytesConsumed;
                        break;
                    case TypeIdParserTokens.HexQWord:
                        this.bufferPosition += stateMachineForHexQWord.BytesConsumed;
                        break;
                    case TypeIdParserTokens.QualifiedIdentifier:
                        this.bufferPosition += stateMachineForQualifiedIdentifier.BytesConsumed;
                        break;
                    case TypeIdParserTokens.Whitespace:
                        this.bufferPosition += stateMachineForWhitespace.BytesConsumed;
                        break;
                    default:
                        switch ((TypeIdParserScanData.SubsetField)entry.SubsetIndex)
	                    {
                            case TypeIdParserScanData.SubsetField.AssemblyTerminalCases:
                                this.bufferPosition += stateMachineForAssemblyTerminals.BytesConsumed;
                                break;
                            case TypeIdParserScanData.SubsetField.CommonSymbolCases:
                                this.bufferPosition += stateMachineForCommonSymbols.BytesConsumed;
                                break;
                            default:
                                break;
	                    }
                        break;
                }
                return result;
            }

            public long Position { get { return this.bufferPosition; } }

            #region Scanner methods
            public TypeIdParserScanData NextToken(TokenTransition valid)
            {
                char @char;
                int aheadDistance = 0;
                bool eof = this.LookAhead(aheadDistance, out @char);
                TypeIdParserScanData result = new TypeIdParserScanData();
                TypeIdParserTokens activeMachinesInTypeIdParserTokens;
                TypeIdParserTokens validTypeIdParserTokens;
                int longest;
                if (eof)
                {
                    // End of file token.
                    if ((valid.Captures & TypeIdParserTokens.EndOFile) == TypeIdParserTokens.EndOFile) 
                        result.AddCapture(null, TypeIdParserTokens.EndOFile);
                    return result;
                }
                if ((@char == 'C') || (@char == 'c'))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & ((((TypeIdParserTokens.CultureIdentifier | TypeIdParserTokens.HexQWord) | TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedIdentifier));
                    if (valid.AssemblyTerminals != AssemblyTerminalCases.None)
                    {
                        this.stateMachineForAssemblyTerminals.Reset(valid.AssemblyTerminals);
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens | TypeIdParserTokens.AssemblyTerminals);
                    }
                    if ((valid.Captures & TypeIdParserTokens.CultureIdentifier) == TypeIdParserTokens.CultureIdentifier)
                        this.stateMachineForCultureIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.HexQWord) == TypeIdParserTokens.HexQWord)
                        this.stateMachineForHexQWord.Reset();
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.AssemblyTerminals) == TypeIdParserTokens.AssemblyTerminals) && !(this.stateMachineForAssemblyTerminals.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.AssemblyTerminals));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) == TypeIdParserTokens.CultureIdentifier) && !(this.stateMachineForCultureIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CultureIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.HexQWord) == TypeIdParserTokens.HexQWord) && !(this.stateMachineForHexQWord.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.HexQWord));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.AssemblyTerminals) != TypeIdParserTokens.None) && this.stateMachineForAssemblyTerminals.IsValidEndState) && (longest < this.stateMachineForAssemblyTerminals.BytesConsumed))
                        longest = this.stateMachineForAssemblyTerminals.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) != TypeIdParserTokens.None) && this.stateMachineForCultureIdentifier.IsValidEndState) && (longest < this.stateMachineForCultureIdentifier.BytesConsumed))
                        longest = this.stateMachineForCultureIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.HexQWord) != TypeIdParserTokens.None) && this.stateMachineForHexQWord.IsValidEndState) && (longest < this.stateMachineForHexQWord.BytesConsumed))
                        longest = this.stateMachineForHexQWord.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.AssemblyTerminals) != TypeIdParserTokens.None) && this.stateMachineForAssemblyTerminals.IsValidEndState) && (longest == this.stateMachineForAssemblyTerminals.BytesConsumed))
                        this.stateMachineForAssemblyTerminals.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) != TypeIdParserTokens.None) && this.stateMachineForCultureIdentifier.IsValidEndState) && (longest == this.stateMachineForCultureIdentifier.BytesConsumed))
                        this.stateMachineForCultureIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.HexQWord) != TypeIdParserTokens.None) && this.stateMachineForHexQWord.IsValidEndState) && (longest == this.stateMachineForHexQWord.BytesConsumed))
                        this.stateMachineForHexQWord.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                }
                else if ((@char == '.') || (@char == '`'))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & ((TypeIdParserTokens.NestedQualifiedAssemblyIdentifier | TypeIdParserTokens.QualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedIdentifier));
                    if (valid.CommonSymbols != CommonSymbolCases.None)
                    {
                        this.stateMachineForCommonSymbols.Reset(valid.CommonSymbols);
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens | TypeIdParserTokens.CommonSymbols);
                    }
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) == TypeIdParserTokens.CommonSymbols) && !(this.stateMachineForCommonSymbols.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CommonSymbols));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest < this.stateMachineForCommonSymbols.BytesConsumed))
                        longest = this.stateMachineForCommonSymbols.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest == this.stateMachineForCommonSymbols.BytesConsumed))
                        this.stateMachineForCommonSymbols.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                }
                else if ((((((@char == 'A') || (@char == 'B')) || (('D' <= @char) && (@char <= 'F'))) || (@char == 'a')) || (@char == 'b')) || (('d' <= @char) && (@char <= 'f')))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & ((((TypeIdParserTokens.CultureIdentifier | TypeIdParserTokens.HexQWord) | TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedIdentifier));
                    if ((valid.Captures & TypeIdParserTokens.CultureIdentifier) == TypeIdParserTokens.CultureIdentifier)
                        this.stateMachineForCultureIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.HexQWord) == TypeIdParserTokens.HexQWord)
                        this.stateMachineForHexQWord.Reset();
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) == TypeIdParserTokens.CultureIdentifier) && !(this.stateMachineForCultureIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CultureIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.HexQWord) == TypeIdParserTokens.HexQWord) && !(this.stateMachineForHexQWord.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.HexQWord));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) != TypeIdParserTokens.None) && this.stateMachineForCultureIdentifier.IsValidEndState) && (longest < this.stateMachineForCultureIdentifier.BytesConsumed))
                        longest = this.stateMachineForCultureIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.HexQWord) != TypeIdParserTokens.None) && this.stateMachineForHexQWord.IsValidEndState) && (longest < this.stateMachineForHexQWord.BytesConsumed))
                        longest = this.stateMachineForHexQWord.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) != TypeIdParserTokens.None) && this.stateMachineForCultureIdentifier.IsValidEndState) && (longest == this.stateMachineForCultureIdentifier.BytesConsumed))
                        this.stateMachineForCultureIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.HexQWord) != TypeIdParserTokens.None) && this.stateMachineForHexQWord.IsValidEndState) && (longest == this.stateMachineForHexQWord.BytesConsumed))
                        this.stateMachineForHexQWord.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                }
                else if ((((((@char == 'N') || (@char == 'P')) || (@char == 'V')) || (@char == 'n')) || (@char == 'p')) || (@char == 'v'))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & (((TypeIdParserTokens.CultureIdentifier | TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedIdentifier));
                    if (valid.AssemblyTerminals != AssemblyTerminalCases.None)
                    {
                        this.stateMachineForAssemblyTerminals.Reset(valid.AssemblyTerminals);
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens | TypeIdParserTokens.AssemblyTerminals);
                    }
                    if ((valid.Captures & TypeIdParserTokens.CultureIdentifier) == TypeIdParserTokens.CultureIdentifier)
                        this.stateMachineForCultureIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.AssemblyTerminals) == TypeIdParserTokens.AssemblyTerminals) && !(this.stateMachineForAssemblyTerminals.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.AssemblyTerminals));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) == TypeIdParserTokens.CultureIdentifier) && !(this.stateMachineForCultureIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CultureIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.AssemblyTerminals) != TypeIdParserTokens.None) && this.stateMachineForAssemblyTerminals.IsValidEndState) && (longest < this.stateMachineForAssemblyTerminals.BytesConsumed))
                        longest = this.stateMachineForAssemblyTerminals.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) != TypeIdParserTokens.None) && this.stateMachineForCultureIdentifier.IsValidEndState) && (longest < this.stateMachineForCultureIdentifier.BytesConsumed))
                        longest = this.stateMachineForCultureIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.AssemblyTerminals) != TypeIdParserTokens.None) && this.stateMachineForAssemblyTerminals.IsValidEndState) && (longest == this.stateMachineForAssemblyTerminals.BytesConsumed))
                        this.stateMachineForAssemblyTerminals.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) != TypeIdParserTokens.None) && this.stateMachineForCultureIdentifier.IsValidEndState) && (longest == this.stateMachineForCultureIdentifier.BytesConsumed))
                        this.stateMachineForCultureIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                }
                else if ((((((('G' <= @char) && (@char <= 'M')) || (('R' <= @char) && (@char <= 'U'))) || (@char == 'Z')) || (('g' <= @char) && (@char <= 'm'))) || (('r' <= @char) && (@char <= 'u'))) || (@char == 'z'))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & (((TypeIdParserTokens.CultureIdentifier | TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedIdentifier));
                    if ((valid.Captures & TypeIdParserTokens.CultureIdentifier) == TypeIdParserTokens.CultureIdentifier)
                        this.stateMachineForCultureIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) == TypeIdParserTokens.CultureIdentifier) && !(this.stateMachineForCultureIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CultureIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) != TypeIdParserTokens.None) && this.stateMachineForCultureIdentifier.IsValidEndState) && (longest < this.stateMachineForCultureIdentifier.BytesConsumed))
                        longest = this.stateMachineForCultureIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CultureIdentifier) != TypeIdParserTokens.None) && this.stateMachineForCultureIdentifier.IsValidEndState) && (longest == this.stateMachineForCultureIdentifier.BytesConsumed))
                        this.stateMachineForCultureIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                }
                else if (('0' <= @char) && (@char <= '9'))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & ((((TypeIdParserTokens.HexQWord | TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) | TypeIdParserTokens.Number) | TypeIdParserTokens.QualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedIdentifier));
                    if ((valid.Captures & TypeIdParserTokens.HexQWord) == TypeIdParserTokens.HexQWord)
                        this.stateMachineForHexQWord.Reset();
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.Number) == TypeIdParserTokens.Number)
                        this.stateMachineForNumber.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.HexQWord) == TypeIdParserTokens.HexQWord) && !(this.stateMachineForHexQWord.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.HexQWord));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.Number) == TypeIdParserTokens.Number) && !(this.stateMachineForNumber.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.Number));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.HexQWord) != TypeIdParserTokens.None) && this.stateMachineForHexQWord.IsValidEndState) && (longest < this.stateMachineForHexQWord.BytesConsumed))
                        longest = this.stateMachineForHexQWord.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.Number) != TypeIdParserTokens.None) && this.stateMachineForNumber.IsValidEndState) && (longest < this.stateMachineForNumber.BytesConsumed))
                        longest = this.stateMachineForNumber.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.HexQWord) != TypeIdParserTokens.None) && this.stateMachineForHexQWord.IsValidEndState) && (longest == this.stateMachineForHexQWord.BytesConsumed))
                        this.stateMachineForHexQWord.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.Number) != TypeIdParserTokens.None) && this.stateMachineForNumber.IsValidEndState) && (longest == this.stateMachineForNumber.BytesConsumed))
                        this.stateMachineForNumber.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                }
                else if (@char == ']')
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier);
                    if (valid.CommonSymbols != CommonSymbolCases.None)
                    {
                        this.stateMachineForCommonSymbols.Reset(valid.CommonSymbols);
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens | TypeIdParserTokens.CommonSymbols);
                    }
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) == TypeIdParserTokens.CommonSymbols) && !(this.stateMachineForCommonSymbols.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CommonSymbols));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest < this.stateMachineForCommonSymbols.BytesConsumed))
                        longest = this.stateMachineForCommonSymbols.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest == this.stateMachineForCommonSymbols.BytesConsumed))
                        this.stateMachineForCommonSymbols.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                }
                else if (((('\t' <= @char) && (@char <= '\v')) || (@char == '\r')) || (@char == ' '))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & (((TypeIdParserTokens.NestedQualifiedAssemblyIdentifier | TypeIdParserTokens.QualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedIdentifier) | TypeIdParserTokens.Whitespace));
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.Whitespace) == TypeIdParserTokens.Whitespace)
                        this.stateMachineForWhitespace.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.Whitespace) == TypeIdParserTokens.Whitespace) && !(this.stateMachineForWhitespace.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.Whitespace));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.Whitespace) != TypeIdParserTokens.None) && this.stateMachineForWhitespace.IsValidEndState) && (longest < this.stateMachineForWhitespace.BytesConsumed))
                        longest = this.stateMachineForWhitespace.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.Whitespace) != TypeIdParserTokens.None) && this.stateMachineForWhitespace.IsValidEndState) && (longest == this.stateMachineForWhitespace.BytesConsumed))
                        this.stateMachineForWhitespace.Inject(result);
                }
                else if (@char == '=')
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & TypeIdParserTokens.QualifiedIdentifier);
                    if (valid.CommonSymbols != CommonSymbolCases.None)
                    {
                        this.stateMachineForCommonSymbols.Reset(valid.CommonSymbols);
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens | TypeIdParserTokens.CommonSymbols);
                    }
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) == TypeIdParserTokens.CommonSymbols) && !(this.stateMachineForCommonSymbols.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CommonSymbols));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest < this.stateMachineForCommonSymbols.BytesConsumed))
                        longest = this.stateMachineForCommonSymbols.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest == this.stateMachineForCommonSymbols.BytesConsumed))
                        this.stateMachineForCommonSymbols.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                }
                else if ((((@char == '&') || (@char == '*')) || (@char == '+')) || (@char == '['))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & (TypeIdParserTokens.NestedQualifiedAssemblyIdentifier | TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (valid.CommonSymbols != CommonSymbolCases.None)
                    {
                        this.stateMachineForCommonSymbols.Reset(valid.CommonSymbols);
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens | TypeIdParserTokens.CommonSymbols);
                    }
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) == TypeIdParserTokens.CommonSymbols) && !(this.stateMachineForCommonSymbols.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CommonSymbols));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest < this.stateMachineForCommonSymbols.BytesConsumed))
                        longest = this.stateMachineForCommonSymbols.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest == this.stateMachineForCommonSymbols.BytesConsumed))
                        this.stateMachineForCommonSymbols.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                }
                else if ((@char == '"') || (@char == ','))
                {
                    activeMachinesInTypeIdParserTokens = TypeIdParserTokens.None;
                    if (valid.CommonSymbols != CommonSymbolCases.None)
                    {
                        this.stateMachineForCommonSymbols.Reset(valid.CommonSymbols);
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens | TypeIdParserTokens.CommonSymbols);
                    }
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) == TypeIdParserTokens.CommonSymbols) && !(this.stateMachineForCommonSymbols.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.CommonSymbols));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest < this.stateMachineForCommonSymbols.BytesConsumed))
                        longest = this.stateMachineForCommonSymbols.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.CommonSymbols) != TypeIdParserTokens.None) && this.stateMachineForCommonSymbols.IsValidEndState) && (longest == this.stateMachineForCommonSymbols.BytesConsumed))
                        this.stateMachineForCommonSymbols.Inject(result);
                }
                else if ((((((((((((((((((((('\0' <= @char) && (@char <= '')) || (@char == '\f')) || (('' <= @char) && (@char <= ''))) || (@char == '!')) || (('#' <= @char) && (@char <= '%'))) || (('\'' <= @char) && (@char <= ')'))) || (@char == '-')) || (@char == '/')) || ((':' <= @char) && (@char <= '<'))) || (('>' <= @char) && (@char <= '@'))) || (@char == 'O')) || (@char == 'Q')) || (('W' <= @char) && (@char <= 'Y'))) || (@char == '\\')) || (@char == '^')) || (@char == '_')) || (@char == 'o')) || (@char == 'q')) || (('w' <= @char) && (@char <= 'y'))) || (('{' <= @char) && (@char <= '\uffff')))
                {
                    activeMachinesInTypeIdParserTokens = (valid.Captures & ((TypeIdParserTokens.NestedQualifiedAssemblyIdentifier | TypeIdParserTokens.QualifiedAssemblyIdentifier) | TypeIdParserTokens.QualifiedIdentifier));
                    if ((valid.Captures & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier)
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier)
                        this.stateMachineForQualifiedAssemblyIdentifier.Reset();
                    if ((valid.Captures & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier)
                        this.stateMachineForQualifiedIdentifier.Reset();
                    validTypeIdParserTokens = activeMachinesInTypeIdParserTokens;
                nextCharacter:
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) == TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) && !(this.stateMachineForNestedQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.NestedQualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) == TypeIdParserTokens.QualifiedAssemblyIdentifier) && !(this.stateMachineForQualifiedAssemblyIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedAssemblyIdentifier));
                    if (((activeMachinesInTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) == TypeIdParserTokens.QualifiedIdentifier) && !(this.stateMachineForQualifiedIdentifier.Next(@char)))
                        activeMachinesInTypeIdParserTokens = (activeMachinesInTypeIdParserTokens & ~(TypeIdParserTokens.QualifiedIdentifier));
                    if (activeMachinesInTypeIdParserTokens != TypeIdParserTokens.None)
                    {
                        aheadDistance++;
                        if (!(this.LookAhead(aheadDistance, out @char)))
                            goto nextCharacter;
                    }
                    longest = 0;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest < this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        longest = this.stateMachineForQualifiedIdentifier.BytesConsumed;
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.NestedQualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForNestedQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForNestedQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForNestedQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedAssemblyIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedAssemblyIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedAssemblyIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedAssemblyIdentifier.Inject(result);
                    if ((((validTypeIdParserTokens & TypeIdParserTokens.QualifiedIdentifier) != TypeIdParserTokens.None) && this.stateMachineForQualifiedIdentifier.IsValidEndState) && (longest == this.stateMachineForQualifiedIdentifier.BytesConsumed))
                        this.stateMachineForQualifiedIdentifier.Inject(result);
                }
                return result;
            }

            private void DoubleBuffer()
            {
                if (this.buffer != null)
                {
                    char[] buffer = new char[(this.buffer.LongLength * 2)];
                    this.buffer.CopyTo(buffer, 0);
                    this.buffer = buffer;
                }
                else
                {
                    this.buffer = new char[1024];
                    this.bufferSize = 0;
                }
            }

            private bool LookAhead(int distance, out char result)
            {
                long lookPoint = (this.bufferPosition + (distance + 1));
            bufferCheck:
                if ((this.buffer == null) || ((this.bufferSize == this.buffer.LongLength) || ((lookPoint + 1024) > this.buffer.LongLength)))
                {
                    this.DoubleBuffer();
                    goto bufferCheck;
                }
                // Check to see if the ahead needs read in.
                if (this.bufferSize < lookPoint)
                {
                    int bytesToRead = ((int)((lookPoint - this.bufferSize)));
                    int readLoc = ((int)((lookPoint - bytesToRead)));
                    if (bytesToRead < 1024)
                        bytesToRead = 1024;
                    int actualBytes = this.sourceReader.Read(this.buffer, readLoc, bytesToRead);
                    this.bufferSize = (this.bufferSize + actualBytes);
                }
                if (lookPoint > this.bufferSize)
                {
                    result = char.MinValue;
                    return true;
                }
                else
                    result = this.buffer[(lookPoint - 1)];
                return false;
            }
            #endregion // Scanner methods
            #region Scanner .ctors
            public Scanner(TextReader sourceReader)
            {
                this.sourceReader = sourceReader;
            }
            #endregion // Scanner .ctors
        }
        #endregion // TypeIdentityParser nested types
    }
}
/* ----------------------------------------------------------------------------------------------\
|  This file took 00:00:00.0226942 to generate.                                                  |
|  Date generated: 4/8/2013 2:00:48 AM                                                           |
|  There were 21 types used by this file                                                         |
|  TypeIdentityParser, TIAssemblyTerminalsTokStateMachine, TICommonSymbolsTokStateMachine,       |
|  TICultureIdentifierTokStateMachine, TIHexByteTokStateMachine, TIHexQWordTokStateMachine,      |
|  TINumberTokStateMachine, TIQualifiedIdentifierTokStateMachine, TIWhitespaceTokStateMachine,   |
|  System.Int64, System.Char, Stream,                                                            |
|  TextReader, TokenTransition, TypeIdParserScanData,                                            |
|  System.Int32, System.Boolean, TypeIdParserTokens,                                             |
|  AssemblyTerminalCases, CommonSymbolCases, System.Void                                         |
|------------------------------------------------------------------------------------------------|
|  There were 1 assemblies referenced:                                                           |
|  mscorlib                                                                                      |
\---------------------------------------------------------------------------------------------- */
